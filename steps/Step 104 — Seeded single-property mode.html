<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Revenue Management</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<link rel="stylesheet" href="./../assets/styles.css" />



<!-- Sync target to hidden bandLow/bandHigh for backward compatibility -->
<script>
(function(){
  function _syncBandsFromTarget(){
    try{
      var t = parseFloat(document.getElementById('comfortTarget')?.value || '95');
      if (!isFinite(t)) t = 95;
      var low = Math.max(80, Math.min(100, t - 2));
      var high = Math.max(80, Math.min(100, t + 1));
      var lowEl = document.getElementById('comfortLow');
      var highEl = document.getElementById('comfortHigh');
      if (lowEl) lowEl.value = String(low);
      if (highEl) highEl.value = String(high);
    }catch(e){}
  }
  window._syncBandsFromTarget = _syncBandsFromTarget;
  document.addEventListener('DOMContentLoaded', function(){
    _syncBandsFromTarget();
    var tgt = document.getElementById('comfortTarget');
    if (tgt){
      tgt.addEventListener('input', _syncBandsFromTarget);
      tgt.addEventListener('change', _syncBandsFromTarget);
    }
  });
})();
</script>


<script>
(function(){
  if (window.__npUnitsInit) return; window.__npUnitsInit = true;
  function getBestTermForFp(fp){ return { termMonths: fp.referenceTerm||14, price: fp.referenceBase }; }

  function buildFpIndex(){
    const idx=new Map();
    if (Array.isArray(window.__fpResults)){
      window.__fpResults.forEach(r=>{ if(r&&r.code) idx.set(String(r.code), { code:r.code, name:r.name||r.code, referenceBase:r.referenceBase, referenceTerm:r.referenceTerm||14 }); });
    } else {
      // Fallback scrape: find "reference: N mo @ $X" in FP debug lines
      document.querySelectorAll('#nlTables .card').forEach(card=>{
        const title = card.querySelector('div[style*="font-weight:600"],h2,h3');
        if (!title) return; const code=(title.textContent||'').trim().split(/\s+/)[0];
        const dbg = Array.from(card.querySelectorAll('.note,div,p')).find(x=>/reference:\s*\d+\s*mo\s*@\s*\$?/i.test(x.textContent||''));
        let ref=null; if(dbg){ const m=(dbg.textContent||'').match(/reference:\s*(\d+)\s*mo\s*@\s*\$?([0-9,]+)/i); if(m){ ref=Number(String(m[2]).replace(/,/g,'')); }}
        if(code && isFinite(ref)) idx.set(code, { code, name:code, referenceBase:ref, referenceTerm:Number((dbg?.match?.(/(\d+)\s*mo/)||[])[1])||14 });
      });
    }
    return idx;
  }

  function buildUnits(){
    const rows = Array.isArray(window.normRows)&&window.normRows.length? window.normRows : (Array.isArray(window.mappedRows)? window.mappedRows:[]);
    const map = (function(){ try{ const ps=window.propertySetup||{}; const pid=ps.property_id||ps.property_name||'default'; return JSON.parse(localStorage.getItem(`rm:fpmap:${pid}`))||{}; }catch(e){ return {}; } })();
    const AMENITY_KEYS = [
      'AmenityAdj','Amenity_Adjustment','AmenityAdjustment','Amenity Delta','Amenity_Delta','Amenity Rent','Amenity_Rent',
      'Amenities','Amenity','UnitAdj','Unit_Adjustment','Unit Adjustment','Unit Premium','Premium','Surcharge',
      'AddlRent','Addl_Rent','Additional Rent','Other Rent','Other_Rent'
    ];
    const list = rows.map(r=>({
      unit: r.UnitID||r.Unit||r.UnitNbr||r.UnitNumber||'',
      floorplan_code: r.FP_CODE || map[String(r.Floorplan||'').trim()] || String(r.Floorplan||'').trim(),
      status: r.Status || r.status || '',
      vacant_date: r.VacantDate || r.vacant_date || null,
      available_date: r.PreleaseStart || r.available_date || null,
      lease_end_date: (r.LeaseEnd || r.Lease_End || r.LeaseEndDate || r.Lease_End_Date || r['Lease End'] || r['Lease End Date'] || r.MoveOut || r.Move_Out || r.MoveOutDate || r.Move_Out_Date || r['Move Out'] || r['Move Out Date'] || null),
      amenity_adj: (function(){ let tot=0; for(const k of AMENITY_KEYS){ if(Object.prototype.hasOwnProperty.call(r,k)) tot+=__toNumberSigned(r[k]); const lk=k.toLowerCase(); for(const kk in r){ if(kk && kk.toLowerCase()===lk){ tot+=__toNumberSigned(r[kk]); break; } } } return tot; })(),
      current: r.Price || r.CurrentRent || null
    })).filter(u=> String(u.unit||'').trim());
    return list.filter(u=>{ const s=unitStatus(u); return s==='Vacant' || s==='On Notice'; });
  }

  // FP map helpers (shared)
  function __fpMapKey(){ try{ const ps=window.propertySetup||{}; return 'rm:fpmap:' + (ps.property_id||ps.property_name||'default'); }catch(e){ return 'rm:fpmap:default'; } }
  function __loadFPMap(){ try{ const raw=localStorage.getItem(__fpMapKey()); return raw? JSON.parse(raw): {}; }catch(e){ return {}; } }

  // Build all units (no status filter) for Unit sub-tab
  function buildUnitsAll(){
    // Prefer normalized rows (already FP_CODE) if available
    if (Array.isArray(window.normRows) && window.normRows.length){
      const AMENITY_KEYS = [
        'AmenityAdj','Amenity_Adjustment','AmenityAdjustment','Amenity Delta','Amenity_Delta','Amenity Rent','Amenity_Rent',
        'Amenities','Amenity','UnitAdj','Unit_Adjustment','Unit Adjustment','Unit Premium','Premium','Surcharge',
        'AddlRent','Addl_Rent','Additional Rent','Other Rent','Other_Rent'
      ];
      return window.normRows.map(r=>({
        unit: r.UnitID||r.Unit||r.UnitNbr||r.UnitNumber||'',
        floorplan_code: r.FP_CODE || String(r.Floorplan||'').trim(),
        status: r.Status || r.status || '',
        vacant_date: r.VacantDate || r.vacant_date || null,
        available_date: r.PreleaseStart || r.available_date || null,
        lease_end_date: (r.LeaseEnd || r.Lease_End || r.LeaseEndDate || r.Lease_End_Date || r['Lease End'] || r['Lease End Date'] || r.MoveOut || r.Move_Out || r.MoveOutDate || r.Move_Out_Date || r['Move Out'] || r['Move Out Date'] || null),
        amenity_adj: (function(){ let tot=0; for(const k of AMENITY_KEYS){ if(Object.prototype.hasOwnProperty.call(r,k)) tot+=__toNumberSigned(r[k]); const lk=k.toLowerCase(); for(const kk in r){ if(kk && kk.toLowerCase()===lk){ tot+=__toNumberSigned(r[kk]); break; } } } return tot; })(),
        current: r.Price || r.CurrentRent || null
      })).filter(u=> String(u.unit||'').trim());
    }
    // Fallback to mappedRows + local FP map
    const rows = Array.isArray(window.mappedRows)? window.mappedRows : [];
    const map = __loadFPMap();
    const AMENITY_KEYS = [
      'AmenityAdj','Amenity_Adjustment','AmenityAdjustment','Amenity Delta','Amenity_Delta','Amenity Rent','Amenity_Rent',
      'Amenities','Amenity','UnitAdj','Unit_Adjustment','Unit Adjustment','Unit Premium','Premium','Surcharge',
      'AddlRent','Addl_Rent','Additional Rent','Other Rent','Other_Rent'
    ];
    const out = rows.map(r=>{
      const rawLbl = String(r.Floorplan||'').trim();
      const code = map[rawLbl] || rawLbl;
      return {
        unit: r.UnitID||r.Unit||r.UnitNbr||r.UnitNumber||'',
        floorplan_code: code,
        status: r.Status || r.status || '',
        vacant_date: r.VacantDate || r.vacant_date || null,
        available_date: r.PreleaseStart || r.available_date || null,
        lease_end_date: (r.LeaseEnd || r.Lease_End || r.LeaseEndDate || r.Lease_End_Date || r['Lease End'] || r['Lease End Date'] || r.MoveOut || r.Move_Out || r.MoveOutDate || r.Move_Out_Date || r['Move Out'] || r['Move Out Date'] || null),
        amenity_adj: (function(){ let tot=0; for(const k of AMENITY_KEYS){ if(Object.prototype.hasOwnProperty.call(r,k)) tot+=__toNumberSigned(r[k]); const lk=k.toLowerCase(); for(const kk in r){ if(kk && kk.toLowerCase()===lk){ tot+=__toNumberSigned(r[kk]); break; } } } return tot; })(),
        current: r.Price || r.CurrentRent || null
      };
    }).filter(u=> String(u.unit||'').trim());
    return out;
  }

  // Persist across re-renders in this session (not localStorage)
  window.__npUnitsState = window.__npUnitsState || { search:'', vac:true, notice:true, page:1 };

  function npSubtabKey(){ return 'np_subtab_v1'; }
  function getNPSubtab(){ try{ return localStorage.getItem(npSubtabKey()) || 'fp'; }catch(e){ return 'fp'; } }
  function setNPSubtab(v){ try{ localStorage.setItem(npSubtabKey(), v==='unit'?'unit':'fp'); }catch(e){} }
  
  // Export for pricing-unit.js module
  window.getNPSubtab = getNPSubtab;
  window.setNPSubtab = setNPSubtab;

  // Unit pricing function is now externalized to ../src/js/pricing-unit.js
  function renderUnitPricingSection_DISABLED(){
    const host=document.getElementById('unitPricingSection'); if(!host) return;
    const isUnitTab = (typeof getNPSubtab==='function' ? getNPSubtab()==='unit' : false);
    if (!isUnitTab && !loadShowUnits()){ host.innerHTML=''; return; }
    const fpIdx=buildFpIndex(); if(!fpIdx.size){ host.innerHTML='<div class="note">No floorplan bases available yet.</div>'; return; }

    const unitsRaw = isUnitTab ? buildUnitsAll() : buildUnits();
    // Available-only gating on Unit tab: keep Vacant / On Notice only
    const units = isUnitTab ? unitsRaw.filter(u=>{ const st=unitStatus(u); return st==='Vacant' || st==='On Notice'; }) : unitsRaw;
    const today=new Date();
    const totalUnits = units.length;
    // Capture current control state from DOM if present; fall back to memory state
    const sEl = document.getElementById('unitSearch');
    const vacEl = document.getElementById('fltVac');
    const notEl = document.getElementById('fltNotice');
    const searchValRaw = (sEl && typeof sEl.value === 'string') ? sEl.value : (window.__npUnitsState.search || '');
    const fltVac = (vacEl && typeof vacEl.checked === 'boolean') ? vacEl.checked : (window.__npUnitsState.vac !== false);
    const fltNotice = (notEl && typeof notEl.checked === 'boolean') ? notEl.checked : (window.__npUnitsState.notice !== false);
    // Update memory state now so filtering uses it
    window.__npUnitsState.search = searchValRaw;
    window.__npUnitsState.vac = !!fltVac;
    window.__npUnitsState.notice = !!fltNotice;
    const searchVal = searchValRaw.trim().toLowerCase();
    let filtered = units.filter(u=>{
      const st=unitStatus(u); // will be Vacant or On Notice only in Unit tab
      const hit = !searchVal || String(u.unit).toLowerCase().includes(searchVal) || String(u.floorplan_code||'').toLowerCase().includes(searchVal);
      if (st==='Vacant') return (fltVac && hit);
      if (st==='On Notice') return (fltNotice && hit);
      return false; // never include Others
    });

    // Make filtered units available to the detail overlay renderer
    window.__npUnitsFiltered = filtered;

    // Global pagination if >500
    // Paging state
    const PER=100; const needsPaging = filtered.length>500; const pages = needsPaging? Math.ceil(filtered.length/PER):1;
    if (window.__npUnitsState.page == null) window.__npUnitsState.page = 1;
    window.__npUnitsPage = Math.min(Math.max(window.__npUnitsState.page,1), pages);
    const page = window.__npUnitsPage;
    const sliceStart=(page-1)*PER, sliceEnd = needsPaging? (sliceStart+PER): filtered.length; const paged = needsPaging? filtered.slice(sliceStart, sliceEnd): filtered;

    // Group by FP using only paged units to avoid heavy DOM
    const byFP = new Map(); let hasUnmapped=false;
    for(const u of paged){ if(!fpIdx.has(String(u.floorplan_code))){ hasUnmapped=true; continue; } const arr=byFP.get(u.floorplan_code)||[]; arr.push(u); byFP.set(u.floorplan_code, arr); }
    const fps = Array.from(byFP.keys()).map(code=>({ code, name: (window.propertySetup?.floorplans||[]).find(x=>String(x.code)===String(code))?.name || code, referenceBase:(fpIdx.get(code)?.referenceBase||null), referenceTerm:(fpIdx.get(code)?.referenceTerm||14) }));
    fps.sort((a,b)=>{ const ka=computeFpSortKey(a), kb=computeFpSortKey(b); return (ka[0]-kb[0]) || ka[1].localeCompare(kb[1]); });

    let html='';
    // Filters row
    html += '<div class="actions" style="gap:8px; align-items:center; margin-bottom:8px">';
    html += `<input type="text" id="unitSearch" placeholder="Search unit or FP code" style="max-width:220px" value="${__np_escape(searchValRaw)}" />`;
    html += `<label><input type="checkbox" id="fltVac" ${fltVac ? 'checked' : ''} /> Vacant</label>`;
    html += `<label><input type="checkbox" id="fltNotice" ${fltNotice ? 'checked' : ''} /> On Notice</label>`;
    if (needsPaging){ html += `<span class="badge" style="margin-left:auto">${filtered.length} units</span>`; }
    html += '</div>';
    if (hasUnmapped) html += '<div class="note" style="margin-bottom:6px">Some units are unmapped — fix in Settings → Floorplan Map.</div>';

    // Groups
    fps.forEach(fp=>{
      const list = sortUnitsForFp(byFP.get(fp.code)||[], today);
      const btnId = `fpUnits_${fp.code}`;
      html += `<section class="card" style="margin:8px 0;">`;
      html += `<div class="actions" style="justify-content:space-between"><button class="btn xs" aria-expanded="true" data-coll="${btnId}">FP ${fp.code} — ${list.length} available</button><div class="pill">Ref: ${formatMoney(fp.referenceBase)} (${fp.referenceTerm} mo)</div></div>`;
      html += `<div id="${btnId}" style="margin-top:6px">`;
      html += '<div style="overflow:auto"><table class="basic" style="width:100%"><thead><tr><th>Unit</th><th>FP</th><th>Status</th><th>Avail / Vacant Age</th><th>Current</th><th>Proposed (final)</th><th>Δ $</th><th>Δ %</th><th>Amenities</th><th class="ta-right w-8">&nbsp;</th></tr></thead><tbody>';
      list.forEach(u=>{
        const st=unitStatus(u);
        const cur=Number(u.current)||NaN;
        const refPrice=Number(fp.referenceBase)||NaN;
        const amen=Number(u.amenity_adj||0);
        const proposedWithAmen = Math.max(0, (isFinite(refPrice)?refPrice:0) + amen);
        
        // Apply vacancy age discount for vacant units
        let finalProposedPrice = proposedWithAmen;
        let vacancyDiscount = 0;
        let vacancyDiscountPct = 0;
        let isDiscounted = false;
        
        if (st === 'Vacant') {
          const vacantDays = vacancyAgeDays(u, today);
          vacancyDiscountPct = vacancyAgeDiscount(vacantDays);
          if (vacancyDiscountPct > 0) {
            vacancyDiscount = (proposedWithAmen * vacancyDiscountPct) / 100;
            finalProposedPrice = Math.max(0, proposedWithAmen - vacancyDiscount);
            isDiscounted = true;
          }
        }
        
        const d$=(isFinite(cur)&&isFinite(finalProposedPrice))? (finalProposedPrice-cur):NaN;
        const dP=(isFinite(cur)&&cur>0)? (d$/cur*100):NaN;
        let availTxt='—'; if(st==='Vacant'){ const age=vacancyAgeDays(u,today); availTxt=`Vacant ${age} days`; } else if(st==='On Notice'){ const dt=onNoticeAvailDate(u); availTxt = dt? ('Avail '+dt.toISOString().slice(0,10)):'On Notice'; }
        let amenCell = '';
        if (amen !== 0){ const sign = amen > 0 ? '+' : '-'; amenCell = sign + formatMoney(Math.abs(amen)); }
        
        // Format proposed price with vacancy age discount styling
        let proposedPriceDisplay = '';
        if (isFinite(finalProposedPrice)) {
          if (isDiscounted) {
            proposedPriceDisplay = `<span style="color: #dc2626; font-weight: 600;">${formatMoney(finalProposedPrice)} 🏷️</span><br><small style="color: #6b7280;">Ref: ${formatMoney(proposedWithAmen)} (-${vacancyDiscountPct.toFixed(1)}%)</small>`;
          } else {
            proposedPriceDisplay = formatMoney(finalProposedPrice);
          }
        } else {
          proposedPriceDisplay = '—';
        }
        
        const key = `${fp.code}::${String(u.unit||'')}`;
        html += `<tr class="unit-row" data-key="${key}" data-base="${isFinite(finalProposedPrice)?finalProposedPrice:''}" data-cur="${isFinite(cur)?cur:''}" data-fp="${fp.code}">`+
                `<td>${__np_escape(String(u.unit||''))}</td>`+
                `<td>${fp.code}</td><td>${st}</td><td>${availTxt}</td><td>${isFinite(cur)?formatMoney(cur):'—'}</td><td>${proposedPriceDisplay}</td><td>${isFinite(d$)?formatMoney(d$):'—'}</td><td>${isFinite(dP)?formatPct(dP):'—'}</td><td>${amenCell}</td></tr>`;
        // Append right-side toggle
        html = html.replace(/<\/tr>$/, `<td class=\"ta-right\"><button class=\"btn-icon unit-expand\" aria-expanded=\"false\" aria-label=\"Show lease term options\" data-unit=\"${__np_escape(String(u.unit||''))}\">▼<\/button><\/td><\/tr>`);
      });
      html += '</tbody></table></div>';
      html += '</div></section>';
    });

    // Global pager
    if (needsPaging){
      html += '<div class="actions" style="justify-content:flex-end; gap:8px; margin-top:8px">';
      html += `<button id="npPrev" class="btn xs" ${page<=1?'disabled':''}>Prev</button>`;
      html += `<span class="badge">${page} / ${pages}</span>`;
      html += `<button id="npNext" class="btn xs" ${page>=pages?'disabled':''}>Next</button>`;
      html += '</div>';
    }

    host.innerHTML = html;
    // Wire filter events
    const reRenderDebounced = __np_debounce(()=>{
      const s2=document.getElementById('unitSearch'); const v2=document.getElementById('fltVac'); const n2=document.getElementById('fltNotice');
      window.__npUnitsState.search = s2 ? s2.value : '';
      window.__npUnitsState.vac = v2 ? !!v2.checked : true;
      window.__npUnitsState.notice = n2 ? !!n2.checked : true;
      window.__npUnitsState.page = 1;
      renderUnitPricingSection();
    }, 150);
    const s=document.getElementById('unitSearch'); if(s && !s.__wired){ s.__wired=true; s.addEventListener('input', reRenderDebounced); }
    const a=document.getElementById('fltVac'); if(a && !a.__wired){ a.__wired=true; a.addEventListener('change', reRenderDebounced); }
    const b=document.getElementById('fltNotice'); if(b && !b.__wired){ b.__wired=true; b.addEventListener('change', reRenderDebounced); }
    host.querySelectorAll('button[data-coll]').forEach(btn=>{ btn.addEventListener('click', ()=>{ const id=btn.getAttribute('data-coll'); const el=document.getElementById(id); const exp=btn.getAttribute('aria-expanded')==='true'; btn.setAttribute('aria-expanded', String(!exp)); if(el) el.style.display = exp? 'none':'block'; }); });
    const prev=document.getElementById('npPrev'), next=document.getElementById('npNext');
    if(prev) prev.onclick=()=>{ window.__npUnitsState.page=Math.max(1,(window.__npUnitsState.page||1)-1); renderUnitPricingSection(); };
    if(next) next.onclick=()=>{ window.__npUnitsState.page=Math.min(pages,(window.__npUnitsState.page||1)+1); renderUnitPricingSection(); };
    // Detail box wiring (overlay) and builder
    // Ensure detail container exists once
    (function ensureDetailBox(){
      const hostBox = document.getElementById('unitDetailBox');
      if (hostBox) return;
      const box = document.createElement('div'); box.id='unitDetailBox'; box.className='unit-detail-box hidden'; box.setAttribute('role','dialog'); box.setAttribute('aria-modal','true'); box.setAttribute('aria-labelledby','udbTitle');
      box.innerHTML = '<div class="udb-card"><div class="udb-header"><div id="udbTitle" class="udb-title"></div><button id="udbClose" class="btn-icon" aria-label="Close">✕</button></div><div class="udb-body"></div></div>';
      const sec = document.getElementById('unitPricingSection'); if (sec) sec.appendChild(box);
      const closer = box.querySelector('#udbClose'); if (closer && !closer.__wired){ closer.__wired=true; closer.addEventListener('click', closeUnitDetail); }
      if (!window.__npDetailEsc){ window.__npDetailEsc=true; document.addEventListener('keydown', (e)=>{ if (e.key==='Escape') closeUnitDetail(); }); }
    })();

    // Close any expanded details on re-render
    closeUnitDetail();
    // Wire expand buttons (click + keyboard) - using event delegation
    const unitSection = document.getElementById('unitPricingSection');
    if (unitSection && !unitSection.__wired) {
      unitSection.__wired = true;
      unitSection.addEventListener('click', (e) => {
        const btn = e.target.closest('.unit-expand');
        if (btn) {
          const unitId = btn.getAttribute('data-unit');
          if (unitId) openUnitDetail(unitId);
        }
      });
      unitSection.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          const btn = e.target.closest('.unit-expand');
          if (btn) {
            e.preventDefault();
            const unitId = btn.getAttribute('data-unit');
            if (unitId) openUnitDetail(unitId);
          }
        }
      });
    }
    // Restore focus nicety
    if (document.activeElement && document.activeElement.id === 'unitSearch'){
      const s3=document.getElementById('unitSearch'); if (s3){ s3.focus(); const len=s3.value.length; try{ s3.setSelectionRange(len,len); }catch(e){} }
    }
  }

  document.addEventListener('DOMContentLoaded', function(){ const cb=document.getElementById('npShowUnits'); if(cb && !cb.__wired){ cb.__wired=true; cb.checked=loadShowUnits(); cb.addEventListener('change', ()=>{ saveShowUnits(cb.checked); window.__renderUnitPricingSection(); }); }});
  
  // Global unit detail functions for event delegation
  function openUnitDetail(unitId){
    if (window.__npOpenUnit === unitId){ closeUnitDetail(); return; }
    window.__npOpenUnit = unitId;
    document.querySelectorAll('.unit-expand').forEach(b=>{ const on=(b.dataset.unit===String(unitId)); b.setAttribute('aria-expanded', on?'true':'false'); b.textContent = on? '▲' : '▼'; });
    renderUnitDetailBox(unitId);
  }
  
  function closeUnitDetail(){ 
    window.__npOpenUnit=null; 
    const box=document.getElementById('unitDetailBox'); 
    if(box) box.classList.add('hidden'); 
    document.querySelectorAll('.unit-expand').forEach(b=>{ b.setAttribute('aria-expanded','false'); b.textContent='▼'; }); 
  }
  
  function renderUnitDetailBox(unitId){
    const box = document.getElementById('unitDetailBox'); if(!box) return;
    const unitsAll = (window.__npUnitsFiltered || []);
    const u = unitsAll.find(x=> String(x.unit||'')=== String(unitId)); if(!u) { closeUnitDetail(); return; }
    const fp = String(u.floorplan_code||'');
    const fpRef = (buildFpIndex().get(fp)||{}).referenceBase || 0;
    const base = Math.max(0, Number(fpRef)||0) + Number(u.amenity_adj||0);
    const cur = Number(u.current)||NaN;
    const title = box.querySelector('#udbTitle'); if (title) title.textContent = `Unit ${unitId} • ${fp}`;
    const body = box.querySelector('.udb-body'); if (body) body.innerHTML = buildTermsHTML(base, cur);
    box.classList.remove('hidden');
  }
  
  function buildTermsHTML(base, cur){
    const cfg = (typeof readCfg==='function') ? readCfg() : {};
    const terms = (cfg && Array.isArray(cfg.nlTerms) && cfg.nlTerms.length) ? cfg.nlTerms : (window.readNLTerms ? window.readNLTerms() : [2,3,4,5,6,7,8,9,10,11,12,13,14]);
    let rows='';
    for(const term of terms){
      const longTerm = term >= 10;
      const shortPct = longTerm ? 0 : (shortTermAdj(100, term)/100 - 1);
      const end = new Date(); end.setMonth(end.getMonth()+term);
      const key = end.getFullYear()+"-"+String(end.getMonth()+1).padStart(2,"0");
      const overCapCount = (typeof overByKey === 'object' && overByKey) ? (overByKey[key] || 0) : 0;
      const overCapPct = (function(){
        const el = $('seasonalityCurve');
        const mm = (typeof seasonalityMultiplier === 'function' && el) ? seasonalityMultiplier(el.value, key) : 1;
        return (mm - 1);
      })();
      const seasArr = (window.__seasonalityArray__ || []);
      const m = Number(seasArr[end.getMonth()]);
      const seasonalityPct = (Number.isFinite(m) ? (m - 1) : 0);
      const seasonalUplift = (seasonalityPct>0 && (overCapCount>0)) ? seasonalityPct : 0;
      const p = base * (1 + (shortPct||0) + (overCapPct||0) + (seasonalUplift||0));
      const d$ = (isFinite(cur) && isFinite(p)) ? (p - cur) : NaN;
      const dP = (isFinite(cur) && cur>0) ? (d$/cur*100) : NaN;
      rows += `<tr><td>${term} mo</td><td>${formatMoney(p)}</td><td>${isFinite(d$)?formatMoney(d$):'—'}</td><td>${isFinite(dP)?formatPct(dP):'—'}</td></tr>`;
    }
    return `<table class="basic" style="width:100%"><thead><tr><th>Term</th><th>Proposed</th><th>Δ $</th><th>Δ %</th></tr></thead><tbody>${rows}</tbody></table>`;
  }
  
  // Sub-tab wiring for New Pricing (Floorplan | Unit) - deduplicated

  function applyNPSubtabUI(sub){
    const bar=document.getElementById('npSubtabBar'); if(!bar) return;
    const btns=bar.querySelectorAll('[role="tab"]');
    btns.forEach(btn=>{
      const isActive = (btn.getAttribute('data-subtab')===sub);
      btn.classList.toggle('active', isActive);
      btn.setAttribute('aria-selected', isActive? 'true':'false');
      btn.setAttribute('tabindex', isActive? '0':'-1');
    });
    const fpPane=document.getElementById('npPaneFP');
    const unitPane=document.getElementById('npPaneUnit');
    if (fpPane) fpPane.classList.toggle('tab-hidden', sub!=='fp');
    if (unitPane) unitPane.classList.toggle('tab-hidden', sub!=='unit');
    // Collapse any expanded unit details when switching away
    if (sub!=='unit'){
      const open=document.querySelector('tr.unit-details');
      if(open){ const btn=document.querySelector('button.unit-exp[aria-expanded="true"]'); if(btn){ btn.setAttribute('aria-expanded','false'); btn.textContent='▸'; } try{ open.parentNode.removeChild(open); }catch(e){} window.__unitExpKey=null; }
    }
    if (sub==='unit'){ 
      try{ 
        // Ensure data is normalized before rendering unit pricing section
        if (typeof window.normalizeRentRoll === 'function') window.normalizeRentRoll();
        if (typeof window.__renderUnitPricingSection==='function') window.__renderUnitPricingSection(); 
      }catch(e){} 
    }
  }

  function wireNPSubtabs(){
    const bar=document.getElementById('npSubtabBar'); if(!bar || bar.__wired) return; bar.__wired=true;
    const activate=(sub)=>{ setNPSubtab(sub); applyNPSubtabUI(sub); };
    bar.addEventListener('click', (e)=>{ const b=e.target.closest('[role="tab"][data-subtab]'); if(!b) return; e.preventDefault(); activate(b.getAttribute('data-subtab')); });
    bar.addEventListener('keydown', (e)=>{
      const tabs=Array.from(bar.querySelectorAll('[role="tab"]'));
      const idx=tabs.indexOf(document.activeElement);
      if (e.key==='ArrowRight' || e.key==='ArrowLeft'){
        e.preventDefault(); const dir=(e.key==='ArrowRight')?1:-1; const next=tabs[(idx+dir+tabs.length)%tabs.length]; if(next) next.focus();
      } else if (e.key==='Enter' || e.key===' '){
        const t=document.activeElement.closest('[role="tab"][data-subtab]'); if (t){ e.preventDefault(); activate(t.getAttribute('data-subtab')); }
      }
    });
    // Force default to Floorplan on load
    setNPSubtab('fp');
    applyNPSubtabUI('fp');
  }

  document.addEventListener('DOMContentLoaded', wireNPSubtabs);
  // Step 69: Base-stage clamp helper (global)
  window.clampBaseToFPCaps = function(base, fpCode){
    try{
      const setup = window.propertySetup || {};
      const fps = setup.floorplans || [];
      const fp = fps.find(x => String(x.code||'') === String(fpCode||''));
      if (!fp) return base;
      const lo = (fp.price_floor_dollars === '' || fp.price_floor_dollars == null) ? -Infinity : Number(fp.price_floor_dollars);
      const hi = (fp.price_ceiling_dollars === '' || fp.price_ceiling_dollars == null) ?  Infinity : Number(fp.price_ceiling_dollars);
      let clamped = base;
      if (Number.isFinite(lo)) clamped = Math.max(clamped, lo);
      if (Number.isFinite(hi)) clamped = Math.min(clamped, hi);
      return clamped;
    }catch(e){ return base; }
  };
  // Step 58: Lock Mode (local-only) — Draft vs Published (read-only structural)
  function $(id){ return document.getElementById(id); }
  function lockKey(){ const ps=window.propertySetup||{}; const pid=ps.property_id||ps.property_name||'default'; return `rm:lockMode:${pid}`; }
  function getLockMode(){ try{ return localStorage.getItem(lockKey())||'draft'; }catch(e){ return 'draft'; } }
  function setLockMode(v){ try{ localStorage.setItem(lockKey(), String(v||'draft')); }catch(e){} }

  function renderLockSwitch(){
    const mode = getLockMode();
    const d = $('btnModeDraft'), p=$('btnModePublished'), chip=$('lockModeChip');
    if (d) d.classList.toggle('primary', mode==='draft');
    if (p) p.classList.toggle('primary', mode==='published');
    if (chip) chip.textContent = 'Mode: ' + (mode==='published'?'Published':'Draft');
  }

  function applyLockState(){
    const mode = getLockMode(); const pub = (mode==='published');
    function setRO(qs){ document.querySelectorAll(qs).forEach(el=>{ if(pub){ el.setAttribute('disabled','disabled'); el.setAttribute('readonly','readonly'); el.classList.add('readonly'); } else { el.removeAttribute('disabled'); el.removeAttribute('readonly'); el.classList.remove('readonly'); } }); }
    // Structural fields in FP Settings
    setRO('#fpSettingsCard [data-fp-field="code"],#fpSettingsCard [data-fp-field="name"],#fpSettingsCard [data-fp-field="units"],#fpSettingsCard [data-fp-field="refask"]');
    // Add/Delete controls
    (function(){ const add=$('addFPBtn'); if(add){ if(pub){ add.setAttribute('disabled','disabled'); add.classList.add('readonly'); } else { add.removeAttribute('disabled'); add.classList.remove('readonly'); } }})();
    document.querySelectorAll('#fpSettingsCard [data-action="del"]').forEach(btn=>{ if(pub){ btn.setAttribute('disabled','disabled'); btn.classList.add('readonly'); } else { btn.removeAttribute('disabled'); btn.classList.remove('readonly'); }});
    // Floorplan Map: selects and Save/Clear disabled in Published
    document.querySelectorAll('#fpMapTableBody select').forEach(sel=>{ if(pub){ sel.setAttribute('disabled','disabled'); sel.classList.add('readonly'); } else { sel.removeAttribute('disabled'); sel.classList.remove('readonly'); } });
    const mSave=$('fpMapSaveBtn'), mClr=$('fpMapClearBtn');
    [mSave,mClr,$('fpMapSave'),$('fpMapClear')].forEach(b=>{ if(!b) return; if(pub){ b.setAttribute('disabled','disabled'); b.classList.add('readonly'); } else { b.removeAttribute('disabled'); b.classList.remove('readonly'); } });
  }

  function wireLock(){
    const d=$('btnModeDraft'), p=$('btnModePublished');
    if (d) d.addEventListener('click', ()=>{ setLockMode('draft'); renderLockSwitch(); applyLockState(); });
    if (p) p.addEventListener('click', ()=>{ setLockMode('published'); renderLockSwitch(); applyLockState(); });
    renderLockSwitch(); applyLockState();
  }

  // Expose for renderers
  window.__applyLockState = applyLockState; window.__renderLockSwitch = renderLockSwitch;
  document.addEventListener('DOMContentLoaded', wireLock);
})();
</script>

<script>
(function(){
  // Step 59R: Autocapture labels (unified candidates key)
  function uniqueLabels(rows){ const s = new Set(); (rows||[]).forEach(r=>{ const v = String(r.Floorplan||'').trim(); if (v) s.add(v); }); return Array.from(s); }
  function fpMapCandidatesKey(){ const ps=(window.propertySetup||{}); const pid=ps.property_id||ps.property_name||'default'; return `rm:fpmap:candidates:${pid}`; }
  function loadFPCandidates(){ try{ const raw=localStorage.getItem(fpMapCandidatesKey()); return raw? JSON.parse(raw): []; }catch(e){ return []; } }
  function saveFPCandidates(list){ try{ localStorage.setItem(fpMapCandidatesKey(), JSON.stringify(list||[])); }catch(e){} }

  const cm = document.getElementById('confirmMapping');
  if (cm) cm.addEventListener('click', ()=> setTimeout(capture, 60));

  let lastSig = '';
  const iv = setInterval(() => {
    const rows = Array.isArray(window.mappedRows) ? window.mappedRows : null;
    if (!rows || rows.length === 0) return;
    const sig = rows.length + ':' + Object.keys(rows[0]||{}).join(',');
    if (sig === lastSig) return;
    lastSig = sig;
    capture();
  }, 400);

  function capture(){
    try{
      const rows = Array.isArray(window.mappedRows) ? window.mappedRows : [];
      const labels = uniqueLabels(rows);
      if (labels.length){
        saveFPCandidates(labels);
        if (typeof renderFPMapCard === 'function') renderFPMapCard();
      }
    }catch(e){}
  }
})();
</script>

<script>
// Step 59R: Floorplan Map — options from Settings, unified candidates, session-gated render
(function(){
  function $(id){ return document.getElementById(id); }
  // Storage keys (canonical names)
  function fpMapStorageKey(){ const ps=window.propertySetup||{}; const pid=ps.property_id||ps.property_name||'default'; return `rm:fpmap:${pid}`; }
  function fpMapCandidatesKey(){ const ps=window.propertySetup||{}; const pid=ps.property_id||ps.property_name||'default'; return `rm:fpmap:candidates:${pid}`; }
  function loadFPMap(){ try{ return JSON.parse(localStorage.getItem(fpMapStorageKey())) || {}; }catch(e){ return {}; } }
  function saveFPMap(map){ try{ localStorage.setItem(fpMapStorageKey(), JSON.stringify(map||{})); }catch(e){} }
  function clearFPMap(){ try{ localStorage.removeItem(fpMapStorageKey()); }catch(e){} }
  function loadFPCandidates(){ try{ return JSON.parse(localStorage.getItem(fpMapCandidatesKey())) || []; }catch(e){ return []; } }
  function saveFPCandidates(labels){ try{ localStorage.setItem(fpMapCandidatesKey(), JSON.stringify(labels||[])); }catch(e){} }
  function clearFPCandidates(){ try{ localStorage.removeItem(fpMapCandidatesKey()); }catch(e){} }
  function getFPNameByCode(code){ try{ const list=(window.propertySetup&&window.propertySetup.floorplans)||[]; const fp=list.find(x=>String(x.code||'')===String(code||'')); return fp? (fp.name||'') : ''; }catch(e){ return ''; } }
  function getCodes(){ try{ return ((window.propertySetup&&window.propertySetup.floorplans)||[]).map(fp=>String(fp.code||'').trim()).filter(Boolean); }catch(e){ return []; } }

  // Session upload flag
  const SS_FLAG = 'rm:session:hasUpload';
  function setHasUpload(){ try{ sessionStorage.setItem(SS_FLAG,'1'); }catch(e){} }
  function hasUpload(){ try{ return sessionStorage.getItem(SS_FLAG)==='1'; }catch(e){ return false; } }
  window.setHasUpload = setHasUpload; window.hasUpload = hasUpload;

  // Capture labels from latest upload (mappedRows), suggest defaults, and refresh card
  function captureFPLabelsFromUpload(){
    try{
      const rows = window.mappedRows || [];
      const labels = Array.from(new Set(rows.map(r=> String(r.Floorplan||'').trim()).filter(Boolean))).sort();
      saveFPCandidates(labels);
      autoMapFromSettings();
      if (typeof renderFPMapCard==='function') renderFPMapCard();
    }catch(e){}
  }

  // Auto-map based on Settings codes (exact or first-token)
  function autoMapFromSettings(){
    try{
      const labels = loadFPCandidates();
      if (!labels || !labels.length) return;
      const codes = getCodes(); if (!codes.length) return;
      const codeLC = codes.map(c=>String(c).toLowerCase());
      const map = loadFPMap(); let changed=false;
      const firstTok = s=> (String(s||'').replace(/[×✕✖]/g,'x').trim().split(/\s+/)[0]||'').toLowerCase();
      labels.forEach(lbl=>{
        if (map[lbl]) return;
        const n = String(lbl||'').trim().toLowerCase();
        const t = firstTok(lbl);
        const idxExact = codeLC.indexOf(n);
        const idxTok = codeLC.indexOf(t);
        if (idxExact>=0) { map[lbl]=codes[idxExact]; changed=true; }
        else if (idxTok>=0) { map[lbl]=codes[idxTok]; changed=true; }
      });
      if (changed){ saveFPMap(map); const chip=document.getElementById('fpMapSavedChip'); if (chip) chip.textContent='Saved locally ' + new Date().toLocaleTimeString(); if (typeof renderFPMapCard==='function') renderFPMapCard(); }
    }catch(e){}
  }
  window.autoMapFromSettings = autoMapFromSettings;

  // Render mapping card using candidates; hide if no upload this session
  window.renderFPMapCard = function renderFPMapCard(){
    const tbody = $('fpMapTableBody'); const empty = $('fpMapEmptyAlt');
    if (!tbody || !empty) return;
    const labels = loadFPCandidates(); const map = loadFPMap(); const codes = getCodes();
    tbody.innerHTML = '';
    if (!hasUpload() || !labels.length){ empty.textContent='No rent roll uploaded yet.'; empty.style.display='block'; return; }
    empty.style.display='none';
    labels.forEach(lbl=>{
      const tr=document.createElement('tr');
      const tdL=document.createElement('td'); tdL.textContent=lbl; tr.appendChild(tdL);
      const tdS=document.createElement('td');
      const sel=document.createElement('select'); sel.setAttribute('aria-label', `Map ${lbl} to code`);
      const opt0=document.createElement('option'); opt0.value=''; opt0.textContent='(Select code)'; sel.appendChild(opt0);
      codes.forEach(c=>{ const o=document.createElement('option'); o.value=c; o.textContent=c; sel.appendChild(o); });
      sel.value = map[lbl] || '';
      sel.addEventListener('change', ()=>{ const m=loadFPMap(); if(sel.value) m[lbl]=sel.value; else delete m[lbl]; saveFPMap(m); renderFPMapCard(); const chip=$('fpMapSavedChip'); if(chip) chip.textContent='Saved locally ' + new Date().toLocaleTimeString(); });
      tdS.appendChild(sel); tr.appendChild(tdS);
      const tdP=document.createElement('td'); const code=map[lbl]||''; const name= code? getFPNameByCode(code):''; tdP.textContent = code? (name? `${code} — ${name}` : code) : '—'; tr.appendChild(tdP);
      tbody.appendChild(tr);
    });
    try{ if (typeof window.__applyLockState==='function') window.__applyLockState(); }catch(e){}
  };

  function bindFPMapButtons(){
    const save=$('fpMapSaveBtn'); const clr=$('fpMapClearBtn'); const clrLegacy=$('fpMapClear');
    if (save) save.addEventListener('click', ()=>{ const chip=$('fpMapSavedChip'); if (chip) chip.textContent='Saved locally ' + new Date().toLocaleTimeString(); });
    const doClear = ()=>{ if (!confirm('Clear all label→code mappings for this property?')) return; clearFPMap(); clearFPCandidates(); renderFPMapCard(); const chip=$('fpMapSavedChip'); if (chip) chip.textContent='Cleared'; };
    if (clr) clr.addEventListener('click', doClear);
    if (clrLegacy) clrLegacy.addEventListener('click', doClear);
  }
  
  // Safe fallback renderer for Unit tab
  function renderUnitPricingSection_DISABLED() {
    console.warn('[RM] Unit pricing section renderer not available - using fallback');
    const container = document.getElementById('unit-pricing-container');
    if (container) {
      container.innerHTML = `
        <div class="note" style="padding: 20px; text-align: center; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px;">
          <h4>Unit Pricing Not Available</h4>
          <p>Please upload a rent roll and run pricing to enable unit-level details.</p>
        </div>
      `;
    }
  }
  
  // Ensure safe fallback is available
  if (typeof window.__renderUnitPricingSection === 'undefined') {
    window.__renderUnitPricingSection = renderUnitPricingSection_DISABLED;
  }

  // Wire confirm overlay buttons
  document.addEventListener('DOMContentLoaded', () => {
    const confirmBtn = document.getElementById('confirmUpload');
    const editBtn = document.getElementById('editMapping');
    const overlay = document.getElementById('confirmOverlay');
    
    if (confirmBtn) {
      confirmBtn.addEventListener('click', () => {
        overlay.style.display = 'none';
        // Proceed with normal flow
        setTimeout(() => {
          try {
            if (typeof setHasUpload === 'function') setHasUpload();
            renderFPMapCard();
            normalizeRentRoll();
            if (typeof window.refreshChartsFromRentRoll === 'function') window.refreshChartsFromRentRoll();
          } catch (e) {}
        }, 60);
      });
    }
    
    if (editBtn) {
      editBtn.addEventListener('click', () => {
        overlay.style.display = 'none';
        // Show mapping table for editing
        document.getElementById('automap').style.display = 'block';
      });
    }
  });

  // Wire on load and on mapping confirm
  document.addEventListener('DOMContentLoaded', ()=>{ try{ renderFPMapCard(); bindFPMapButtons(); }catch(e){} });
  const cm=document.getElementById('confirmMapping'); if (cm){ cm.addEventListener('click', ()=> setTimeout(()=>{ try{ if (typeof setHasUpload==='function') setHasUpload(); captureFPLabelsFromUpload(); showConfirmOverlay(); }catch(e){} }, 60)); }
})();
</script>

<script>
// Step 56: Floorplan CODE mapping + normalization and New Pricing override
(function(){
  function $(id){ return document.getElementById(id); }
  const MAP_NS = 'rm:fpmap:';
  function getFPMapKey(){ const ps=(window.propertySetup||{}); return MAP_NS + (ps.property_id || ps.property_name || 'default'); }
  function getAllCodes(){ try{ return (window.propertySetup.floorplans||[]).map(f=>String(f.code||'')).filter(Boolean);}catch(e){return [];} }
  function loadFPMap(){ try{ const raw=localStorage.getItem(getFPMapKey()); return raw? JSON.parse(raw) : {}; }catch(e){ return {}; } }
  function saveFPMap(map){ try{ localStorage.setItem(getFPMapKey(), JSON.stringify(map||{})); }catch(e){} }
  function clearFPMap(){ try{ localStorage.removeItem(getFPMapKey()); }catch(e){} }
  function uniqueLabels(rows){ const s=new Set(); (rows||[]).forEach(r=>{ const v=String(r.Floorplan||'').trim(); if(v) s.add(v); }); return Array.from(s); }
  function applyFPMapToRows(rows, map, codes){ const out=[]; const unm=new Set(); const set=new Set(codes||[]); (rows||[]).forEach(r=>{ const lbl=String(r.Floorplan||'').trim(); let code = map && map[lbl]; if(!code && set.has(lbl)) code=lbl; if(code) out.push(Object.assign({}, r, { FP_CODE: code, FloorplanLabel: lbl })); else { unm.add(lbl); out.push(Object.assign({}, r, { FloorplanLabel: lbl })); } }); return { rows: out, unmapped: unm }; }

  function renderFPMapCard(){
    /* Legacy renderer (fpMapWrap/fpMapEmpty). Disabled in Step 57 in favor of table-based renderer. */
  }

  function normalizeRentRoll(){
    const rows = Array.isArray(window.mappedRows) ? window.mappedRows : [];
    const map = loadFPMap(); const codes = getAllCodes();
    const res = applyFPMapToRows(rows, map, codes);
    window.normRows = res.rows; window.unmappedLabels = Array.from(res.unmapped||[]);
    try{
      // Step 67: Auto-refresh charts from rent roll if mapping is valid
      if (Array.isArray(window.normRows) && window.normRows.length){
        if (typeof window.refreshChartsFromRentRoll==='function') window.refreshChartsFromRentRoll();
        const unm = window.unmappedLabels||[];
        if (typeof window.hasUpload==='function' && window.hasUpload() && unm.length===0){
          if (typeof setTabDisabled==='function') setTabDisabled('charts', false);
        }
      }
    }catch(e){}
  }
  
  // Expose normalizeRentRoll to window object for unit pricing tab
  window.normalizeRentRoll = normalizeRentRoll;

  document.addEventListener('DOMContentLoaded', ()=>{ try{ renderFPMapCard(); }catch(e){} try{ normalizeRentRoll(); }catch(e){} });
  const cm = document.getElementById('confirmMapping'); if (cm) cm.addEventListener('click', ()=> setTimeout(()=>{ try{ if (typeof setHasUpload==='function') setHasUpload(); renderFPMapCard(); normalizeRentRoll(); if (typeof window.refreshChartsFromRentRoll==='function') window.refreshChartsFromRentRoll(); }catch(e){} }, 60));

  // Guard New run if unmapped
  if (typeof window.canRun === 'function'){
    const _old = window.canRun;
    window.canRun = function(){ const ok=_old(); if(!ok) return false; try{ normalizeRentRoll(); }catch(e){} const unm = window.unmappedLabels||[]; if (unm.length){ const nl=$('nlTables'); if(nl){ nl.innerHTML = `<div class=\"note\" style=\"border:1px solid #7f1d1d;background:#1b0f12;color:#fca5a5;padding:8px;border-radius:8px;\">Unmapped floorplan labels: ${unm.slice(0,12).join(', ')}. <a href=\"#\" id=\"goMap\">Map them on Settings → Floorplan Map</a>.</div>`; setTimeout(()=>{ const a=$('goMap'); if (a) a.onclick=(e)=>{ e.preventDefault(); if (typeof setTab==='function') setTab('settings'); const card=$('fpMapCard'); if(card) card.scrollIntoView({behavior:'smooth'}); }; },0);} return false; } return true; };
  }

  // Normalize New Pricing to use FP_CODE grouping while preserving UI
  if (typeof window.renderNewLease === 'function'){
    const _origRender = window.renderNewLease;
    window.renderNewLease = function(cfg, norm, tState){
      const rows = (Array.isArray(window.normRows) && window.normRows.some(r=>r.FP_CODE))
        ? window.normRows.map(r=> Object.assign({}, r, { Floorplan: r.FP_CODE }))
        : (norm||[]);
      _origRender(cfg, rows, tState);
      // Add normalization footnote
      const wrap = $('nlTables'); if (wrap){ wrap.insertAdjacentHTML('afterbegin', '<div class="note">Floorplans normalized to codes; CSV labels shown for reference only.</div>'); }
    };
  }
})();
</script>

<script>
(function(){
  // Step 52: Floorplan Settings manual editor (Settings tab)
  function $(id){ return document.getElementById(id); }
  function clamp(x, lo, hi){ return Math.min(Math.max(x, lo), hi); }
  function toInt(v, d=0){ const n=Number(v); return Number.isFinite(n)? Math.round(n): d; }
  // Note: clampBaseToFPCaps is defined globally for reuse across modules.
  function normalizeCode(s){ return String(s||'').trim().replace(/\s+/g,' '); }
  const LS_KEY = 'rm:propertySetup:floorplans';

  // Initialize state
  window.propertySetup = window.propertySetup || {
    community_settings: { target_occupancy_pct: 95 },
    floorplans: []
  };

  // Helpers: compute duplicate codes map
  function dupMap(rows){ const m=new Map(); for(const r of rows){ const c=normalizeCode(r.code); if(!c) continue; m.set(c,(m.get(c)||0)+1);} return m; }
  function bandIssues(low, high){
    const out = { lowGtHigh:false, outOfRange:false };
    const l=Number(low), h=Number(high);
    if (Number.isFinite(l) && Number.isFinite(h) && l>h) out.lowGtHigh=true;
    if ((l && (l<70 || l>100)) || (h && (h<70 || h>100))) out.outOfRange = true;
    return out;
  }

  // Validity checks for saving
  function isRowValid(r){
    if (!String(r.code||'').trim()) return false;
    if (!String(r.name||'').trim()) return false;
    const l = Number(r.band_low_pct), h = Number(r.band_high_pct);
    if (!Number.isFinite(l) || !Number.isFinite(h)) return false;
    if (l<70 || l>100 || h<70 || h>100) return false;
    if (l>h) return false;
    if (Number(r.units)<0) return false;
    if (Number(r.gap_to_next_tier_dollars)<0) return false;
    if (Number(r.reference_ask)<0) return false;
    if (r.price_floor_dollars!=null && String(r.price_floor_dollars)!=='' && Number(r.price_floor_dollars)<0) return false;
    if (r.price_ceiling_dollars!=null && String(r.price_ceiling_dollars)!=='' && Number(r.price_ceiling_dollars)<0) return false;
    return true;
  }
  function isTableValid(){
    const rows = window.propertySetup.floorplans || [];
    const dups = dupMap(rows);
    for(const r of rows){ if (String(r.code||'') && dups.get(normalizeCode(r.code))>1) return false; }
    return rows.every(isRowValid);
  }

  function updateSavedChip(text){
    const chip = document.getElementById('fpSavedChip');
    if (!chip) return;
    if (text){ chip.textContent = text; chip.style.display='inline-block'; }
    else { chip.textContent=''; chip.style.display='none'; }
  }

  function saveFPsLocal(){
    try{
      const rows = (window.propertySetup.floorplans || []).map(r=>{
        const { stop_down_buffer_dollars, ...rest } = (r||{});
        return rest;
      });
      window.propertySetup.floorplans = rows; // normalize in-memory as well
      localStorage.setItem(LS_KEY, JSON.stringify(rows));
      const t = new Date().toLocaleTimeString();
      updateSavedChip('Saved locally ' + t);
    }catch(e){ /* ignore */ }
  }
  function maybeSaveLocal(){ if (isTableValid()) saveFPsLocal(); }
  function loadFPsLocal(){
    try{
      const rows = window.propertySetup.floorplans || [];
      if (rows.length) return;
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) {
        window.propertySetup.floorplans = parsed.map(r=>{ const { stop_down_buffer_dollars, ...rest } = (r||{}); return rest; });
      }
    }catch(e){ /* ignore */ }
  }

  // Render table body from state
  function renderFPTable(){
    const tbody = $('fpTableBody'); if(!tbody) return;
    const rows = window.propertySetup.floorplans || [];
    const dups = dupMap(rows);
    const esc = s=>String(s??'').replace(/&/g,'&amp;').replace(/</g,'&lt;');
    // derive bedroom tiers once to disable gap field on lowest tier
    function _bedOf(code,name){
      const c=String(code||''); const s=(String(code||'')+' '+String(name||'')).toLowerCase();
      if (/\b(s0|studio|0x1)\b/i.test(c) || /\b(studio|0x1)\b/.test(String(name||'').toLowerCase())) return 0;
      if (/\b1x1\b/i.test(s) || /\b1\s*br\b/i.test(s)) return 1;
      if (/\b2x2\b/i.test(s) || /\b2\s*br\b/i.test(s)) return 2;
      if (/\b3x\d\b/i.test(s) || /\b3\s*br\b/i.test(s)) return 3;
      if (/\b4x\d\b/i.test(s) || /\b4\s*br\b/i.test(s)) return 4;
      if (/^a/i.test(c)) return 1; if (/^b/i.test(c)) return 2; if (/^c/i.test(c)) return 3;
      const m1=s.match(/(\d)\s*br/); if(m1) return parseInt(m1[1]); const m2=s.match(/(\d)\s*x\s*(\d)/); if(m2) return parseInt(m2[1]);
      return 1;
    }
    const minTier = rows.length ? Math.min(...rows.map(r=>_bedOf(r.code,r.name))) : 0;
    const maxTier = rows.length ? Math.max(...rows.map(r=>_bedOf(r.code,r.name))) : 0;

    tbody.innerHTML = rows.map((r,idx)=>{
      const code = normalizeCode(r.code);
      const issues = bandIssues(r.band_low_pct, r.band_high_pct);
      const badges = [];
      if (code && dups.get(code)>1) badges.push('<span class="badge danger">Duplicate code</span>');
      if (issues.lowGtHigh) badges.push('<span class="badge danger">Low > High</span>');
      if (issues.outOfRange) badges.push('<span class="badge warn">Outside range</span>');
      const reqClass = (v)=> (String(v||'').trim()? '' : 'invalid');
      return `<tr data-row="${idx}">
        <td style="color:#94a3b8">⋮⋮</td>
        <td>
          ${badges.join(' ')}
          <input type="text" maxlength="12" value="${esc(r.code)}" aria-label="Code" class="${reqClass(r.code)}" data-k="code" data-i="${idx}" data-fp-field="code" style="width:120px" />
        </td>
        <td>
          <input type="text" maxlength="40" value="${esc(r.name)}" aria-label="Name" class="${reqClass(r.name)}" data-k="name" data-i="${idx}" data-fp-field="name" style="width:160px" />
        </td>
        <td>
          <input type="number" step="1" min="0" value="${toInt(r.units,0)}" aria-label="Units" data-k="units" data-i="${idx}" data-fp-field="units" style="width:90px" />
        </td>
        <td>
          <input type="number" step="0.5" min="70" max="100" value="${Number(r.band_low_pct||0)}" aria-label="Band Low %" data-k="band_low_pct" data-i="${idx}" data-fp-field="bandlow" style="width:110px" />
        </td>
        <td>
          <input type="number" step="0.5" min="70" max="100" value="${Number(r.band_high_pct||0)}" aria-label="Band High %" data-k="band_high_pct" data-i="${idx}" data-fp-field="bandhigh" style="width:110px" />
        </td>
        <td>
          ${(_bedOf(r.code,r.name)===maxTier)
            ? `<input type="number" step="1" min="0" value="0" aria-label="Min Gap to Next Tier $" data-k="gap_to_next_tier_dollars" data-i="${idx}" data-fp-field="gapnew" style="width:170px" disabled readonly class="readonly" />`
            : `<input type=\"number\" step=\"1\" min=\"0\" value=\"${toInt(r.gap_to_next_tier_dollars||0,0)}\" aria-label=\"Min Gap to Next Tier $\" data-k=\"gap_to_next_tier_dollars\" data-i=\"${idx}\" data-fp-field=\"gapnew\" style=\"width:170px\" />`}
        </td>
        <td>
          <input type="number" step="1" min="0" value="${toInt(r.reference_ask||0,0)}" aria-label="Starting Rent $" data-k="reference_ask" data-i="${idx}" data-fp-field="refask" style="width:130px" />
        </td>
        <td>
          <input type="number" step="1" min="0" value="${(r.price_floor_dollars!=null&&String(r.price_floor_dollars)!=='')?toInt(r.price_floor_dollars,0):''}" aria-label="Price Floor ($)" data-k="price_floor_dollars" data-i="${idx}" data-fp-field="pfloor" style="width:120px" />
        </td>
        <td>
          <input type="number" step="1" min="0" value="${(r.price_ceiling_dollars!=null&&String(r.price_ceiling_dollars)!=='')?toInt(r.price_ceiling_dollars,0):''}" aria-label="Price Ceiling ($)" data-k="price_ceiling_dollars" data-i="${idx}" data-fp-field="pceil" style="width:120px" />
        </td>
        <td>
          <button class="btn xs" data-action="del" data-i="${idx}" aria-label="Delete row">🗑️</button>
        </td>
      </tr>`;
    }).join('');

    // Wire inputs
    tbody.querySelectorAll('input').forEach(inp=>{
      inp.addEventListener('input', onInputValidate);
      inp.addEventListener('change', onCommit);
      inp.addEventListener('blur', onCommit);
    });
    tbody.querySelectorAll('[data-action="del"]').forEach(btn=>{
      btn.addEventListener('click', (e)=>{ e.preventDefault(); deleteFPRow(Number(btn.dataset.i)); });
    });
    try{ if (typeof window.__applyLockState==='function') window.__applyLockState(); }catch(e){}
  }

  function onInputValidate(e){
    const inp = e.target; const key = inp.dataset.k;
    if (inp.type==='text'){
      const v = String(inp.value||'').trim();
      inp.classList.toggle('invalid', v.length===0);
    } else if (inp.type==='number'){
      const v = inp.value;
      const isNum = v!=='' && !isNaN(Number(v));
      inp.classList.toggle('invalid', !isNum);
      if (isNum && (key==='band_low_pct' || key==='band_high_pct')){
        const n = Number(v);
        inp.classList.toggle('warn', n<70 || n>100);
      } else {
        inp.classList.remove('warn');
      }
    }
  }

  function onCommit(e){
    const inp = e.target; const idx = Number(inp.dataset.i); const key = inp.dataset.k;
    if (!key || Number.isNaN(idx)) return;
    let val = inp.type==='number' ? Number(inp.value) : inp.value;
    setFP(idx, key, val);
  }

  function addFPRow(){
    const rows = window.propertySetup.floorplans || (window.propertySetup.floorplans=[]);
    rows.push({ code:"", name:"", units:0, band_low_pct:93, band_high_pct:96, gap_to_next_tier_dollars:0, reference_ask:0, price_floor_dollars:'', price_ceiling_dollars:'' });
    renderFPTable();
    maybeSaveLocal();
  }

  function deleteFPRow(idx){
    const rows = window.propertySetup.floorplans || [];
    if (idx>=0 && idx<rows.length){ rows.splice(idx,1); renderFPTable(); }
    maybeSaveLocal();
  }

  function setFP(idx, key, value){
    const rows = window.propertySetup.floorplans || [];
    if (!rows[idx]) return;
    if (key==='code') value = normalizeCode(value).slice(0,12);
    if (key==='name') value = String(value||'').slice(0,40);
    if (key==='units' || key==='reference_ask' || key==='gap_to_next_tier_dollars' || key==='price_floor_dollars' || key==='price_ceiling_dollars'){
      if (String(value)===''){ rows[idx][key] = ''; renderFPTable(); return; }
      value = Math.max(0, toInt(value,0));
    }
    if (key==='band_low_pct' || key==='band_high_pct') value = clamp(Math.round(Number(value||0)*2)/2, 70, 100);
    rows[idx][key] = value;
    // Only re-render table (badges/validation). No other side effects.
    renderFPTable();
    maybeSaveLocal();
  }

  // Prefill from mapped rent roll if present
  function normalizeLabel(s){ return String(s||'').replace(/[×✕✖]/g,'x').trim().replace(/\s+/g,' ').toLowerCase(); }
  function firstToken(label){ const raw=String(label||'').replace(/[×✕✖]/g,'x').trim().replace(/\s+/g,' '); return (raw.split(/\s+/)[0]||'').replace(/[^A-Za-z0-9]/g,''); }
  function codeFromLabel(label){ const tok=firstToken(label); const sanitized = tok || String(label||'').replace(/[^A-Za-z0-9]/g,''); return (sanitized||'FP').slice(0,12); }
  function prefillFromRentRoll(){
    const mr = Array.isArray(window.mappedRows) ? window.mappedRows : null;
    if (!mr || !mr.length) return;
    const freq = new Map();
    for(const r of mr){ const lbl=String(r.Floorplan||'').trim(); const key=normalizeLabel(lbl); if (!key) continue; const cur=freq.get(key)||{label:lbl,units:0}; cur.units++; if(!cur.label) cur.label=lbl; freq.set(key,cur); }
    const out=[];
    for(const {label,units} of freq.values()){
      const code = codeFromLabel(label);
      const small = (units<15);
      out.push({ code, name: label, units, band_low_pct: small?92:93, band_high_pct: small?97:96, gap_to_next_tier_dollars:0, reference_ask:0, price_floor_dollars:'', price_ceiling_dollars:'' });
    }
    window.propertySetup.floorplans = out;
    renderFPTable();
    saveFPsLocal();
    try{ if (typeof window.__applyLockState==='function') window.__applyLockState(); }catch(e){}
  }

  function mergeFromRentRoll(){
    const mr = Array.isArray(window.mappedRows) ? window.mappedRows : null;
    if (!mr || !mr.length) return;
    const freq = new Map();
    for(const r of mr){ const lbl=String(r.Floorplan||'').trim(); const key=normalizeLabel(lbl); if (!key) continue; const cur=freq.get(key)||{label:lbl,units:0}; cur.units++; if(!cur.label) cur.label=lbl; freq.set(key,cur); }
    const rows = window.propertySetup.floorplans || (window.propertySetup.floorplans=[]);
    const byCode = new Map(rows.map((r,i)=>[String(r.code||'').toLowerCase(), {i,r}]));
    const byName = new Map(rows.map((r,i)=>[normalizeLabel(r.name||''), {i,r}]));
    const usedCodes = new Set(rows.map(r=>String(r.code||'').toLowerCase()).filter(Boolean));
    const add=[];
    for(const {label,units} of freq.values()){
      const tok = firstToken(label).toLowerCase();
      let t = byCode.get(tok) || byName.get(normalizeLabel(label));
      if (t){ rows[t.i].units = units; }
      else {
        let c = codeFromLabel(label); let base=c.toLowerCase(); let n=1; while(usedCodes.has(base)){ n++; c=(c+n).slice(0,12); base=c.toLowerCase(); }
        usedCodes.add(base);
        const small=(units<15);
        add.push({ code:c, name:label, units, band_low_pct: small?92:93, band_high_pct: small?97:96, gap_to_next_tier_dollars:0, reference_ask:0, price_floor_dollars:'', price_ceiling_dollars:'' });
      }
    }
    if (add.length) rows.push(...add);
    renderFPTable();
    saveFPsLocal();
    try{ if (typeof window.__applyLockState==='function') window.__applyLockState(); }catch(e){}
  }

  function initFPSettings(){
    const add = document.getElementById('addFPBtn'); if (add) add.addEventListener('click', addFPRow);
    const pf = document.getElementById('prefillFromRR');
    if (pf){
      if (Array.isArray(window.mappedRows) && window.mappedRows.length){ pf.style.display='inline'; pf.addEventListener('click', (e)=>{ e.preventDefault(); const rows=(window.propertySetup&&window.propertySetup.floorplans)||[]; if (!rows.length) prefillFromRentRoll(); else mergeFromRentRoll(); if (typeof window.renderFPMapCard==='function') window.renderFPMapCard(); if (typeof window.autoMapFromSettings==='function') window.autoMapFromSettings(); }); }
      else { pf.style.display = 'none'; }
    }
    // Local persistence controls
    const clear = document.getElementById('fpClearLocal');
    if (clear) clear.addEventListener('click', (e)=>{ e.preventDefault(); if (confirm('Clear locally saved data?')){ try{ localStorage.removeItem(LS_KEY);}catch(err){} try{ const ps=window.propertySetup||{}; const pid=ps.property_id||ps.property_name||'default'; localStorage.removeItem(`rm:fpmap:${pid}`); localStorage.removeItem(`rm:fpmap:candidates:${pid}`);}catch(err){} (window.propertySetup.floorplans=[]); renderFPTable(); try{ if (typeof window.renderFPMapCard==='function') window.renderFPMapCard(); }catch(err){} updateSavedChip('Cleared'); }});
    const reset = document.getElementById('fpResetDefaults');
    if (reset) reset.addEventListener('click', (e)=>{ e.preventDefault(); window.propertySetup.floorplans=[{ code:'A1', name:'1x1', units:0, band_low_pct:93, band_high_pct:96, reference_ask:0, price_floor_dollars:'', price_ceiling_dollars:'' }]; renderFPTable(); saveFPsLocal(); });

    // Load any local persisted rows if current state is empty
    loadFPsLocal();
    renderFPTable();
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initFPSettings);
  else initFPSettings();
})();
</script>









  




</head>
<body>
<div class="wrap">
  <h1><span class="logo-emoji">🚀</span> Revenue Management</h1>
  <div id="tabBar" style="position:sticky; top:0; z-index:100; background:var(--bg); padding:8px 0; margin:0 0 8px; border-bottom:1px solid #0b1326;">
    <div class="actions" style="gap:8px; flex-wrap:wrap">
      <button class="btn sm" data-tab="home">🏠 Home</button>
      <button class="btn sm" data-tab="settings">⚙️ Settings</button>
      <button class="btn sm" data-tab="newPricing">💵 New Pricing</button>
      <button class="btn sm" data-tab="renewals">🔁 Renewals</button>
      <button class="btn sm" data-tab="charts">📊 Charts</button>
      <button class="btn sm" data-tab="history">🕒 History</button>
    </div>
  </div>

      

  <div class="grid">
    <div class="panel">






      <!-- Privacy -->
      <div class="card">
        <div class="note"><strong>Privacy:</strong> Files are parsed in your browser (no server upload). When we move to SaaS: encryption at rest & in transit, strict retention, and no third party sharing.</div>
      </div>

      <!-- Upload + Mapping -->
      

<!-- Removed Property card (Thorpe Gardens) -->
<div class="card">
        <h2 data-tab-scope="home">Upload Rent Roll</h2>
        <input id="file" type="file" accept=".csv" />
        <div id="automap" style="display:none; margin-top:12px">
          <h3>Column Mapping (auto detected — adjust if needed)</h3>
          <div id="mapTable" style="overflow:auto"></div>
          <div id="validationBox" class="note"></div>
          <button id="confirmMapping" class="btn" style="margin-top:8px">Confirm Mapping</button>
        
        <!-- Confirm Overlay -->
        <div id="confirmOverlay" class="overlay" style="display:none;">
          <div class="overlay-content" style="max-width:500px;">
            <h3>Confirm Upload</h3>
            <div id="detectedColumns" class="note" style="margin:12px 0;"></div>
            <div id="mappingStatus" class="note" style="margin:12px 0;"></div>
            <div class="actions" style="margin-top:16px; gap:8px;">
              <button id="confirmUpload" class="btn">Confirm</button>
              <button id="editMapping" class="btn secondary">Edit Mapping</button>
            </div>
          </div>
        </div>
      </div>
      </div>
      <div class="home-only">
      
  <div class="card">
    <h2 data-tab-scope="home">Run & Export</h2>
    <div class="home-actions">
      <div class="home-group">
        <div class="title">💵 New Pricing</div>
        <div class="btnrow">
          <button class="btn" id="homeRunNew" class="btn accent" class="btn accent">Run New</button>
          <button class="btn secondary sm" id="homeExportNew">Export New</button>
          <button class="btn xs" data-goto="newPricing">View</button>
        </div>
      </div>
      <div class="home-group">
        <div class="title">🔁 Renewals</div>
        <div class="btnrow">
          <button class="btn" id="homeRunRenew" class="btn accent" class="btn accent">Run Renewals</button>
          <button class="btn secondary sm" id="homeExportRenew">Export Renew</button>
          <button class="btn xs" data-goto="renewals">View</button>
        </div>
      </div>
    </div>
    <!-- Hidden fallbacks for legacy code; auto-synced from target -->
    <input id="comfortLow" type="hidden" value="93">
    <input id="comfortHigh" type="hidden" value="96">
  </div>

      <!-- Status 45: Forward-looking widget (placed under Run & Export) -->
      <div class="card" data-tab-scope="home" id="status45-card">
        <h2 data-tab-scope="home">Status at a Glance</h2>
        <div class="status45">

          <!-- Row 1: KPI tiles -->
          <div class="kpi-row">
            <!-- Trending Occupancy -->
            <div class="tile" id="kpi_trending_occ">
              <h3>Trending Occupancy</h3>
              <div class="big" data-kpi="trendingOcc">—</div>
              <div class="sub">
                Today <span data-kpi="todayOcc">—</span> • Target <span data-kpi="targetOcc">—</span>
                <span class="pill neutral">Occ + Preleased − On-Notice</span>
      </div>
      </div>

      

            <!-- Pacing to Target -->
            <div class="tile" id="kpi_pacing_gap">
              <h3>Pacing to Target</h3>
              <div class="big" data-kpi="gapPP">—</div>
              <div class="sub">Need <span data-kpi="homesNeeded">—</span> homes</div>
            </div>

            <!-- Undecided Renewals (30d) -->
            <div class="tile" id="kpi_undecided_30d" style="cursor:pointer">
              <h3>Undecided Renewals (30d)</h3>
              <div class="big"><span data-kpi="undecided30d">—</span></div>
              <div class="sub">of <span data-kpi="expiring30d">—</span> expiring</div>
            </div>

            <div class="tile hidden-soft" id="kpi_velocity_7d">
              <h3>Leasing Pacing (7d)</h3>
              <div class="big"><span data-kpi="pacingPP">—</span></div>
              <div class="sub"><span data-kpi="approvals7d">—</span> approvals • conv <span data-kpi="convPct">—</span></div>
            </div>
          </div>

          <!-- Row 2: Alerts -->
          <div class="alerts-row">
            <div class="alert-card" id="alert_struggling_fps">
              <h4>Struggling Floorplans <span class="pill neutral" data-kpi="strugglingCount">0</span></h4>
              <ul class="alert-list" data-list="fps"></ul>
            </div>

            <div class="alert-card" id="alert_stale_units">
              <h4>Stale Vacancies (≥30d) <span class="pill neutral" data-kpi="staleCount">0</span></h4>
              <ul class="alert-list" data-list="stale"></ul>
            </div>
          </div>

        </div>
      </div>





</div>

      

      <!-- Strategy -->
      <div class="card">
        <h2 data-tab-scope="settings">Global</h2>
        <div class="row" id="comfortTargetRow">
          <div style="max-width: 200px;">
            <label>
              <span class="iwrap">Comfort Target Trend %
                <span class="help">i</span>
                <span class="itip">Single target trending occupancy (e.g., 95). We will switch logic in a later step.</span>
              </span>
            </label>
            <input id="comfortTarget" type="number" step="0.1" min="80" max="100" value="95" placeholder="e.g., 95">
          </div>
        </div>
        <div class="row">
          <div>
            <!-- Low/High controls removed in favor of single target -->
          </div>
          <div>
            <div class="inline-compact" style="margin-top:6px; display:flex; gap:8px; align-items:center; justify-content:flex-end;">
              <label style="margin:0;">
                <span class="iwrap">New Lease Terms (Months)
                  <span class="help">i</span>
                  <span class="itip">Select which terms to quote for new leases. Defaults 2–14; up to 24 supported.</span>
                </span>
              </label>
              <div class="dropdown" style="position:relative;">
                <button id="nlDropdownBtn" type="button" class="btn sm" style="padding:6px 10px;">2–14</button>
                <div id="nlDropdownPanel" class="panel" style="display:none; position:absolute; right:0; top:110%; background:#0b1220; border:1px solid #334155; border-radius:8px; padding:8px; box-shadow:0 8px 24px rgba(0,0,0,.35); z-index:50; width:220px; max-height:220px; overflow:auto;">
                  <div id="nlTermList" style="display:grid; grid-template-columns:repeat(4,1fr); gap:6px;"></div>
                  <div style="display:flex; justify-content:space-between; margin-top:8px;">
                    <button id="nlAll" class="btn xs" type="button">All</button>
                    <button id="nlNone" class="btn xs" type="button">None</button>
                    <button id="nlDefault" class="btn xs" type="button">2–14</button>
                  </div>
                </div>
              </div>
            </div>

      </div>
      </div>
        <div class="row-3" style="margin-top:8px">
          <div class="hidden-soft">
            <label>
              <span class="iwrap">Conversion Sensitivity
                <span class="help">i</span>
                <span class="itip">How strongly we react to applications vs leads when inside the band.</span>
              </span>
            </label>
            <select id="convSensitivity">
              <option value="low">Low</option>
              <option value="medium" selected>Medium</option>
              <option value="high">High</option>
            </select>
          </div>
          <div>
            <label>
              <span class="iwrap">Pricing Adjustment Style
                <span class="help">i</span>
                <span class="itip">Controls how quickly prices adjust each run: Conservative, Standard, or Aggressive.</span>
              </span>
            </label>
            <select id="priceResponse">
              <option value="gentle">Conservative</option>
              <option value="standard" selected>Standard</option>
              <option value="fast">Aggressive</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Floorplan Settings (manual editor) -->
      <div class="card" id="fpSettingsCard">
        <div class="actions" style="justify-content:space-between; align-items:center;">
          <h2 data-tab-scope="settings" style="margin:0">Floorplan Settings</h2>
          <div id="lockModeSwitch" class="actions" style="gap:6px">
            <button id="btnModeDraft" class="btn xs" type="button">Draft</button>
            <button id="btnModePublished" class="btn xs" type="button">Published 🔒</button>
            <span id="lockModeChip" class="badge" aria-live="polite"></span>
          </div>
        </div>
        <div class="note">Buffer stops decreases on this floorplan if a price drop would cross the buffer line. It never pushes other floorplans down.</div>
        <div class="actions" style="justify-content:space-between; align-items:center; margin:8px 0;">
          <div>
            <a id="prefillFromRR" href="#" style="display:none; font-size:12px">Prefill from rent roll</a>
          </div>
          <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
            <a id="fpClearLocal" href="#" style="font-size:12px">Clear local</a>
            <a id="fpResetDefaults" href="#" style="font-size:12px">Reset defaults</a>
            <span id="fpSavedChip" class="badge" aria-live="polite" style="display:none"></span>
            <button id="addFPBtn" class="btn xs" type="button">Add floorplan</button>
          </div>
        </div>
        <div class="hscroll" style="overflow-x:auto">
          <table class="basic" aria-label="Floorplan Settings table" style="min-width:780px">
            <thead>
              <tr>
                <th style="width:24px"></th>
                <th>Code</th>
                <th>Name</th>
                <th>Units</th>
                <th>Band Low %</th>
                <th>Band High %</th>
                <th>Min Gap to Next Tier $</th>
            <th>Starting Rent $</th>
            <th>Price Floor ($)</th>
            <th>Price Ceiling ($)</th>
            <th>Actions</th>
              </tr>
            </thead>
            <tbody id="fpTableBody"></tbody>
          </table>
        </div>
      </div>

      <!-- Carry-Forward Mode Settings -->
      <div class="card" id="carryForwardCard">
        <h2 data-tab-scope="settings" style="margin:0">Carry-Forward Mode</h2>
        <div class="note" style="margin:8px 0;">
          Carry-forward mode saves each run's final floorplan baselines and uses them as starting points for the next run. 
          This allows you to test how pricing evolves over time with different rent roll scenarios.
        </div>
        <div class="actions" style="gap:12px; margin-top:12px;">
          <button id="resetCarryForwardBtn" class="btn sm" type="button" style="background:#dc2626; color:white;">
            Reset Baselines to Seed Values
          </button>
          <span id="carryForwardStatus" class="badge" aria-live="polite"></span>
        </div>
        <div id="carryForwardInfo" class="note" style="margin-top:8px; display:none;">
          <strong>Current Carry-Forward State:</strong>
          <div id="carryForwardDetails"></div>
        </div>
      </div>

      <!-- Vacancy Age Pricing Settings -->
      <div class="card" id="vacancyAgeCard">
        <h2 data-tab-scope="settings" style="margin:0">Vacancy Age Pricing</h2>
        <div class="note" style="margin:8px 0;">
          Apply progressive discounts to units vacant beyond 30 days. This helps move stale vacancies while maintaining operator control over pricing intensity.
        </div>
        
        <div class="setting-group" style="margin:12px 0;">
          <label style="display:flex; align-items:center; gap:8px;">
            <input type="checkbox" id="vacancyAgeEnabled" style="margin:0;">
            <span>Enable vacancy age pricing</span>
          </label>
        </div>
        
        <div id="vacancyAgeControls" style="display:none; margin-top:12px;">
          <div class="setting-group">
            <label for="vacancyAgeIntensity" style="display:block; margin-bottom:4px; font-weight:600;">Intensity Level:</label>
            <select id="vacancyAgeIntensity" style="width:100%; max-width:400px;">
              <option value="minimal">Minimal - Gentle pressure (0.1%/day, max 5%)</option>
              <option value="medium">Medium - Moderate pressure (0.2%/day, max 10%)</option>
              <option value="aggressive">Aggressive - Strong pressure (0.3%/day, max 15%)</option>
            </select>
          </div>
          
          <div class="note" style="margin-top:8px;">
            <strong>How it works:</strong> Units vacant 30+ days receive progressive discounts based on vacancy age. 
            The discount increases daily until the maximum is reached. Only affects individual unit pricing, not floorplan baselines.
          </div>
          
          <div id="vacancyAgePreview" class="note" style="margin-top:8px; display:none;">
            <strong>Example discounts:</strong>
            <div id="vacancyAgeExamples"></div>
          </div>
        </div>
      </div>

      <!-- Development Panel (Step 107) -->
      <div class="card" id="devPanelCard" style="display:none;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
          <h2 data-tab-scope="settings" style="margin:0">🧪 Development Panel</h2>
          <button id="devPanelToggle" class="btn xs" style="font-size:11px; opacity:0.7;">Hide Dev Panel</button>
        </div>
        <div class="note" style="margin:8px 0;">
          <strong>Developer Tools:</strong> Enable simulation mode and trend overrides for testing and demos. 
          These features are disabled by default in production.
        </div>
        
        <!-- Feature Flags -->
        <div class="setting-group" style="margin:12px 0;">
          <label style="display:flex; align-items:center; gap:8px;">
            <input type="checkbox" id="devEnableSimulation" style="margin:0;">
            <span>Enable Simulation Mode</span>
          </label>
          <div class="note" style="margin-top:4px; font-size:12px;">
            Run pricing against simulated unit states instead of real rent roll data.
          </div>
        </div>
        
        <div class="setting-group" style="margin:12px 0;">
          <label style="display:flex; align-items:center; gap:8px;">
            <input type="checkbox" id="devEnableTrendOverrides" style="margin:0;">
            <span>Enable Trend Override Sliders</span>
          </label>
          <div class="note" style="margin-top:4px; font-size:12px;">
            Adjust floorplan trends manually for controlled "what-if" scenarios.
          </div>
        </div>
        
        <!-- Trend Override Sliders -->
        <div id="trendOverrideControls" style="display:none; margin-top:16px;">
          <h3 style="margin:0 0 12px; font-size:1em;">Floorplan Trend Overrides</h3>
          <div id="trendSliderContainer"></div>
          <div class="note" style="margin-top:8px; font-size:12px;">
            <strong>How it works:</strong> Override actual floorplan occupancy trends with manual values. 
            The pricing engine will use these values instead of computed trends. Reset to 0 to use actual trends.
          </div>
        </div>
        
        <!-- Simulation Status -->
        <div id="simulationStatus" style="display:none; margin-top:12px;">
          <div class="note" style="background:#fef3c7; border:1px solid #f59e0b;">
            <strong>Simulation Active:</strong> <span id="simStatusBadge">Ready</span><br>
            <small>Using simulated unit states and trends</small>
          </div>
        </div>
        
        <!-- Data Source Badge -->
        <div id="dataSourceBadge" style="margin-top:12px; display:none;">
          <div class="badge" id="dataSourceBadgeContent" style="background:#0891b2; color:white;">
            Data Source: <span id="dataSourceText">Real</span>
          </div>
        </div>
        
        <!-- Simulator Seed Badge (shows when simulation active) -->
        <div id="simulatorSeedBadge" style="margin-top:8px; display:none;">
          <div class="badge" style="background:#7c3aed; color:white;">
            Simulation Mode: Seed <span id="simulatorSeedValue">12345</span>
          </div>
        </div>

        <!-- Simulator Controls (Step 1) -->
        <div id="simulatorControls" style="display:none; margin-top:16px;">
          <h3 style="margin:0 0 12px; font-size:1em;">Simulator Controls</h3>
          
          <div class="setting-group" style="margin:8px 0;">
            <label>Total Units: <input type="number" id="simTotalUnits" value="200" min="1" max="1000" style="width:80px;"></label>
          </div>
          
          <div class="setting-group" style="margin:8px 0;">
            <label>Seed: <input type="number" id="simSeed" value="12345" style="width:100px;"></label>
            <button id="simInitBtn" class="btn xs">Init</button>
            <button id="simResetBtn" class="btn xs">Reset</button>
          </div>
          
          <!-- Floorplan Mix Sliders (Phase 2) -->
          <div id="simMixSliders" style="margin:12px 0; padding:8px; background:#f8f9fa; border-radius:6px; display:none;">
            <h4 style="margin:0 0 8px; font-size:0.9em;">Floorplan Mix (%)</h4>
            <div id="simMixContainer">
              <!-- Sliders will be injected here -->
              <div class="note" style="font-size:12px;">No floorplans configured</div>
            </div>
            <div class="note" style="margin-top:8px; font-size:11px;">
              <strong>Total must equal 100%.</strong> Units allocated using largest-remainder rounding.
            </div>
          </div>
          
          <div class="setting-group" style="margin:8px 0;">
            <button id="simRunOnceBtn" class="btn xs">RunOnce</button>
            <button id="simStepBtn" class="btn xs">Step</button>
            <button id="simStartBtn" class="btn xs" disabled>Start</button>
            <button id="simStopBtn" class="btn xs" disabled>Stop</button>
          </div>
          
          <!-- Speed Control -->
          <div class="setting-group" style="margin:8px 0;">
            <label>Speed: </label>
            <button id="simSpeed1Btn" class="btn xs" style="background:#059669;">1×</button>
            <button id="simSpeed5Btn" class="btn xs">5×</button>
            <button id="simSpeed10Btn" class="btn xs">10×</button>
          </div>
          
          <!-- Trend % Controls (80–100) -->
          <div id="simTrendOccPctControls" style="margin:12px 0; padding:8px; background:#f0f9ff; border-radius:6px; display:none;">
            <h4 style="margin:0 0 8px; font-size:0.9em;">Floorplan Trend % (80–100)</h4>
            <div id="simTrendOccPctContainer">
              <!-- Controls will be injected here -->
            </div>
            <button id="simResetTrendBtn" class="btn xs" style="margin-top:8px;">Reset Trend %</button>
          </div>
          
          <!-- Prices & Deltas Panel -->
          <div id="simPricesPanel" style="margin:12px 0; padding:8px; background:#fef3c7; border-radius:6px; display:none;">
            <h4 style="margin:0 0 8px; font-size:0.9em;">Per-Floorplan Prices (current run)</h4>
            <div id="simPricesContent">
              <div class="note" style="font-size:12px;">No pricing data yet. Click Step or Start to run.</div>
            </div>
          </div>
          
          <div id="simHistoryStrip" style="margin-top:8px; display:flex; gap:4px; flex-wrap:wrap; max-height:60px; overflow-y:auto; padding:4px; background:#1e293b; border-radius:4px;">
            <div class="note" style="font-size:11px; margin:0;">History strip will appear here</div>
          </div>
          
          <!-- Invariant Warning (Phase 2) -->
          <div id="simInvariantWarning" style="display:none; margin-top:8px; padding:8px; background:#fee2e2; border:1px solid #ef4444; border-radius:4px;">
            <strong style="color:#dc2626;">⚠️ Invariant Violation</strong>
            <div id="simInvariantMessage" style="font-size:12px; margin-top:4px;"></div>
          </div>
        </div>

        <!-- Simulator Demo Button (Quick Entry Point) -->
        <div style="margin-top:16px;">
          <button id="simulatorDemoBtn" class="btn" style="width:100%; margin-top:8px;">🎮 Try Simulator Demo</button>
          <div class="note" style="margin-top:4px; font-size:12px;">
            Load sample simulated data and run pricing without a CSV upload.
          </div>
        </div>
      </div>

      <!-- Data Settings (Property Profile) -->
      <div class="card" id="dataSettingsCard">
        <h2 data-tab-scope="settings" style="margin:0">Property Configuration</h2>
        <div class="note" style="margin:8px 0;">
          <strong>Thorpe Gardens Property:</strong> Floorplans are locked for consistent operations. Operators can adjust pricing levers (bands, floors/ceilings, buffers) but cannot change floorplan catalog.
        </div>
        
        <div id="propertyStatus" class="note" style="margin:12px 0; padding:12px; border-radius:8px; background:#f0f9ff; border:1px solid #0ea5e9;">
          <div id="propertyInfo">
            <strong>Property Status:</strong> <span id="propertyStatusText">Not configured</span><br>
            <small id="propertyDetails">Upload a rent roll to establish property profile</small>
          </div>
        </div>
        
        <div class="setting-group" style="margin:12px 0;">
          <label style="display:flex; align-items:center; gap:8px;">
            <input type="checkbox" id="strictMappingEnabled" style="margin:0;" checked>
            <span>Strict mapping mode (recommended)</span>
          </label>
          <div class="note" style="margin-top:4px; font-size:12px;">
            Validates CSV headers and floorplan catalog against property profile. Required for consistent testing.
          </div>
        </div>
        
        <div id="strictMappingControls" style="margin-top:12px;">
          <div class="setting-group">
            <label style="display:flex; align-items:center; gap:8px;">
              <input type="checkbox" id="catalogLockEnabled" style="margin:0;" checked>
              <span>Lock floorplan catalog (default)</span>
            </label>
            <div class="note" style="margin-top:4px; font-size:12px;">
              Floorplans are locked to property profile. Contact admin to add/remove floorplans.
            </div>
          </div>
          
          <div class="actions" style="margin-top:12px; gap:8px;">
            <button id="unlockFloorplansBtn" class="btn secondary" type="button" style="display:none;">Temporarily Unlock Floorplans</button>
            <button id="downloadProfileBtn" class="btn secondary" type="button" style="display:none;">Export Profile</button>
          </div>
          
          <div id="profileStatus" class="note" style="margin-top:8px; display:none;">
            <div id="profileInfo"></div>
          </div>
        </div>
        
        <div class="note" style="margin-top:12px;">
          <strong>How it works:</strong> 
          <ul style="margin:4px 0; padding-left:16px;">
            <li><strong>Pre-configured:</strong> Thorpe Gardens property profile is built-in</li>
            <li><strong>Operator Control:</strong> Adjust pricing levers (bands, floors, buffers, etc.)</li>
            <li><strong>Consistent Testing:</strong> All rent rolls must match Thorpe Gardens floorplans</li>
            <li><strong>Floorplan Changes:</strong> Contact admin to modify property configuration</li>
          </ul>
        </div>
      </div>

      <!-- Floorplan Map (canonical CODE mapping) -->
      <div class="card" id="fpMapCard">
        <h2 data-tab-scope="settings">Floorplan Map</h2>
        <div class="note">Map CSV labels to setup Codes. Pricing uses codes only.</div>
        <div id="fpMapEmpty" class="note" style="display:none">No rent roll uploaded yet <span class="badge">unseen</span></div>
        <div id="fpMapWrap" style="display:none">
          <div class="row" style="align-items:start; gap:12px">
            <div>
              <h3 style="margin:0 0 6px">CSV Labels</h3>
              <div id="fpLabelList" class="hscroll"></div>
            </div>
            <div>
              <h3 style="margin:0 0 6px">Map to code</h3>
              <div id="fpMapList" class="hscroll"></div>
            </div>
          </div>
          <div class="actions" style="justify-content:flex-end; gap:10px; margin-top:8px">
            <button id="fpMapSave" class="btn xs" type="button">Save map</button>
            <button id="fpMapClear" class="btn xs" type="button">Clear map</button>
          </div>
        </div>

        <div id="cardFPMapAlt">
          <div class="note" id="fpMapEmptyAlt" style="display:none">No rent roll labels found yet.</div>
          <table class="basic" style="width:100%">
            <thead><tr><th style="width:55%">CSV Label</th><th style="width:35%">Map to Code</th><th>Preview</th></tr></thead>
            <tbody id="fpMapTableBody"></tbody>
          </table>
          <div class="actions" style="justify-content:flex-end; gap:10px; margin-top:8px">
            <button class="btn xs" id="fpMapClearBtn" type="button">Clear map</button>
            <button class="btn primary xs" id="fpMapSaveBtn" type="button">Save map</button>
            <span id="fpMapSavedChip" class="badge" aria-live="polite" style="margin-left:8px"></span>
          </div>
        </div>
      </div>

      <!-- Seasonality -->
      <div class="card">
        <h2 data-tab-scope="settings">Seasonality</h2>
        <div class="row">
          <div>
            <label>
              <span class="iwrap">Seasonality Preset
                <span class="help">i</span>
                <span class="itip">Distribute expirations across the year. Choose Normal/Minimal/Aggressive, or use Custom to input your own monthly % targets.</span>
              </span>
            </label>
            <select id="seasonalityCurve">
              <option value="minimal">Minimal</option>
              <option value="normal" selected>Normal</option>
              <option value="aggressive">Aggressive</option>
              <option value="custom">Custom</option>
            </select>
            <div id="seasonalityGrid" style="margin-top:10px;">
              <label><strong>Monthly Expiration Targets (%)</strong></label>
              <div class="months-grid" style="display:grid;grid-template-columns:repeat(13,1fr);gap:8px;margin-top:6px;align-items:end;">
                <div><small>Jan</small><input class="month-input" data-idx="0" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Feb</small><input class="month-input" data-idx="1" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Mar</small><input class="month-input" data-idx="2" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Apr</small><input class="month-input" data-idx="3" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>May</small><input class="month-input" data-idx="4" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Jun</small><input class="month-input" data-idx="5" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Jul</small><input class="month-input" data-idx="6" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Aug</small><input class="month-input" data-idx="7" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Sep</small><input class="month-input" data-idx="8" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Oct</small><input class="month-input" data-idx="9" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Nov</small><input class="month-input" data-idx="10" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Dec</small><input class="month-input" data-idx="11" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div style="text-align:right;">
                  <small>Total</small>
                  <div id="seasonalityTotal" class="ok" style="padding:6px 8px;border-radius:6px;border:1px solid #334155;">0%</div>
                </div>
              </div>
              <p class="note">Tip: Values should equal 100%. Presets show read only values; choose Custom to edit.</p>
            </div>

          </div>
        </div>
        <div class="row" style="margin-top:8px"></div>
      </div>

      <!-- Renewals -->
      <div class="card">
        <h2 data-tab-scope="settings">Renewals</h2>
        <div class="row">
          <div>
            <label>
              <span class="iwrap">Allow Renewal Decrease
                <span class="help">i</span>
                <span class="itip">If current rent is above today's new lease, allow decrease.</span>
              </span>
            </label>
            <label class="switch">
              <input id="allowDecAbove" type="checkbox">
              <span class="toggle"><span class="knob"></span></span>
              <span>On</span>
            </label>
          </div>
          <div>
            <label>
              <span class="iwrap">Apply Guardrails to All Terms
                <span class="help">i</span>
                <span class="itip">Apply the same min/max % change caps across all renewal terms.</span>
              </span>
            </label>
            <label class="switch">
              <input id="capAllTerms" type="checkbox">
              <span class="toggle"><span class="knob"></span></span>
              <span>On</span>
            </label>
          </div>
        </div>
        <div class="row-3" style="margin-top:8px">
          <div>
            <label>
              <span class="iwrap">Percent-to-New (%) (when below)
                <span class="help">i</span>
                <span class="itip">Enter how far renewals move toward the current new lease price when below (e.g., 50 = halfway).</span>
              </span>
            </label>
            <input id="pctToNew" type="number" step="1" min="0" max="100" value="50" placeholder="e.g., 50">
          </div>
        </div>
        <div class="row-3" style="margin-top:8px">
          <div>
            <label>
              <span class="iwrap">Min % (below new)
                <span class="help">i</span>
                <span class="itip">Minimum allowed change when below new lease.</span>
              </span>
            </label>
            <input id="renMin" type="number" step="1" min="-100" max="100" value="0" placeholder="e.g., 0">
          </div>
          <div>
            <label>
              <span class="iwrap">Max % (below new)
                <span class="help">i</span>
                <span class="itip">Maximum allowed increase when below new lease.</span>
              </span>
            </label>
            <input id="renMax" type="number" step="1" min="-100" max="100" value="10" placeholder="e.g., 8">
          </div>
        </div>
        <div class="row-3" style="margin-top:8px">
          <div>
            <label>
              <span class="iwrap">Min % (above new)
                <span class="help">i</span>
                <span class="itip">Minimum allowed change when already above new lease.</span>
              </span>
            </label>
            <input id="renAboveMin" type="number" step="1" min="-100" max="100" value="0" placeholder="e.g., 0">
          </div>
          <div>
            <label>
              <span class="iwrap">Max % (above new)
                <span class="help">i</span>
                <span class="itip">Maximum allowed change when already above new lease.</span>
              </span>
            </label>
            <input id="renAboveMax" type="number" step="1" min="-100" max="100" value="0" placeholder="e.g., 5">
          </div>
          <div>
            <label>
              <span class="iwrap">Renewal Terms (Months)
                <span class="help">i</span>
                <span class="itip">Choose renewal terms to offer; defaults 2–14, up to 24 supported.</span>
              </span>
            </label>
            <div class="inline-compact" style="margin-top:6px; display:flex; gap:8px; align-items:center; justify-content:flex-start;">
              <div class="dropdown" style="position:relative;">
                <button id="renDropdownBtn" type="button" class="btn sm" style="padding:6px 10px;">2–14</button>
                <div id="renDropdownPanel" class="panel" style="display:none; position:absolute; left:0; top:110%; background:#0b1220; border:1px solid #334155; border-radius:8px; padding:8px; box-shadow:0 8px 24px rgba(0,0,0,.35); z-index:50; width:220px; max-height:220px; overflow:auto;">
                  <div id="renTermList" style="display:grid; grid-template-columns:repeat(4,1fr); gap:6px;"></div>
                  <div style="display:flex; justify-content:space-between; margin-top:8px;">
                    <button id="renAll" class="btn xs" type="button">All</button>
                    <button id="renNone" class="btn xs" type="button">None</button>
                    <button id="renDefault" class="btn xs" type="button">2–14</button>
                  </div>
                </div>
              </div>
            </div>
            <div id="renTermBox" style="display:none"></div>
          </div>
        </div>
      </div>


      <!-- Safety & Governance -->
      <div class="card">
        <h2 data-tab-scope="settings">Safety & Governance</h2>
        <div class="row">
          <div>
            <label>
              <span class="iwrap">Change Frequency Limit
                <span class="help">i</span>
                <span class="itip">Choose how often pricing can change: "Daily" allows one publish per day; "Off" removes the limit.</span>
              </span>
            </label>
            <select id="changeCadence">
              <option value="daily" selected>Daily</option>
              <option value="off">Off</option>
            </select>
          </div>
        </div>
      </div>

      <div class="card" style="display:none">
        <button id="run" class="btn primary">Run Pricing</button> <button id="exportXLSX" class="btn" disabled>Export XLSX</button>
        <div class="note">Uploads stay local. Results include an expirations chart and suggested new & renewal pricing.</div>
      </div>
    </div>

    <!-- Right column: Seasonality and Results -->
    <div class="panel">
      
      <div class="card" id="boxScoreCard">
        <div class="actions sticky-summary" style="justify-content:space-between">
          <h2 style="margin:0" data-tab-scope="charts">Box Score</h2>
          <div id="chartsSourceNote" class="note" style="margin-top:6px"></div>
          <div class="note">Floorplan rows • Assumes all notices move out</div>
        </div>
        <div id="boxScoreSummary" style="margin:6px 0 0; display:none;"></div>
        <div id="boxScoreWrap" style="overflow:auto; margin-top:6px;">
          <table class="basic" id="boxScoreTable">
            <thead>
              <tr>
                <th style="white-space:nowrap">Group</th>
                <th># Units</th>
                <th># Vacant</th>
                <th># Notices</th>
                <th># Preleased</th>
                <th># Occupied</th>
                <th>Occupied %</th>
                <th>Projected %</th>
              </tr>
            </thead>
            <tbody id="boxScoreBody">
              <tr><td colspan="8" class="note">Run New or Renew to populate.</td></tr>
            </tbody>
            <tfoot id="boxScoreFoot"><tr><td colspan="8" class="note">Totals will appear after you run.</td></tr></tfoot>
          </table>
        </div>
      </div>
<div class="card">
        <h2 data-tab-scope="charts">Seasonality (Next 12 Months)</h2>
        <div style="height:260px;max-height:260px">
          <canvas id="seasonChart" style="width:100%;height:100%"></canvas>
        </div>
        <div class="note">Shows actual expirations (blue bars) vs allowed capacity (line). Overages trigger higher-seasonality pressure.</div>
      </div>
      
      <div class="card">
        <h2 data-tab-scope="charts">Renewal Summary (Next 5 Months)</h2>
        <div id="renewalSummaryWrap" style="overflow:auto; margin-top:6px;">
          <table class="basic" id="renewalSummaryTable">
            <thead>
              <tr>
                <th>Month</th>
                <th>Total Expiring</th>
                <th>Given Notice</th>
                <th>Renewed</th>
                <th>Undecided</th>
                <th>Conversion %</th>
              </tr>
            </thead>
            <tbody id="renewalSummaryBody">
              <tr><td colspan="6" class="note">Run Renewals to populate Renewed. Upload & confirm mapping to see expirations.</td></tr>
            </tbody>
          </table>
          <div id="mtmSummary" class="note" style="margin-top:6px"></div>
        </div>
      </div>

      <div class="card">
        <h2 style="margin-bottom:8px" data-tab-scope="history">Floorplan Price Movement (History)</h2>
        <div class="row" style="align-items:end; margin-bottom:8px;">
          <div>
            <label><span class="iwrap">Select Floorplan
              <span class="help">i</span>
              <span class="itip">Choose a floorplan to view its adjusted base price over recent runs.</span>
            </span></label>
            <select id="fpHistorySelect"></select>
          </div>
          <div>
            <label><span class="iwrap">Points
              <span class="help">i</span>
              <span class="itip">How many recent runs to plot (max 100).</span>
            </span></label>
            <input id="fpHistoryLimit" type="number" min="5" max="100" step="5" value="30">
          </div>
        </div>
        <div style="height:220px;max-height:220px">
          <canvas id="fpHistoryChart" style="width:100%;height:100%"></canvas>
        </div>
        <div class="note">Plots the adjusted base price captured on each <strong>New</strong> run. Does not include term premiums or seasonality.</div>
      </div>


      <div class="card">
        <div class="actions" style="justify-content:space-between; align-items:center;">
          <div style="display:flex; align-items:center; gap:8px;">
            <h2 style="margin:0" data-tab-scope="newPricing">New Lease Pricing</h2>
            <div id="npSubtabBar" role="tablist" aria-label="New Pricing view" class="actions" style="gap:6px; margin-left:8px;">
              <button class="btn sm active" role="tab" data-subtab="fp" aria-selected="true" tabindex="0">Floorplan Pricing</button>
              <button class="btn sm" role="tab" data-subtab="unit" aria-selected="false" tabindex="-1">Unit Pricing</button>
            </div>
            <span id="pricingEngineBadge" class="badge" style="background:#0891b2; color:white; font-size:11px; display:none;">Engine: <span id="pricingEngineText">Loading...</span></span>
          </div>
          <div class="actions">
            <button id="runNew" class="btn primary">Run New</button>
            <button id="exportNew" class="btn" disabled>Export New</button>
            <label id="npShowUnitsWrap" class="inline-flex items-center hidden-soft" style="gap:8px; margin-left:8px;">
              <input type="checkbox" id="npShowUnits">
              <span>Show available units</span>
            </label>
          </div>
        </div>
        <div id="npPaneFP">
          <div id="nlBadge" class="note" style="margin:6px 0 4px; display:none;"></div>
          <div id="nlTables"></div>
        </div>
        <div id="npPaneUnit" class="tab-hidden">
          <div id="unitPricingSection" class="stack" style="margin-top:16px;"></div>
        </div>
      </div>

      <div class="card">
        <div class="actions sticky-summary" style="justify-content:space-between">
          <h2 style="margin:0" data-tab-scope="renewals">Renewal Offers</h2>
          <div class="actions">
            <button id="runRenew" class="btn primary">Run Renewals</button>
            <button id="exportRenew" class="btn" disabled>Export Renew</button>
          </div>
        </div>
        <div id="renBadge" class="note" style="margin:6px 0 4px; display:none;"></div>
        <div id="renTables"></div>
      </div>

      <div class="card" id="legendCard">
        <h2 data-tab-scope="newPricing renewals charts settings">Flags & Legend</h2>
        <ul id="flagList"></ul>
        <div class="note">
          🚩 Over max allowed expirations (seasonality) • 🏷️ Floor applied • ⏳ Vacant too long (30/60/90d) •
          📉 Renewal capped by guardrails • 🕰️ Tenure ≥30m • 💚 Above new lease by >10%
        </div>
      </div>

      <div class="card" id="historyCard" style="display:block">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <h2 style="margin:0">History (Local)</h2>
          <button id="clearHistoryBtn" class="btn xs" type="button">Clear history</button>
        </div>
        <div id="historyList" class="note" style="margin-top:8px"></div>
      </div>
    </div>
  </div>
</div>

<script src="./../src/js/seeds.js"></script>
<script src="./../src/js/pricing-helpers.js"></script>
<script src="./../src/js/validation.js"></script>
<script src="./../src/js/dev-guards.js"></script>
<script src="./../src/js/pricing-unit.js"></script>
<script src="./../src/js/pricing-fp.js"></script>
<script src="./../src/js/app-boot.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script>
(()=>{
  const $ = id => document.getElementById(id);
  const num = (v,d=0)=>{const n=Number(v);return isNaN(n)?d:n};
  const clamp=(x,lo,hi)=>Math.min(Math.max(x,lo),hi);
  const fmt=(v)=> (v==null||isNaN(v)?"":"$"+Math.round(v).toLocaleString());
  const fmtDate = (s)=>{const d=new Date(s); return isNaN(d)? "—" : d.toLocaleDateString(); };
  const monthKey=(dt)=>{const d=new Date(dt);if(isNaN(d))return null;return d.getFullYear()+"-"+String(d.getMonth()+1).padStart(2,"0");};
  let allowedPctByMonth = [0.04,0.04,0.07,0.09,0.11,0.12,0.12,0.11,0.09,0.07,0.06,0.08];

  
  // --- Export capture storage (split by panel) ---
  let __newPricingRows = [];             // [["Floorplan","Term (mo)","Price ($)"], ...] for New Pricing
  let __seasonalityNewRows = [];         // [["Month","Actual Expirations","Allowed Max"], ...] for New run

  let __renewalsRows = [];               // [["Unit","Floorplan","Lease End","Term (mo)","Offer ($)",...], ...] for Renewals
  let __seasonalityRenewRows = [];       // [["Month","Actual Expirations","Allowed Max"], ...] for Renew run
  // expose buffers to window for cross-module access
  window.__newPricingRows = __newPricingRows;
  window.__seasonalityNewRows = __seasonalityNewRows;
  window.__renewalsRows = __renewalsRows;
  window.__seasonalityRenewRows = __seasonalityRenewRows;

  function resetNewBuffers(){
    __newPricingRows = [["Floorplan","Starting Rent ($)","Term (mo)","Price ($)"]];
    __seasonalityNewRows = [["Month","Actual Expirations","Allowed Max"]];
    window.__newPricingRows = __newPricingRows;
    window.__seasonalityNewRows = __seasonalityNewRows;
  }
  function resetRenewBuffers(){
  __renewalsRows = [[
    "Unit","Floorplan","Lease End","Term (mo)",
    "Offer ($)","Current ($)","Starting Rent ($)","Baseline New ($)",
    "Pct-to-New","Guardrail Max",
    "BasePct","TermPremiumPct","FinalPctApplied","GuardrailsOn",
    "ShortTermPct","OverCapPct","SeasonalityPct"
  ]];
    __seasonalityRenewRows = [["Month","Actual Expirations","Allowed Max"]];
    window.__renewalsRows = __renewalsRows;
    window.__seasonalityRenewRows = __seasonalityRenewRows;
  }

  // Per-panel export buttons
  function enableExportNew(on){ const b=$("exportNew"); if(b) b.disabled=!on; }
  function enableExportRenew(on){ const b=$("exportRenew"); if(b) b.disabled=!on; }

  function exportNew(){
    if (__newPricingRows.length <= 1 || __seasonalityNewRows.length <= 1){
      alert("Run New first."); return;
    }
    const wb = XLSX.utils.book_new();
    const ws1 = XLSX.utils.aoa_to_sheet(__newPricingRows);
    const ws2 = XLSX.utils.aoa_to_sheet(__seasonalityNewRows);
    XLSX.utils.book_append_sheet(wb, ws1, "New Pricing");
    XLSX.utils.book_append_sheet(wb, ws2, "Seasonality");
    const fname = "export_new_" + new Date().toISOString().slice(0,19).replace(/[:T]/g,"-") + ".xlsx";
    XLSX.writeFile(wb, fname);
  }

  
  function setBadge(elId, kind, rows){
    const el = $(elId);
    if(!el) return;
    const ts = new Date();
    const stamp = ts.toLocaleString();
    const label = kind === "new" ? "New" : "Renew";
    const count = Math.max(0, rows|0);
    el.textContent = `Last run: ${label} • rows: ${count} • ${stamp}`;
    el.style.display = "block";
  }

  function exportRenew(){
    if (__renewalsRows.length <= 1 || __seasonalityRenewRows.length <= 1){
      alert("Run Renewals first."); return;
    }
    const wb = XLSX.utils.book_new();
    const ws1 = XLSX.utils.aoa_to_sheet(__renewalsRows);
    const ws2 = XLSX.utils.aoa_to_sheet(__seasonalityRenewRows);
    XLSX.utils.book_append_sheet(wb, ws1, "Renewals");
    XLSX.utils.book_append_sheet(wb, ws2, "Seasonality");
    const fname = "export_renew_" + new Date().toISOString().slice(0,19).replace(/[:T]/g,"-") + ".xlsx";
    XLSX.writeFile(wb, fname);
  }
  // (removed global click dispatcher to avoid double-trigger on export buttons)
  function enableExportBtn(){}
  function exportXLSX(){ alert("Use the panel-specific Export buttons."); }

  function enableExportNew(on){ const b=$("exportNew"); if(b) b.disabled=!on; }
  function enableExportRenew(on){ const b=$("exportRenew"); if(b) b.disabled=!on; }

  // Build renewal terms 2..24 months
  function buildRenTerms(){
    const el=$("renTermBox"); el.innerHTML="";
    for(let t=2;t<=24;t++){
      const id="ren_t_"+t;
      el.insertAdjacentHTML("beforeend",`
        <label style="display:flex;align-items:center;gap:6px;">
          <input type="checkbox" id="${id}" value="${t}" ${t<=14?'checked':''}>
          <span>${t}</span>
        </label>
      `);
    }
  }
  buildRenTerms();
  const readRenTerms = ()=> Array.from(document.querySelectorAll("#renTermBox input:checked")).map(x=>parseInt(x.value)).sort((a,b)=>a-b);

  // CSV mapping
  let rawRows=[], mapping=null, mappedRows=[];
  const targetFields = [
    {key:"UnitID", req:true,  hints:["unitid","unit","apt"]},
    {key:"Floorplan", req:true, hints:["floorplan","type","unittype","plan"]},
    {key:"Bedrooms", req:false, hints:["bedrooms","beds","br","bd","bed"]},
    {key:"Status", req:true, hints:["status","occupancy","occ"]},
    {key:"CurrentRent", req:true, hints:["currentrent","rent","base rent"]},
    {key:"LeaseEnd", req:false, hints:["leaseend","expiration","exp date","move out"]},
    {key:"PreleaseStart", req:false, hints:["prelease","future lease","future start"]},
    {key:"VacantDays", req:false, hints:["vacantdays","days vacant"]},
    {key:"MoveInDate", req:false, hints:["movein","lease start"]},
    {key:"AmenityAdj", req:false, hints:["amenity adj","premium","discount"]},
  ];
  const normalizeHeader=(s)=> String(s||"").toLowerCase().replace(/[^a-z0-9]/g,"");

  // Dashboard stats update function (defined globally for seeded mode)
  (function(){
    function statusStr(s){ return String(s||"").toLowerCase(); }
    function isVacant(s){ s=statusStr(s); return s.includes("vacant"); }
    function isNotice(s){ s=statusStr(s); return s.includes("notice"); }
    function isOccLike(s){ s=statusStr(s); return s.startsWith("occupied") || s.includes("notice"); }

    function calcTrending(rows){
      const N = rows.length;
      let vac=0, notices=0, preRaw=0, occ=0;
      for(const r of rows){
        const s = statusStr(r.Status);
        if (isVacant(s)) vac++;
        if (isNotice(s)) notices++;
        if (isOccLike(s)) occ++;
        if (r.PreleaseStart) preRaw++;
      }
      const pre = Math.min(preRaw, vac + notices);
      const todayOcc = N ? (occ / N) : 0;
      const trending = N ? ((occ + pre - notices) / N) : 0;
      return { todayOcc, trending: Math.max(0, Math.min(1, trending)), total: N, occ, notices, pre };
    }

    function calcStrugglingFPs(rows, targetOcc){
      const by = new Map();
      for(const r of rows){
        const fp = r.Floorplan || "(unknown)";
        if (!by.has(fp)) by.set(fp, []);
        by.get(fp).push(r);
      }
      const out=[];
      for (const [fp, list] of by.entries()){
        const t = calcTrending(list).trending;
        if (t < targetOcc) out.push({ code: fp, trendingOcc: t });
      }
      out.sort((a,b)=> (a.trendingOcc - b.trendingOcc));
      return out;
    }

    function calcStale(rows){
      const list = rows.filter(r => (Number(r.VacantDays)||0) >= 30 && isVacant(r.Status));
      list.sort((a,b)=> (Number(b.VacantDays)||0) - (Number(a.VacantDays)||0));
      return list.map(r => ({
        unit: r.UnitID || r.Unit || "—",
        fp: r.Floorplan || "",
        days: Number(r.VacantDays)||0,
        fpPrice: r.Price || r.NewPrice || null,
        hasPre: !!r.PreleaseStart
      }));
    }

    function calcExpiring(rows){
      const in30 = new Date(); in30.setDate(in30.getDate()+30);
      let exp=0;
      for(const r of rows){
        if(!r.LeaseEnd) continue;
        const d = new Date(r.LeaseEnd);
        if(!isNaN(d) && d <= in30) exp++;
      }
      return { expiring30d: exp, undecided30d: exp };
    }

    function updateWidgetData(rows){
      const cfg = (typeof readCfg==='function') ? readCfg() : { comfortTarget: 0.95 };
      const t = calcTrending(rows);
      const exp = calcExpiring(rows);
      const stale = calcStale(rows);
      const fps = calcStrugglingFPs(rows, cfg.comfortTarget || 0.95);

      window.totalUnits = t.total;
      window.occupiedNow = t.occ;
      window.onNotice = t.notices;
      window.preleased = t.pre;

      window.todayOcc = t.todayOcc;
      window.undecidedRenewals30d = exp.undecided30d;
      window.expiring30d = exp.expiring30d;
      window.approvals7d = window.approvals7d || 0;
      window.strugglingFPs = fps;
      window.staleUnits30d = stale;

      if (typeof repaintStatus45 === 'function') repaintStatus45();
    }

    window.__updateStatusFromMappedRows = updateWidgetData;
  })();

  // Show confirm overlay with detected columns and mapping status (DEPRECATED in seeded mode)
  function showConfirmOverlay() {
    const overlay = document.getElementById('confirmOverlay');
    const detectedColumns = document.getElementById('detectedColumns');
    const mappingStatus = document.getElementById('mappingStatus');
    
    if (!overlay || !detectedColumns || !mappingStatus) return;
    
    // Get detected columns from rawRows
    const cols = window.rawRows ? Object.keys(window.rawRows[0] || {}) : [];
    const detectedCols = ['Unit', 'Status', 'CurrentRent', 'LeaseEnd', 'PreleaseStart', 'Floorplan Label'].filter(col => 
      cols.some(c => c.toLowerCase().includes(col.toLowerCase().replace(' ', '')))
    );
    
    // Check if seeds were used
    const seedsUsed = window._seedsUsed || false;
    const mappingSource = seedsUsed ? 'from seeds' : 'from saved mapping';
    
    detectedColumns.innerHTML = `
      <strong>Detected Columns:</strong><br>
      ${detectedCols.map(col => `• ${col}`).join('<br>')}
    `;
    
    mappingStatus.innerHTML = `
      <strong>Mapping Status:</strong> ${mappingSource}<br>
      <small>All floorplan labels have been mapped successfully</small>
    `;
    
    overlay.style.display = 'flex';
  }

  // Execute mapping confirmation (called automatically in seeded mode)
  function executeMappingConfirmation() {
    console.log('[RM Seeds] Executing automatic mapping confirmation');
    
    // Validate required fields
    const reqMissing = targetFields.filter(tf => tf.req && !mapping[tf.key]);
    if (reqMissing.length) {
      alert(`Missing required fields: ${reqMissing.map(x => x.key).join(", ")}`);
      return;
    }
    
    // Map raw rows to structured format
    mappedRows = rawRows.map(r => ({
      UnitID:       mapping.UnitID       ? r[mapping.UnitID]       : "",
      Floorplan:    mapping.Floorplan    ? r[mapping.Floorplan]    : "",
      Bedrooms:     mapping.Bedrooms     ? Number(r[mapping.Bedrooms]) : NaN,
      Status:       (mapping.Status      ? String(r[mapping.Status]) : "").toLowerCase(),
      CurrentRent:  mapping.CurrentRent  ? Number(r[mapping.CurrentRent]) : NaN,
      LeaseEnd:     mapping.LeaseEnd     ? r[mapping.LeaseEnd]     : "",
      PreleaseStart:mapping.PreleaseStart? r[mapping.PreleaseStart]: "",
      VacantDays:   mapping.VacantDays   ? Number(r[mapping.VacantDays]) : 0,
      MoveInDate:   mapping.MoveInDate   ? r[mapping.MoveInDate]   : "",
      AmenityAdj:   mapping.AmenityAdj   ? Number(r[mapping.AmenityAdj]) : 0
    }));
    
    // Store globally
    window.mappedRows = mappedRows;
    
    // Set upload flag
    try { 
      if (typeof window.setHasUpload === 'function') window.setHasUpload(); 
    } catch(e) {
      console.error('[RM Seeds] Error setting upload flag:', e);
    }
    
    // Trigger related updates
    try {
      const rows = (window.propertySetup && window.propertySetup.floorplans) || [];
      if (!rows.length) {
        if (typeof prefillFromRentRoll === 'function') prefillFromRentRoll();
      } else {
        if (typeof mergeFromRentRoll === 'function') mergeFromRentRoll();
      }
      if (typeof window.renderFPMapCard === 'function') window.renderFPMapCard();
      if (typeof window.autoMapFromSettings === 'function') window.autoMapFromSettings();
      if (typeof window.__applyLockState === 'function') window.__applyLockState();
    } catch(e) {
      console.error('[RM Seeds] Error during post-mapping updates:', e);
    }
    
    // Update dashboard stats
    try {
      if (typeof window.__updateStatusFromMappedRows === 'function') {
        window.__updateStatusFromMappedRows(mappedRows);
        console.log('[RM Seeds] Dashboard stats updated');
      }
    } catch(e) {
      console.error('[RM Seeds] Error updating dashboard stats:', e);
    }
    
    console.log(`[RM Seeds] ✅ Mapping confirmed - ${mappedRows.length} units loaded from Thorpe Gardens`);
  }

  $("file").addEventListener("change",(e)=>{
    const f=e.target.files?.[0]; if(!f) return;
    Papa.parse(f,{header:true,skipEmptyLines:true,complete:(r)=>{
      rawRows=r.data;
      const cols=Object.keys(rawRows[0]||{});
      
      // PROPERTY PROFILE VALIDATION (temporarily disabled for testing)
      const strictMode = false; // window.isStrictMappingEnabled && window.isStrictMappingEnabled();
      if (strictMode) {
        // Ensure Thorpe Gardens profile is initialized
        if (window.initializeThorpeGardensProfile) {
          window.initializeThorpeGardensProfile();
        }
        
        const propertyProfile = window.loadPropertyProfile && window.loadPropertyProfile();
        if (propertyProfile && window.RMValidation) {
          const csvData = { headers: cols, rows: rawRows };
          
          // Simple floorplan validation - just check if CSV has Thorpe Gardens floorplans
          const csvFloorplans = rawRows.map(row => row.Floorplan || row.floorplan).filter(Boolean);
          const uniqueFloorplans = [...new Set(csvFloorplans)];
          
          const hasValidFloorplans = propertyProfile.floorplanCatalog.every(expectedFp => 
            uniqueFloorplans.includes(expectedFp)
          );
          
          if (!hasValidFloorplans) {
            const missingFloorplans = propertyProfile.floorplanCatalog.filter(fp => 
              !uniqueFloorplans.includes(fp)
            );
            alert(`❌ Wrong Property Uploaded!\n\nThis CSV doesn't contain Thorpe Gardens floorplans.\n\nMissing floorplans: ${missingFloorplans.join(', ')}\n\nFound floorplans: ${uniqueFloorplans.join(', ')}\n\nExpected floorplans: ${propertyProfile.floorplanCatalog.join(', ')}\n\nOnly Thorpe Gardens rent rolls are accepted.`);
            e.target.value = ''; // Clear file input
            return;
          }
        } else if (propertyProfile) {
          alert('❌ Strict mapping is enabled but validation system not available.\n\nPlease refresh the page and try again.');
          e.target.value = ''; // Clear file input
          return;
        } else {
          // No property profile - this is the first upload (admin setup)
          console.log('[RM] First upload - will establish property profile');
        }
      }
      
      mapping={};
      const lower = cols.map(c=>({orig:c, norm:normalizeHeader(c)}));
      for(const tf of targetFields){
        let best = lower.find(c=>c.norm===normalizeHeader(tf.key));
        if(!best) best = lower.find(c=>tf.hints.some(h=>c.norm===normalizeHeader(h)));
        mapping[tf.key] = best ? best.orig : "";
      }
      
      // SEEDED FP MAPPING - Auto-map floorplan labels using seeds or saved map
      const propertyId = window.__seedPropertySetup?.property_id || 'thorpe-gardens';
      const fpMapKey = `rm:fpmap:${propertyId}`;
      const savedFPMap = JSON.parse(localStorage.getItem(fpMapKey) || '{}');
      const seedFPMap = window.__seedFPMap || {};
      
      // Use saved map if available, otherwise use seeds
      const activeFPMap = Object.keys(savedFPMap).length > 0 ? savedFPMap : seedFPMap;
      const seedsUsed = Object.keys(savedFPMap).length === 0 && Object.keys(seedFPMap).length > 0;
      
      // Track if seeds were used for this session
      window._seedsUsed = seedsUsed;
      
      // Auto-map floorplan labels
      const floorplanCol = mapping.Floorplan || mapping.floorplan;
      if (floorplanCol && rawRows.length > 0) {
        const uniqueFloorplanLabels = [...new Set(rawRows.map(row => row[floorplanCol]).filter(Boolean))];
        let allMapped = true;
        let unmappedLabels = [];
        
        // Check if all labels are mapped
        for (const label of uniqueFloorplanLabels) {
          if (!activeFPMap[label]) {
            allMapped = false;
            unmappedLabels.push(label);
          }
        }
        
        if (allMapped) {
          // All labels mapped - proceed directly to confirmation
          console.log('[RM Seeds] All floorplan labels mapped successfully');
          if (seedsUsed) {
            console.log('[RM Seeds] Using seeded FP map from Thorpe Gardens property');
          } else {
            console.log('[RM Seeds] Using saved FP map');
          }
          
          // Store mapping and rawRows in global scope
          window.mapping = mapping;
          window.rawRows = rawRows;
          
          // Hide mapping table - no user confirmation needed in seeded mode
          $("automap").style.display = "none";
          
          // Execute mapping confirmation directly (skip overlay)
          executeMappingConfirmation();
          return;
        } else {
          // Some labels unmapped - REJECT UPLOAD COMPLETELY
          console.error('[RM Seeds] Upload rejected - unmapped floorplan labels:', unmappedLabels);
          
          const propertyName = window.__seedPropertySetup?.property_name || 'Thorpe Gardens';
          alert(`❌ Wrong Property CSV\n\nThis CSV contains floorplan labels that don't match ${propertyName}:\n\n${unmappedLabels.join('\n')}\n\n${propertyName} only accepts these floorplans:\n• S0 - Studio\n• A1 - 1x1\n• B2 - 2x2\n• C3 - 3x2 Small\n\nPlease upload a ${propertyName} rent roll instead.`);
          
          // Reset file input to allow re-upload
          const fileInput = $("rentRollFile");
          if (fileInput) fileInput.value = '';
          
          // Hide mapping UI completely
          $("automap").style.display = "none";
          
          return; // Stop processing completely
        }
      }
      
      // Store mapping and rawRows in global scope for property profile creation
      window.mapping = mapping;
      window.rawRows = rawRows;
      
      renderMappingTable(cols, mapping); $("automap").style.display="block"; validateMappingPreview();
    },error:(err)=>alert("Parse error: "+err.message)});
  });

  function renderMappingTable(cols, mapping){
    const opts = sel => ["",...cols].map(c=>`<option ${mapping[sel]===c?"selected":""}>${c}</option>`).join("");
    const rows = targetFields.map(tf=>`
      <tr><td>${tf.key}${tf.req?" *":""}</td>
      <td><select class="sel mapSel" data-key="${tf.key}">${opts(tf.key)}</select></td></tr>`).join("");
    $("mapTable").innerHTML = `<table class="basic"><thead><tr><th>Field</th><th>CSV Column</th></tr></thead><tbody>${rows}</tbody></table>`;
    document.querySelectorAll(".mapSel").forEach(el=> el.addEventListener("change",()=>{mapping[el.dataset.key]=el.value; validateMappingPreview();}));
  }
  function validateMappingPreview(){
    const reqMissing = targetFields.filter(tf=>tf.req && !mapping[tf.key]);
    $("validationBox").textContent = reqMissing.length ? `Missing required: ${reqMissing.map(x=>x.key).join(", ")}` : "Looks good.";
    return !reqMissing.length;
  }

  $("confirmMapping").onclick=()=>{
    if(!validateMappingPreview()){ alert("Fix required fields first."); return; }
    mappedRows = rawRows.map(r=>({
      UnitID:       mapping.UnitID       ? r[mapping.UnitID]       : "",
      Floorplan:    mapping.Floorplan    ? r[mapping.Floorplan]    : "",
      Bedrooms:     mapping.Bedrooms     ? Number(r[mapping.Bedrooms]) : NaN,
      Status:       (mapping.Status      ? String(r[mapping.Status]) : "").toLowerCase(),
      CurrentRent:  mapping.CurrentRent  ? Number(r[mapping.CurrentRent]) : NaN,
      LeaseEnd:     mapping.LeaseEnd     ? r[mapping.LeaseEnd]     : "",
      PreleaseStart:mapping.PreleaseStart? r[mapping.PreleaseStart]: "",
      VacantDays:   mapping.VacantDays   ? Number(r[mapping.VacantDays]) : 0,
      MoveInDate:   mapping.MoveInDate   ? r[mapping.MoveInDate]   : "",
      AmenityAdj:   mapping.AmenityAdj   ? Number(r[mapping.AmenityAdj]) : 0
    }));
    alert("Mapping confirmed. Use Run New or Run Renewals to generate results."); window.mappedRows = mappedRows;
    try{ if (typeof window.setHasUpload==='function') window.setHasUpload(); }catch(e){}
    try{
      const rows=(window.propertySetup&&window.propertySetup.floorplans)||[];
      if (!rows.length) prefillFromRentRoll(); else mergeFromRentRoll();
      if (typeof window.renderFPMapCard==='function') window.renderFPMapCard();
      if (typeof window.autoMapFromSettings==='function') window.autoMapFromSettings();
      if (typeof window.__applyLockState==='function') window.__applyLockState();
    }catch(e){}

    // Update dashboard stats (function now defined globally)
    if (Array.isArray(window.mappedRows) && typeof window.__updateStatusFromMappedRows === 'function') { 
      window.__updateStatusFromMappedRows(window.mappedRows); 
    }
  };

  // Seasonality chart + over-cap calc
  let seasonChart, overByKey={};
  function renderSeasonality(norm, rowsTarget){
        const start=new Date(); start.setDate(1);
    const keys=[], labels=[];
    for(let i=0;i<12;i++){ const d=new Date(start); d.setMonth(d.getMonth()+i); keys.push(d.getFullYear()+"-"+String(d.getMonth()+1).padStart(2,"0")); labels.push(d.toLocaleString(undefined,{month:"short"})); }
    const count=Object.fromEntries(keys.map(k=>[k,0]));
    norm.filter(r=>r.LeaseEnd).forEach(r=>{ const k=monthKey(r.LeaseEnd); if(k && count[k]!=null) count[k]++; });
    const actual = keys.map(k=>count[k]||0);
    const allowed = keys.map((k,i)=>Math.round((norm.length)*allowedPctByMonth[i%12]));
    overByKey={};
    keys.forEach((k,i)=>{ const over=Math.max(0,(actual[i]||0)-(allowed[i]||0)); if(over>0) overByKey[k]=over; });
    const ctx=$("seasonChart").getContext("2d");
    if(seasonChart) seasonChart.destroy();
    seasonChart = new Chart(ctx,{type:"bar",data:{labels, datasets:[{label:"Actual expirations",data:actual},{label:"Max allowed",type:"line",data:allowed}]},options:{responsive:true,maintainAspectRatio:false,plugins:{legend:{position:"bottom"}},scales:{x:{grid:{display:false}},y:{beginAtZero:true}}}});
    if (rowsTarget && Array.isArray(rowsTarget)) { for(let i=0;i<keys.length;i++){ rowsTarget.push([labels[i], actual[i]||0, allowed[i]||0]); } }
    const overMonths = keys.map((k,i)=> actual[i]>allowed[i]? labels[i]:null).filter(Boolean);
    if(overMonths.length){ flag(`🚩 Over max allowed expirations in: ${overMonths.join(", ")}`); }
  }
  const seasonalityMultiplier=(curve,endKey)=>{
    const curveAlpha = {minimal:0.01, normal:0.02, aggressive:0.03}[curve]||0.02;
    const over = overByKey[endKey]||0;
    return 1 + curveAlpha * over;
  };

  function flag(msg){ const li=document.createElement("li"); li.textContent=msg; $("flagList").appendChild(li); }
  function groupBy(arr,fn){ const m=new Map(); for(const x of arr){ const k=fn(x); m.set(k,(m.get(k)||[]).concat([x])); } return m; }

  // Pricing pieces
  function readCfg(){
    return {
      comfortTarget: num($("comfortTarget").value,95)/100,
      bandLow: Math.max(0.80, Math.min(1.00, (num($("comfortTarget").value,95)-2)/100)),
      bandHigh: Math.max(0.80, Math.min(1.00, (num($("comfortTarget").value,95)+1)/100)),
      convSensitivity: $("convSensitivity").value,
      priceResponse: $("priceResponse").value,
      fpSensitivity: 'medium',
      seasonalityCurve: $("seasonalityCurve").value,
      agedVacantPolicy: $("agedVacantPolicy").value,
      showDiscount: $("showDiscount").checked,
      floorBadge: $("floorBadge").checked,
      // renewals
      allowDecAbove: $("allowDecAbove").checked,
      capAllTerms: $("capAllTerms").checked,
      strengthToMarket: $("strengthToMarket").value,
      pctToNew: num($("pctToNew").value,50)/100,
      renMin: num($("renMin").value,0)/100,
      renMax: num($("renMax").value,10)/100,
      renAboveMin: num($("renAboveMin").value,0)/100,
      renAboveMax: num($("renAboveMax").value,0)/100,
      renewalAwareness: $("renewalAwareness").value,
      renTerms: (window.readRenTermsCompact ? window.readRenTermsCompact() : readRenTerms()),
      nlTerms: (window.readNLTerms ? window.readNLTerms() : [2,3,4,5,6,7,8,9,10,11,12,13,14]),
      maxWeeklyDec: num($("maxWeeklyDec").value,2)/100,
      // safety
      changeCadence: $("changeCadence").value,
      reviewLarge: $("reviewLarge").checked,
      fs_windowDays: num(document.getElementById('fs_windowDays')?.value, 28),
      fs_minLeads: num(document.getElementById('fs_minLeads')?.value, 50),
      fs_thrWeak: num(document.getElementById('fs_thrWeak')?.value, 20),
      fs_thrCautious: num(document.getElementById('fs_thrCautious')?.value, 30)
    };
  }

  function writeCfg(c){
    // Update only our new display settings inputs if present
    try{
      if (document.getElementById('fs_windowDays')) document.getElementById('fs_windowDays').value = String(c.fs_windowDays ?? 28);
      if (document.getElementById('fs_minLeads')) document.getElementById('fs_minLeads').value = String(c.fs_minLeads ?? 50);
      if (document.getElementById('fs_thrWeak')) document.getElementById('fs_thrWeak').value = String(c.fs_thrWeak ?? 20);
      if (document.getElementById('fs_thrCautious')) document.getElementById('fs_thrCautious').value = String(c.fs_thrCautious ?? 30);
    }catch(e){}
    return c;
  }

  // Conversion map
  const CONV = { low:{target:0.20,tol:0.03,step:0.005}, medium:{target:0.25,tol:0.02,step:0.010}, high:{target:0.30,tol:0.015,step:0.015} };
  const PRICE_STEP = {gentle:0.0075, standard:0.015, fast:0.025};


  function computeMoveSingleThreshold(cfg, fpTrend, commTrend, nFp){
    return 0;
  }

  function computeDirSmooth(code, fpLabel, cfg, tState, setupByCode){
    try{
      const row = (setupByCode && setupByCode[code]) || {};
      const low = Number(row.band_low_pct||0) || Math.round((cfg.bandLow||0.93)*100);
      const high= Number(row.band_high_pct||0) || Math.round((cfg.bandHigh||0.96)*100);
      const mid = (low + high) / 2;
      const occ_fp = Number(tState && (tState.tFP[code] ?? tState.tFP[fpLabel])) || 0; // 0..1
      const occ_site = Number(tState && tState.tComm) || 0; // 0..1
      const target_site = Number(cfg && cfg.comfortTarget) || 0.95;

      const dev_pp = (occ_fp*100) - mid; // percent-points
      const sign = dev_pp < 0 ? -1 : (dev_pp > 0 ? +1 : 0);

      const S = { maxMove: 0.05, k: 1.4 }; // Balanced
      const pr = String(cfg && cfg.priceResponse || 'standard').toLowerCase();
      if (pr === 'fast') S.maxMove = 0.08;       // Aggressive: ±8%
      else if (pr === 'gentle') S.maxMove = 0.03; // Conservative: ±3%
      else S.maxMove = 0.05;                     // Standard/Balanced: ±5%

      // Normalize distance: 5pp => x=1
      const x = Math.abs(dev_pp) / 5;
      let mag = S.maxMove * Math.tanh(S.k * x); // 0..maxMove

      // Community bias
      const deltaSitePP = ((occ_site - target_site) * 100);
      let biasMult = 1.0;
      if (deltaSitePP > 1 && sign > 0){
        biasMult = 1 + Math.min(0.15 * deltaSitePP, 0.30);
      } else if (deltaSitePP < -1 && sign < 0){
        biasMult = 1 + Math.min(0.15 * Math.abs(deltaSitePP), 0.30);
      }
      mag *= biasMult;

      if (sign < 0){
        const minDrop   = Number(cfg && cfg.commMinDropWhenAtOrBelowTargetPct) || 0.004; // 0.4%
        const dampStart = Number(cfg && cfg.commDampenStartAboveTargetPP)   || 1.0;      // +1 pp
        const blockAt   = Number(cfg && cfg.commBlockAboveTargetPP)         || 4.0;      // +4 pp
        const slopePP   = Number(cfg && cfg.commDampenSlopePerPP)           || 0.15;     // per-pp
        const dampFloor = Number(cfg && cfg.commDampenFloor)                || 0.25;     // ≥25%

        if (occ_site <= target_site){
          // Enforce minimum negative move when at/below target
          mag = Math.max(mag, minDrop);
        } else {
          // Site above target: dampen or block decreases progressively
          if (deltaSitePP >= blockAt){
            mag = 0;
          } else if (deltaSitePP >= dampStart){
            let factor = 1 - slopePP * (deltaSitePP - dampStart);
            // Clamp factor between dampFloor..1
            factor = Math.max(dampFloor, Math.min(1, factor));
            mag *= factor;
          }
        }
      }

      // Cap to sensitivity max and restore sign
      mag = Math.min(mag, S.maxMove);
      let dir = sign * mag;

      // Center deadband with tiny assist if bias applies
      const CENTER_DEADBAND_PP = 0.3;
      if (Math.abs(dev_pp) < CENTER_DEADBAND_PP){
        if (biasMult > 1.0){
          const tiny = Math.min(0.0025 * (S.maxMove/0.05), 0.005);
          const nudgeSign = sign || (deltaSitePP>0? +1 : -1);
          dir = nudgeSign * tiny;
        } else {
          dir = 0;
        }
      }

      const biasPct = Math.max(0, (biasMult - 1) * 100);
      return { dir: Number.isFinite(dir)? dir: 0, mid, dev_pp, biasPct };
    }catch(e){ return { dir:0, mid:NaN, dev_pp:NaN, biasPct:0 }; }
  }
function computeTrending(norm){
  // Box Score-equivalent helpers
  const status = (s)=> String(s||'').toLowerCase();
  const isVac = (s)=> status(s).includes('vacant');
  const isNotice = (s)=> status(s).includes('notice');
  const isOccLike = (s)=> status(s).startsWith('occupied') || status(s).includes('notice');

  // Community counts
  const N = norm.length;
  let vac = 0, notices = 0, preRaw = 0, occ = 0;
  for(const r of norm){
    const s = status(r.Status);
    if (isVac(s)) vac++;
    if (isNotice(s)) notices++;
    if (isOccLike(s)) occ++;
    if (r.PreleaseStart) preRaw++;
  }
  const pre = Math.min(preRaw, vac + notices); // cannot replace more than pending move-outs
  const occPct = N ? (occ / N) : 0;
  const projected = N ? (1 - ((vac + notices - pre) / N)) : 0;
  const tComm = Math.max(0, Math.min(1, projected));

  // Floorplan-level projected (same rules)
  const byFP = (function groupBy(arr,fn){ const m=new Map(); for(const x of arr){ const k=fn(x); m.set(k,(m.get(k)||[]).concat([x])); } return m; })(norm, r => r.Floorplan || "(unknown)");
  const tFP = {};
  for (const [fp, list] of byFP.entries()){
    const n = list.length;
    let v = 0, no = 0, pr = 0, oc = 0;
    for(const r of list){
      const s = status(r.Status);
      if (isVac(s)) v++;
      if (isNotice(s)) no++;
      if (isOccLike(s)) oc++;
      if (r.PreleaseStart) pr++;
    }
    const pre2 = Math.min(pr, v + no);
    const proj2 = n ? (1 - ((v + no - pre2) / n)) : 0;
    tFP[fp] = Math.max(0, Math.min(1, proj2));
  }

  return { tComm, tFP, occPct }; // occPct included for possible UI chips
}


  function applyIFTHEN(cfg, tFP, tComm, fp){
    const f=tFP[fp]; const c=tComm;
    const low=cfg.bandLow, high=cfg.bandHigh;
    const outsideStep = PRICE_STEP[cfg.priceResponse];
    if (f>high && c<low) return 0;
    if (f>high && c>=low && c<=high) return +outsideStep;
    if (f>high && c>high) return -outsideStep;
    if (f>=low && f<=high && c>high) return 0;
    if (f>=low && f<=high && c>=low && c<=high) return 0;
    if (f>=low && f<=high && c<low) return 0;
    if (f<low && c<low) return -outsideStep;
    if (f<low && c>=low && c<=high) return -outsideStep;
    if (f<low && c>high) return 0;
    return 0;
  }

  function vacancySpecialPct(v){
    if (v>=90) return 0.15;
    if (v>=60) return 0.10;
    if (v>=30) return 0.05;
    return 0;
  }

  function shortTermAdj(base, term){
    if (term>=10) return base;
    const start = 0.08, taper = 0.01;
    const extra = Math.max(0, start - (term-2)*taper);
    return base*(1+extra);
  }

  function renewalBase(current,newLease,cfg,isAbove){
    // Helper: order-aware clamp
    const ordClamp = (x, a, b) => {
      const lo = Math.min(a, b);
      const hi = Math.max(a, b);
      return Math.min(Math.max(x, lo), hi);
    };

    if(!isAbove){
      // BELOW NEW: move toward new by pctToNew, then clamp by [renMin, renMax] (order-aware)
      const target = current + (newLease - current) * (cfg.pctToNew || 0);
      let d = (target / Math.max(1, current)) - 1; // expected >= 0
      const lo = (typeof cfg.renMin === 'number') ? cfg.renMin : 0;
      const hi = (typeof cfg.renMax === 'number') ? cfg.renMax : 0;
      d = ordClamp(d, lo, hi);
      return current * (1 + d);
    } else {
      // ABOVE NEW: move toward new by pctToNew (typically negative), respect allowDecAbove,
      // then clamp by [renAboveMin, renAboveMax] (order-aware; values may be negative)
      const toward = current - (current - newLease) * (cfg.pctToNew || 0);
      let d = (toward / Math.max(1, current)) - 1; // typically < 0
      if (!cfg.allowDecAbove) d = Math.max(0, d); // disallow decreases if configured

      const loRaw = (typeof cfg.renAboveMin === 'number') ? cfg.renAboveMin : -1;
      const hiRaw = (typeof cfg.renAboveMax === 'number') ? cfg.renAboveMax : 0; // negative max => allow decreases
      d = ordClamp(d, loRaw, hiRaw);

      return current * (1 + d);
    }
  }

  function applyRenewalGuardrailMax(cfg, pctChange, isAbove, allowDecAbove){
    // pctChange is (finalPrice/current) - 1 AFTER premiums
    if (!isAbove){
      // BELOW new lease path: cap upward % by renMax; do NOT enforce a min.
      const cappedUp = Math.min(pctChange, cfg.renMax||0);
      return cappedUp;
    } else {
      // ABOVE new lease path:
      // - If decreases are not allowed, clamp negatives to 0 first.
      let p = allowDecAbove ? pctChange : Math.max(0, pctChange);
      // Apply above-new "max %" as an absolute magnitude cap (symmetric)
      const limit = Math.abs(cfg.renAboveMax||0);
      if (p > 0) p = Math.min(p, limit);
      if (p < 0) p = Math.max(p, -limit);
      return p;
    }
  }

  function explain(chips){
    const cap=chips.slice(0,3);
    return `<div>${cap.map(c=>`<span class="badge">${c}</span>`).join(" ")}</div>`;
  }

  // Debug helpers for base formula (added for Renewals debug)
  if (typeof _fmtPct !== 'function'){
    function _fmtPct(p){ return ((p*100).toFixed(1) + '%'); }
  }
  if (typeof _clampOrdered !== 'function'){
    function _clampOrdered(x, a, b){ const lo = Math.min(a, b), hi = Math.max(a, b); return Math.min(Math.max(x, lo), hi); }
  }
  if (typeof buildRenewalBaseFormulaDebug !== 'function'){
    function buildRenewalBaseFormulaDebug(current, newLease, cfg){
      const isAbove = current > newLease;
      const pctToNew = cfg.pctToNew || 0;
      if (!isAbove){
        const target = current + (newLease - current) * pctToNew;
        const rawPct = (target / Math.max(1, current)) - 1;
        const lo = (typeof cfg.renMin === 'number') ? cfg.renMin : 0;
        const hi = (typeof cfg.renMax === 'number') ? cfg.renMax : 0;
        const basePct = _clampOrdered(rawPct, lo, hi);
        const base = Math.round(current * (1 + basePct));
        return [
          'Base (below-new): ',
          `target = ${fmt(target)} = ${fmt(current)} + ${_fmtPct(pctToNew)}×(${fmt(newLease)} − ${fmt(current)})`,
          `; raw ${_fmtPct(rawPct)} → clamp[${_fmtPct(lo)}, ${_fmtPct(hi)}] = ${_fmtPct(basePct)}`,
          ` → base ${fmt(base)}`
        ].join('');
      } else {
        const toward = current - (current - newLease) * pctToNew;
        let rawPct = (toward / Math.max(1, current)) - 1; // typically negative
        const allowDec = !!cfg.allowDecAbove;
        const loRaw = (typeof cfg.renAboveMin === 'number') ? cfg.renAboveMin : -1;
        const hiRaw = (typeof cfg.renAboveMax === 'number') ? cfg.renAboveMax : 0;
        const afterAllow = allowDec ? rawPct : Math.max(0, rawPct);
        const basePct = _clampOrdered(afterAllow, loRaw, hiRaw);
        const base = Math.round(current * (1 + basePct));
        return [
          'Base (above-new): ',
          `toward = ${fmt(toward)} = ${fmt(current)} − ${_fmtPct(pctToNew)}×(${fmt(current)} − ${fmt(newLease)})`,
          `; raw ${_fmtPct(rawPct)}`,
          allowDec ? '' : ' → no-decrease max(0, raw)',
          ` → clamp[${_fmtPct(loRaw)}, ${_fmtPct(hiRaw)}] = ${_fmtPct(basePct)}`,
          ` → base ${fmt(base)}`
        ].join('');
      }
    }
  }

  // Debug helpers for base formula (safe additions)
  if (typeof _fmtPct !== 'function'){
    function _fmtPct(p){ return ((p*100).toFixed(1) + '%'); }
  }
  if (typeof _clampOrdered !== 'function'){
    function _clampOrdered(x, a, b){ const lo = Math.min(a, b), hi = Math.max(a, b); return Math.min(Math.max(x, lo), hi); }
  }
  if (typeof buildRenewalBaseFormulaDebug !== 'function'){
    function buildRenewalBaseFormulaDebug(current, newLease, cfg){
      const isAbove = current > newLease;
      const pctToNew = cfg.pctToNew || 0;
      if (!isAbove){
        const target = current + (newLease - current) * pctToNew;
        const rawPct = (target / Math.max(1, current)) - 1;
        const lo = (typeof cfg.renMin === 'number') ? cfg.renMin : 0;
        const hi = (typeof cfg.renMax === 'number') ? cfg.renMax : 0;
        const basePct = _clampOrdered(rawPct, lo, hi);
        const base = Math.round(current * (1 + basePct));
        return [
          'Base (below-new): ',
          `target = ${fmt(target)} = ${fmt(current)} + ${_fmtPct(pctToNew)}×(${fmt(newLease)} − ${fmt(current)})`,
          `; raw ${_fmtPct(rawPct)} → clamp[${_fmtPct(lo)}, ${_fmtPct(hi)}] = ${_fmtPct(basePct)}`,
          ` → base ${fmt(base)}`
        ].join('');
      } else {
        const toward = current - (current - newLease) * pctToNew;
        let rawPct = (toward / Math.max(1, current)) - 1; // typically negative
        const allowDec = !!cfg.allowDecAbove;
        const loRaw = (typeof cfg.renAboveMin === 'number') ? cfg.renAboveMin : -1;
        const hiRaw = (typeof cfg.renAboveMax === 'number') ? cfg.renAboveMax : 0;
        const afterAllow = allowDec ? rawPct : Math.max(0, rawPct);
        const basePct = _clampOrdered(afterAllow, loRaw, hiRaw);
        const base = Math.round(current * (1 + basePct));
        return [
          'Base (above-new): ',
          `toward = ${fmt(toward)} = ${fmt(current)} − ${_fmtPct(pctToNew)}×(${fmt(current)} − ${fmt(newLease)})`,
          `; raw ${_fmtPct(rawPct)}`,
          allowDec ? '' : ' → no-decrease max(0, raw)',
          ` → clamp[${_fmtPct(loRaw)}, ${_fmtPct(hiRaw)}] = ${_fmtPct(basePct)}`,
          ` → base ${fmt(base)}`
        ].join('');
      }
    }
  }

  
function renderRenewals(cfg,norm,tState){
  const wrap = $("renTables"); 
  wrap.innerHTML = "";

  const byFP = groupBy(norm, r => r.Floorplan || "(unknown)");
  const terms = (cfg && Array.isArray(cfg.renTerms) && cfg.renTerms.length)
    ? cfg.renTerms
    : (window.readRenTermsCompact ? window.readRenTermsCompact() : readRenTerms());
  const refTerm = Math.max.apply(null, terms);

  // occupied units with a lease-end date, oldest first
  const renewals = (norm||[])
    .filter(x => String(x.Status||"").toLowerCase().startsWith("occupied") && x.LeaseEnd)
    .sort((a,b)=> new Date(a.LeaseEnd) - new Date(b.LeaseEnd));

  // If no eligible renewals, show a friendly note instead of a blank panel
  if (!renewals.length){
    wrap.innerHTML = '<div class="note">No renewal candidates found for this dataset.</div>';
    return;
  }

    for (const r of renewals){
    const fp = r.Floorplan || "(unknown)";
    const fpList = byFP.get(fp) || [];
    const fpAvg = fpList.reduce((s,u)=> s + (u.CurrentRent||0), 0) / Math.max(1, fpList.length);
    const fpN = fpList.length;

    // trending + move direction
    const fpTrend   = tState.tFP[fp];
    const commTrend = tState.tComm;
    const dir = computeMoveSingleThreshold(cfg, fpTrend, commTrend, fpN);

    // === Baseline new anchored to Starting Rent (by code) ===
    const sr = Number((startingRentForCode(fp)) || 0);
    const anchor = (sr && sr > 0) ? sr : fpAvg;
    const baselineNew = anchor * (1 + dir);
    const curr = r.CurrentRent || 0;

    let trs = "";
    let _refRenewPrice = NaN;

    for (const term of terms){
      // Whether current is above today's baseline-new
      const isAboveNew = curr > baselineNew;

// --- RENEWALS: per-term computation (surgical patch) ---
// 1) Build base using existing renewalBase
const basePrice = renewalBase(curr, baselineNew, cfg, isAboveNew);
let basePct = (basePrice / Math.max(1, curr)) - 1;

// 2) Term premiums = short-term (2–9) + seasonality.
const end = new Date(); end.setMonth(end.getMonth() + term);
const key = end.getFullYear() + "-" + String(end.getMonth()+1).padStart(2, "0");

// Start from basePrice to compute the multiplicative term effects just like New
const baseAfterShort = shortTermAdj(basePrice, term); // if term>=10, it's unchanged
const shortTermPctDec = (baseAfterShort / Math.max(1, basePrice)) - 1; // decimal

const monthMult = seasonalityMultiplier(cfg.seasonalityCurve, key) || 1;
const seasonalityPctDec = (monthMult - 1); // decimal
const overCount = (overByKey && overByKey[key]) ? overByKey[key] : 0;

// Apply term effects multiplicatively to basePrice to get the raw term price
const rawTermPrice = baseAfterShort * monthMult;

// 3) Convert to final % vs current and apply guardrails policy
let pctFinal = (rawTermPrice / Math.max(1, curr)) - 1;
if (cfg.capAllTerms === true) {
  // Per-term MAX-only cap after premiums
  pctFinal = applyRenewalGuardrailMax(cfg, pctFinal, isAboveNew, cfg.allowDecAbove);
} else {
  // No per-term cap. If above-new and decreases are not allowed, prevent negative final pct.
  if (isAboveNew && !cfg.allowDecAbove) {
    pctFinal = Math.max(0, pctFinal);
  }
}

// Final offer (rounded)
const offer = Math.round(curr * (1 + pctFinal));

// --- Notes formatting (match New style). When guardrails OFF, omit "max-cap ..." ---
const pctToStr = v => `${(v*100).toFixed(1)}%`;
const parts = [];
parts.push(`term premium ${pctToStr(shortTermPctDec)}`);
if (overCount && seasonalityPctDec !== 0) {
  parts.push(`& over cap (${overCount}) ${pctToStr(Math.max(0, seasonalityPctDec))}`);
} else {
  parts.push(`& seasonality ${pctToStr(seasonalityPctDec)}`);
}
const termSumDec = shortTermPctDec + seasonalityPctDec;
const left = `${parts.join(' ')} = ${pctToStr(termSumDec)}`;
let note = left + ` → applied ${pctToStr(pctFinal)}`;
if (cfg.capAllTerms === true) {
  const maxCap = isAboveNew ? Math.abs(cfg.renAboveMax || 0) : Math.abs(cfg.renMax || 0);
  note = `${left} → max-cap ${pctToStr(maxCap)} → applied ${pctToStr(pctFinal)}`;
}

      trs += `<tr>
                <td>${term} mo</td>
                <td>${fmt(offer)}</td>
                <td style="text-align:right;opacity:.9"><small>${note}</small></td>
              </tr>`;

      // Include Starting Rent and Baseline New in export
      __renewalsRows.push([
        r.UnitID, fp, fmtDate(r.LeaseEnd), term,
        offer, Math.round(curr), Math.round(sr>0?sr:fpAvg), Math.round(baselineNew),
        Math.round((cfg.pctToNew||0)*100)+'%',
        (isAboveNew?cfg.renAboveMin:cfg.renMin), (isAboveNew?cfg.renAboveMax:cfg.renMax)
      ]);
    }

    // Footer debug: Current vs baseline-new, plus knobs and applied on reference term
  const appliedPct = (isFinite(_refRenewPrice) && curr>0) ? ((_refRenewPrice/curr - 1)*100) : NaN;
  const appliedTxt = isFinite(appliedPct) ? ((appliedPct>=0?'+':'−')+Math.abs(appliedPct).toFixed(1)+'%') : '—';
  const pctToNewTxt = Math.round((cfg.pctToNew||0)*100) + '%';
  const maxOnly = Math.max(0, (cfg.renMax||0), (cfg.renAboveMax||0));
  const maxTxt = maxOnly ? (Math.round(maxOnly*1000)/10).toFixed(1)+'%' : '—';
  const baseLine = (typeof buildRenewalBaseFormulaDebug==='function') ? buildRenewalBaseFormulaDebug(curr, baselineNew, cfg) : '';

    const footerDebug = `
      <div class="note" style="margin-top:6px;opacity:.9">
        Debug — Current ${fmt(curr)} • Starting Rent ${fmt(sr>0?sr:fpAvg)} • baseline-new ${fmt(baselineNew)}
        • pct-to-new: ${pctToNewTxt} • max: ${maxTxt} → applied ${appliedTxt}
        <br><span style="opacity:.85">${baseLine}</span>
      </div>`;

    wrap.insertAdjacentHTML("beforeend", `
      <div style="border:1px solid #0b2035;border-radius:10px;padding:10px;margin:8px 0">
        <div style="font-weight:600">Unit ${r.UnitID} — ${fp} — Lease End ${fmtDate(r.LeaseEnd)} — Current ${fmt(curr)}</div>
        <table class="basic" style="margin-top:6px">
          <thead><tr><th>Term</th><th>Offer</th><th style="text-align:right;">Notes</th></tr></thead>
          <tbody>${trs}</tbody>
        </table>
        ${footerDebug}
        ${explain([
          (curr >= baselineNew) ? "Above baseline-new" : "Below baseline-new",
          "Percent-to-new: " + Math.round((cfg.pctToNew||0)*100) + "%",
          cfg.capAllTerms ? "Guardrails: max only" : "Guardrails off"
        ])}
      </div>`);
  }
}


  // STEP 1: split run paths
  function canRun(){
    if(!mappedRows?.length){ alert("Upload & confirm mapping first."); return false; }
    if(window.applySeasonalityFromUI && !window.applySeasonalityFromUI()) return false;
    return true;
  }
  function computeState(){ if (typeof window._syncBandsFromTarget === 'function') window._syncBandsFromTarget(); const cfg = readCfg(); const tState = computeTrending(mappedRows); return {cfg,tState}; }

  $("runNew").addEventListener("click",()=>{
    if(!canRun()) return;
    $("flagList").innerHTML="";
    resetNewBuffers();
    renderSeasonality(mappedRows, __seasonalityNewRows);
    const {cfg,tState} = computeState();
    const fpPts = collectNewFloorplanPoints(cfg, mappedRows, tState);
    renderNewLease(cfg,mappedRows,tState);
    // Also render unit pricing after floorplan pricing is complete
    try{
      if (typeof window.__renderUnitPricingSection === 'function') {
        window.__renderUnitPricingSection();
      }
    }catch(e){ console.error('[RM] Error rendering unit pricing:', e); }
    // Also render Renewals so the tab is ready without manual refresh
    try{
      resetRenewBuffers();
      renderSeasonality(mappedRows, __seasonalityRenewRows);
      renderRenewals(cfg, mappedRows, tState);
    }catch(e){}
    setBadge("nlBadge","new", (__newPricingRows.length>0? (__newPricingRows.length-1):0));
    addHistory("new", cfg, tState, (__newPricingRows.length>0? (__newPricingRows.length-1):0), fpPts);
    enableExportNew(true);
    if (Array.isArray(window.mappedRows) && typeof window.__updateStatusFromMappedRows==='function'){
      window.__updateStatusFromMappedRows(window.mappedRows);
    }
  });

  $("runRenew").addEventListener("click",()=>{
    if(!canRun()) return;
    $("flagList").innerHTML="";
    resetRenewBuffers();
    renderSeasonality(mappedRows, __seasonalityRenewRows);
    const {cfg,tState} = computeState();
    renderRenewals(cfg,mappedRows,tState);
    setBadge("renBadge","renew", (__renewalsRows.length>0? (__renewalsRows.length-1):0));
    addHistory("renew", cfg, tState, (__renewalsRows.length>0? (__renewalsRows.length-1):0));
    enableExportRenew(true);
    if (Array.isArray(window.mappedRows) && typeof window.__updateStatusFromMappedRows==='function'){
      window.__updateStatusFromMappedRows(window.mappedRows);
    }
  });

  $("exportNew").addEventListener("click", exportNew);
  $("exportRenew").addEventListener("click", exportRenew);

})();

// --- Local History (scaffold) ---
let __history = []; // keep last 100 runs

function snapshotCfg(cfg){
  try{
    // shallow copy only of keys we care about
    const keys = ["comfortTarget","bandLow","bandHigh","convSensitivity","priceResponse","fpSensitivity","seasonalityCurve",
                  "allowDecAbove","capAllTerms","pctToNew","renMin","renMax","renAboveMin","renAboveMax",
                  "renTerms","nlTerms","changeCadence"];
    const out = {};
    keys.forEach(k => out[k] = Array.isArray(cfg[k]) ? [...cfg[k]] : cfg[k]);
    return out;
  }catch(e){ return {}; }
}

function addHistory(kind, cfg, tState, rowCount, fpPoints){
  const item = {
    ts: new Date().toISOString(),
    kind: kind,                    // "new" | "renew"
    rows: rowCount|0,
    cfg: snapshotCfg(cfg),
    t: {
      comm: (typeof tState?.tComm === "number" ? Math.round(tState.tComm*1000)/1000 : null),
      fps: tState && tState.tFP ? Object.keys(tState.tFP).length : null
    }
  };
  if(kind === 'new' && Array.isArray(fpPoints)) item.fpPoints = fpPoints;
  __history.unshift(item);
  if(__history.length > 100) __history = __history.slice(0,100);
  // Placeholder: future UI rendering goes here.
}

window.getHistory = () => __history.slice(); // read-only copy
window.clearHistory = () => { __history = []; };
</script>

<script>
(function(){
  const btn = document.getElementById('confirmMapping');
  const automap = document.getElementById('automap');
  if(btn && automap){
    btn.addEventListener('click', function(){
      automap.style.display = 'none';
      try { document.getElementById('file')?.scrollIntoView({behavior:'smooth'}); } catch(e){}
    });
  }
})();
</script>

<!-- Backfill hidden controls removed from UI to keep logic working -->
<div id="ui-backfill" style="display:none">
  <input type="checkbox" id="showDiscount">
  <input type="checkbox" id="floorBadge" checked>
  <select id="agedVacantPolicy">
    <option value="off" selected>Off</option>
  </select>
  <select id="strengthToMarket">
    <option value="standard" selected>Standard</option>
  </select>
</div>

<!-- Hidden backfill for removed control to keep logic intact -->
<div style="display:none">
  <select id="renewalAwareness">
    <option value="off">Off</option>
    <option value="standard" selected>Standard (60–90d)</option>
    <option value="strong">Strong (90–120d)</option>
  </select>
</div>

<!-- Hidden backfill to keep logic intact after removing the visible control -->
<div style="display:none">
  <input id="maxWeeklyDec" type="number" value="2">
</div>

<!-- Hidden backfill: always enforce review for ≥5% changes -->
<div style="display:none">
  <input id="reviewLarge" type="checkbox" checked>
</div>

<script>
(function(){
  const sel = document.getElementById('seasonalityCurve');
  const inputs = Array.from(document.querySelectorAll('#seasonalityGrid .month-input'));
  const totalEl = document.getElementById('seasonalityTotal');

  const PRESETS = {
    normal:    [4,4,7,9,11,12,12,11,9,7,6,8],
    minimal:   [8,8,8,8,8,9,9,9,9,8,8,8],
    aggressive:[5,5,6,7,9,10,12,11,10,8,8,9]
  };

  function fill(values){
    for(let i=0;i<12;i++){
      const v = (values && values[i] != null) ? Number(values[i]) : 0;
      const s = (Math.round(v*10)/10).toString();
      inputs[i].value = s;
      inputs[i].setAttribute('value', s);
      inputs[i].style.color = '#e5e7eb';
    }
    updateTotal();
  }

  function setReadOnly(ro){
    inputs.forEach(inp=>{
      inp.readOnly = !!ro;
      inp.style.opacity = ro ? 0.85 : 1;
    });
  }

  function readInputs(){
    return inputs.map(inp => parseFloat(inp.value||'0')||0);
  }

  function updateTotal(){
    const sum = readInputs().reduce((a,b)=>a+b,0);
    const rounded = Math.round(sum*10)/10;
    totalEl.textContent = rounded + '%';
    const ok = Math.abs(rounded - 100.0) < 0.05;
    totalEl.classList.toggle('bad', !ok);
    totalEl.classList.toggle('ok', ok);
    return ok;
  }

  function applyFromSelect(){
    const val = (sel && sel.value) ? sel.value : 'normal';
    if(val === 'custom'){
      const current = readInputs();
      const allZero = current.every(v => v === 0);
      if(allZero) fill(PRESETS.normal);
      setReadOnly(false);
    }else{
      fill(PRESETS[val] || PRESETS.normal);
      setReadOnly(true);
    }
  }

  window.applySeasonalityFromUI = function(){
    const val = (sel && sel.value) ? sel.value : 'normal';
    if(val === 'custom'){
      if(!updateTotal()){
        alert('Seasonality total must equal 100% for Custom.');
        return false;
      }
      const arr = readInputs().map(v => v/100);
      allowedPctByMonth = arr;
      try{ window.__seasonalityArray__ = arr.map(v => Math.min(1.20, Math.max(0.80, Number(v)||1))); }catch(e){}
      return true;
    }else{
      const arr = (PRESETS[val] || PRESETS.normal).map(v => v/100);
      allowedPctByMonth = arr;
      try{ window.__seasonalityArray__ = arr.map(v => Math.min(1.20, Math.max(0.80, Number(v)||1))); }catch(e){}
      return true;
    }
  };

  if(sel){ sel.addEventListener('change', applyFromSelect); }
  inputs.forEach(inp => inp.addEventListener('input', updateTotal));
  applyFromSelect();
  document.addEventListener("DOMContentLoaded", applyFromSelect);
})();
</script>

<script>
(function(){
  const btn = document.getElementById('nlDropdownBtn');
  const panel = document.getElementById('nlDropdownPanel');
  const list = document.getElementById('nlTermList');
  if(!btn || !panel || !list) return;

  function build(){
    list.innerHTML = "";
    for(let t=2;t<=24;t++){
      const id = "nl_opt_" + t;
      const checked = (t>=2 && t<=14) ? 'checked' : '';
      list.insertAdjacentHTML('beforeend', `
        <label style="display:flex; align-items:center; gap:6px;">
          <input type="checkbox" id="${id}" value="${t}" ${checked}>
          <span>${t}</span>
        </label>
      `);
    }
    updateBtnLabel();
  }

  function getSelected(){
    return Array.from(list.querySelectorAll('input:checked')).map(x => parseInt(x.value)).sort((a,b)=>a-b);
  }

  function setSelected(range){
    list.querySelectorAll('input').forEach(inp => {
      const v = parseInt(inp.value);
      inp.checked = range ? (v >= range[0] && v <= range[1]) : false;
    });
    updateBtnLabel();
  }

  function updateBtnLabel(){
    const sel = getSelected();
    if(sel.length === 0){ btn.textContent = "Select"; return; }
    let contiguous = true;
    for(let i=1;i<sel.length;i++){ if(sel[i] !== sel[i-1]+1){ contiguous=false; break; } }
    btn.textContent = contiguous ? `${sel[0]}–${sel[sel.length-1]}` : sel.slice(0,6).join(',') + (sel.length>6?'…':'');
  }

  window.readNLTerms = function(){
    return getSelected();
  };

  const btnAll = document.getElementById('nlAll');
  const btnNone = document.getElementById('nlNone');
  const btnDef = document.getElementById('nlDefault');
  if(btnAll) btnAll.addEventListener('click', ()=>{ setSelected([2,24]); });
  if(btnNone) btnNone.addEventListener('click', ()=>{ setSelected(null); });
  if(btnDef) btnDef.addEventListener('click', ()=>{ setSelected([2,14]); });

  function togglePanel(){ panel.style.display = (panel.style.display==='block') ? 'none' : 'block'; }
  btn.addEventListener('click', (e)=>{ e.stopPropagation(); togglePanel(); });
  document.addEventListener('click', ()=>{ panel.style.display = 'none'; });
  panel.addEventListener('click', (e)=> e.stopPropagation());

  list.addEventListener('change', updateBtnLabel);
  build();
})();
</script>

<script>
(function(){
  const btn = document.getElementById('renDropdownBtn');
  const panel = document.getElementById('renDropdownPanel');
  const list = document.getElementById('renTermList');
  if(!btn || !panel || !list) return;

  function build(){
    list.innerHTML = "";
    for(let t=2;t<=24;t++){
      const checked = (t>=2 && t<=14) ? 'checked' : '';
      list.insertAdjacentHTML('beforeend', `
        <label style="display:flex; align-items:center; gap:6px;">
          <input type="checkbox" value="${t}" ${checked}>
          <span>${t}</span>
        </label>
      `);
    }
    updateBtnLabel();
  }

  function getSelected(){
    return Array.from(list.querySelectorAll('input:checked')).map(x => parseInt(x.value)).sort((a,b)=>a-b);
  }

  function setSelected(range){
    list.querySelectorAll('input').forEach(inp => {
      const v = parseInt(inp.value);
      inp.checked = range ? (v >= range[0] && v <= range[1]) : false;
    });
    updateBtnLabel();
  }

  function updateBtnLabel(){
    const sel = getSelected();
    if(sel.length === 0){ btn.textContent = "Select"; return; }
    let contiguous = true;
    for(let i=1;i<sel.length;i++){ if(sel[i] !== sel[i-1]+1){ contiguous=false; break; } }
    btn.textContent = contiguous ? `${sel[0]}–${sel[sel.length-1]}` : sel.slice(0,6).join(',') + (sel.length>6?'…':'');
  }

  window.readRenTermsCompact = function(){
    const arr = getSelected();
    return arr.length ? arr : [2,3,4,5,6,7,8,9,10,11,12,13,14];
  };

  const btnAll = document.getElementById('renAll');
  const btnNone = document.getElementById('renNone');
  const btnDef = document.getElementById('renDefault');
  if(btnAll) btnAll.addEventListener('click', ()=>{ setSelected([2,24]); });
  if(btnNone) btnNone.addEventListener('click', ()=>{ setSelected(null); });
  if(btnDef) btnDef.addEventListener('click', ()=>{ setSelected([2,14]); });

  function togglePanel(){ panel.style.display = (panel.style.display==='block') ? 'none' : 'block'; }
  btn.addEventListener('click', (e)=>{ e.stopPropagation(); togglePanel(); });
  document.addEventListener('click', ()=>{ panel.style.display = 'none'; });
  panel.addEventListener('click', (e)=> e.stopPropagation());

  list.addEventListener('change', updateBtnLabel);
  build();
})();
</script>

<script>
(function(){
  if (typeof window.readRenTermsCompact === 'function') {
    window.readRenTerms = function(){ return window.readRenTermsCompact(); };
  }
})();
</script>


<script>
(function(){
  let fpChart, fpChartCtx;
  const sel = document.getElementById('fpHistorySelect');
  const lim = document.getElementById('fpHistoryLimit');

  function getAllFloorplansFromHistory(){
    try{
      const hist = (typeof window.getHistory === 'function') ? window.getHistory() : [];
      const set = new Set();
      for(const h of hist){
        if(h && h.kind === 'new' && Array.isArray(h.fpPoints)){
          for(const p of h.fpPoints){ if(p && p.fp) set.add(p.fp); }
        }
      }
      // Fallback to rent-roll snapshot if no history
      if (set.size===0 && window.__rrChartState && Array.isArray(window.__rrChartState.fpPoints)){
        window.__rrChartState.fpPoints.forEach(p=>{ if(p&&p.fp) set.add(p.fp); });
      }
      return Array.from(set).sort((a,b)=> a.localeCompare(b));
    }catch(e){ return []; }
  }

  function ensureSelectOptions(){
    if(!sel) return;
    const fps = getAllFloorplansFromHistory();
    const current = sel.value;
    sel.innerHTML = fps.map(fp => `<option value="${fp.replace(/"/g,'&quot;')}">${fp}</option>`).join("");
    // try to keep selection if still present
    if(current && fps.includes(current)) sel.value = current;
  }

  function buildSeries(fp, limitN){
    const hist = (typeof window.getHistory === 'function') ? window.getHistory() : [];
    const pts = [];
    for(const h of hist){
      if(h && h.kind === 'new' && Array.isArray(h.fpPoints)){
        const m = h.fpPoints.find(x => x.fp === fp);
        if(m){
          pts.push({ x: new Date(h.ts), y: m.price });
        }
      }
    }
    // reverse chronological -> chronological for plotting
    pts.reverse();
    if(limitN && limitN > 0 && pts.length > limitN){
      // take the last 'limitN' chronological points
      return pts.slice(pts.length - limitN);
    }
    // If no history points, fallback to a single snapshot from rent roll
    if (!pts.length && window.__rrChartState && Array.isArray(window.__rrChartState.fpPoints)){
      const snap = window.__rrChartState.fpPoints.find(x=>x.fp===fp);
      if (snap){ return [{ x: new Date(window.__rrChartState.ts), y: snap.price }]; }
    }
    return pts;
  }

  function renderChart(){
    if(!sel || !lim) return;
    const fp = sel.value;
    if(!fp){ return; }
    const n = Math.max(5, Math.min(100, parseInt(lim.value||'30',10)));
    const dataPts = buildSeries(fp, n);

    if(!fpChartCtx){
      fpChartCtx = document.getElementById('fpHistoryChart').getContext('2d');
    }
    if(fpChart){ fpChart.destroy(); }
    fpChart = new Chart(fpChartCtx, {
      type: 'line',
      data: {
        datasets: [{
          label: fp + " base price",
          parsing: false,
          data: dataPts,
          tension: 0.2
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, position: 'bottom' },
          tooltip: {
            callbacks: {
              label: (ctx)=> {
                const v = ctx.parsed.y;
                const d = ctx.parsed.x;
                try{
                  const ds = new Date(d).toLocaleString();
                  return `$${Math.round(v).toLocaleString()} — ${ds}`;
                }catch(e){ return `$${Math.round(v).toLocaleString()}`; }
              }
            }
          }
        },
        scales: {
          x: { type: 'time', time: { unit:'day' }, ticks:{ autoSkip:true } },
          y: { beginAtZero: false }
        }
      }
    });
  }

  window.refreshChartsFromRentRoll = function refreshChartsFromRentRoll(){
    try{
      const rows = Array.isArray(window.normRows) ? window.normRows : [];
      if (!rows.length) return;
      // Aggregate current rents by FP code/label
      const by = new Map();
      rows.forEach(r => {
        const code = String(r.FP_CODE || r.Floorplan || r.FloorplanLabel || '').trim();
        if (!code) return;
        const curr = Number(r.CurrentRent)||0;
        const acc = by.get(code) || {s:0,c:0};
        acc.s += curr; acc.c += 1; by.set(code, acc);
      });
      const fpPoints = Array.from(by.entries()).map(([fp,{s,c}])=>({ fp, price: (c? (s/c):0) }));
      if (!fpPoints.length) return;
      window.__rrChartState = { ts: new Date().toISOString(), fpPoints };
      // Update charts UI
      ensureSelectOptions(); renderChart();
      const note = document.getElementById('chartsSourceNote');
      if (note){ note.textContent = 'Charts last refreshed from rent roll • ' + new Date().toLocaleString(); }
    }catch(e){}
  };

  function refreshUI(){
    ensureSelectOptions();
    if(sel && !sel.value){
      const opts = sel.querySelectorAll('option');
      if(opts.length) sel.value = opts[0].value;
    }
    renderChart();
  }

  // Init on DOM ready
  document.addEventListener('DOMContentLoaded', refreshUI);

  // Re-render on selection change
  if(sel) sel.addEventListener('change', renderChart);
  if(lim) lim.addEventListener('input', renderChart);

  // Also refresh after each run by monkey-patching addHistory to trigger a small refresh.
  if(typeof window.addHistory === 'function'){
    const _addHistory = window.addHistory;
    window.addHistory = function(kind, cfg, tState, rowCount, fpPoints){
      const result = _addHistory.apply(this, arguments);
      // Only refresh if a new run occurred
      try { refreshUI(); } catch(e){}
      return result;
    };
  }
})();
</script>


<script>
(function(){
  const listEl = document.getElementById('historyList');
  const clearBtn = document.getElementById('clearHistoryBtn');

  function formatKind(k){ return k==='new' ? 'New' : (k==='renew' ? 'Renew' : String(k||'')); }
  function formatTs(s){ try{ return new Date(s).toLocaleString(); }catch(e){ return s; } }

  window.renderHistoryList = function(){
    if(!listEl) return;
    const hist = (typeof window.getHistory === 'function') ? window.getHistory() : [];
    if(!hist.length){
      listEl.innerHTML = '<em>No history yet. Run New or Renew to populate.</em>';
      return;
    }
    const rows = hist.map((h,i)=>{
      const parts = [
        `<strong>#${hist.length - i}</strong>`,
        `• ${formatKind(h.kind)}`,
        `• rows: ${h.rows||0}`,
        `• ${formatTs(h.ts)}`
      ];
      return `<div style="padding:4px 0; border-top:1px solid #0b2035">${parts.join(' ')}</div>`;
    }).join('');
    listEl.innerHTML = rows;
  };

  // Wire clear button
  if(clearBtn){
    clearBtn.addEventListener('click', ()=>{
      try{ window.clearHistory && window.clearHistory(); }catch(e){}
      window.renderHistoryList && window.renderHistoryList();
    });
  }

  // Initial render on DOM ready
  document.addEventListener('DOMContentLoaded', ()=>{
    window.renderHistoryList && window.renderHistoryList();
  });

  // Hook into addHistory so the list refreshes after each run
  if(typeof window.addHistory === 'function'){
    const _addHistory = window.addHistory;
    window.addHistory = function(kind, cfg, tState, rowCount, fpPoints){
      const r = _addHistory.apply(this, arguments);
      try{ window.renderHistoryList && window.renderHistoryList(); }catch(e){}
      return r;
    };
  }
})();
</script>


<script>
(function(){
  // Apply a settings snapshot to the UI without running pricing.
  function setVal(id, val){
    const el = document.getElementById(id);
    if(!el) return;
    if(el.type === 'checkbox'){
      el.checked = !!val;
    } else if(el.tagName === 'SELECT' || el.tagName === 'INPUT'){
      el.value = val;
    }
  }

  function setTermCheckboxes(listSelector, terms){
    try{
      const list = document.querySelectorAll(listSelector + ' input[type="checkbox"]');
      const set = new Set((terms||[]).map(Number));
      list.forEach(inp => { inp.checked = set.has(parseInt(inp.value,10)); });
    }catch(e){}
  }

  function setNLButtonLabel(){
    const btn = document.getElementById('nlDropdownBtn');
    const sel = Array.from(document.querySelectorAll('#nlTermList input:checked')).map(x=>parseInt(x.value,10)).sort((a,b)=>a-b);
    if(!btn) return;
    if(sel.length===0){ btn.textContent = "Select"; return; }
    let contiguous = true;
    for(let i=1;i<sel.length;i++){ if(sel[i] !== sel[i-1]+1){ contiguous=false; break; } }
    btn.textContent = contiguous ? `${sel[0]}–${sel[sel.length-1]}` : sel.slice(0,6).join(',') + (sel.length>6?'…':'');
  }

  function setRenButtonLabel(){
    const btn = document.getElementById('renDropdownBtn');
    const sel = Array.from(document.querySelectorAll('#renTermList input:checked')).map(x=>parseInt(x.value,10)).sort((a,b)=>a-b);
    if(!btn) return;
    if(sel.length===0){ btn.textContent = "Select"; return; }
    let contiguous = true;
    for(let i=1;i<sel.length;i++){ if(sel[i] !== sel[i-1]+1){ contiguous=false; break; } }
    btn.textContent = contiguous ? `${sel[0]}–${sel[sel.length-1]}` : sel.slice(0,6).join(',') + (sel.length>6?'…':'');
  }

  window.applyCfgSnapshot = function(cfg){
    if(!cfg) return;
    try{
      // Strategy
      if(typeof cfg.comfortTarget === 'number') setVal('comfortTarget', Math.round(cfg.comfortTarget*1000)/10);
      else {
        if (typeof cfg.bandLow === 'number' && typeof cfg.bandHigh === 'number'){
          var mid = (cfg.bandLow + cfg.bandHigh)/2;
          if (isFinite(mid)) setVal('comfortTarget', Math.round(mid*1000)/10);
        }
      }
      if (typeof window._syncBandsFromTarget === 'function') window._syncBandsFromTarget();
      if(cfg.convSensitivity) setVal('convSensitivity', cfg.convSensitivity);
      if(cfg.priceResponse) setVal('priceResponse', cfg.priceResponse);

      // Seasonality preset only (values already handled by existing logic upon change)
      if(cfg.seasonalityCurve) {
        setVal('seasonalityCurve', cfg.seasonalityCurve);
        // trigger preset application if helper exists
        try{ window.applySeasonalityFromUI && window.applySeasonalityFromUI(); }catch(e){}
      }

      // Renewals
      setVal('allowDecAbove', !!cfg.allowDecAbove);
      setVal('capAllTerms', !!cfg.capAllTerms);
      if(typeof cfg.pctToNew === 'number') setVal('pctToNew', Math.round(cfg.pctToNew*100));
      if(typeof cfg.renMin === 'number') setVal('renMin', Math.round(cfg.renMin*100));
      if(typeof cfg.renMax === 'number') setVal('renMax', Math.round(cfg.renMax*100));
      if(typeof cfg.renAboveMin === 'number') setVal('renAboveMin', Math.round(cfg.renAboveMin*100));
      if(typeof cfg.renAboveMax === 'number') setVal('renAboveMax', Math.round(cfg.renAboveMax*100));

      // Terms
      if(Array.isArray(cfg.nlTerms)) { setTermCheckboxes('#nlTermList', cfg.nlTerms); setNLButtonLabel(); }
      if(Array.isArray(cfg.renTerms)) { setTermCheckboxes('#renTermList', cfg.renTerms); setRenButtonLabel(); }

      // Safety
      if(cfg.changeCadence) setVal('changeCadence', cfg.changeCadence);

      // Visual feedback
      try{
        const el = document.createElement('div');
        el.className = 'note';
        el.textContent = 'Settings restored from history. Review and click Run when ready.';
        const parent = document.querySelector('.panel .card'); // first card
        if(parent) parent.prepend(el);
        setTimeout(()=>{ if(el && el.parentNode) el.parentNode.removeChild(el); }, 3000);
      }catch(e){}
    }catch(e){ console.error('applyCfgSnapshot error', e); }
  };

  // Extend history list to include "Restore" link per row
  if(typeof window.renderHistoryList === 'function'){
    const _render = window.renderHistoryList;
    window.renderHistoryList = function(){
      _render();
      const listEl = document.getElementById('historyList');
      if(!listEl) return;
      const hist = (typeof window.getHistory === 'function') ? window.getHistory() : [];
      const items = listEl.querySelectorAll('div[data-hrow]');
      if(items.length){ return; } // already enhanced
      // Rebuild with restore links
      if(!hist.length){
        listEl.innerHTML = '<em>No history yet. Run New or Renew to populate.</em>';
        return;
      }
      const rows = hist.map((h,i)=>{
        const idx = i;
        const kind = h.kind==='new' ? 'New' : (h.kind==='renew' ? 'Renew' : String(h.kind||''));
        const stamp = (function(s){ try{ return new Date(s).toLocaleString(); }catch(e){ return s; } })(h.ts);
        return `<div data-hrow="${idx}" style="padding:4px 0; border-top:1px solid #0b2035">
          <strong>#${hist.length - i}</strong> • ${kind} • rows: ${h.rows||0} • ${stamp}
          <a href="#" data-restore="${idx}" style="margin-left:8px; color:#22d3ee; text-decoration:underline;">Restore</a>
        </div>`;
      }).join('');
      listEl.innerHTML = rows;

      listEl.addEventListener('click', (e)=>{
        const a = e.target.closest('a[data-restore]');
        if(!a) return;
        e.preventDefault();
        const idx = parseInt(a.getAttribute('data-restore'),10);
        const hist2 = (typeof window.getHistory === 'function') ? window.getHistory() : [];
        const item = hist2[idx];
        if(item && item.cfg){ window.applyCfgSnapshot(item.cfg); }
      });
    };
  }
})();
</script>


<script>
(function(){
  function inHorizon(dt){
    const horizonMs = 120*86400000, now = Date.now();
    const d = new Date(dt);
    if (isNaN(d)) return false;
    const diff = d.getTime() - now;
    return diff >= 0 && diff <= horizonMs;
  }
  
  
function calcCounts(list){
  const N = list.length;
  const status = (s)=> String(s||'').toLowerCase();
  const isVac = (s)=> status(s).includes('vacant');          // 'vacant unrented', 'vacant rented', etc.
  const isNotice = (s)=> status(s).includes('notice');       // 'occupied (on-notice)', variants
  const isOccLike = (s)=> status(s).startsWith('occupied') || status(s).includes('notice');

  const occ = list.filter(r=> isOccLike(r.Status)).length;
  const vac = list.filter(r=> isVac(r.Status)).length;
  const notices = list.filter(r=> isNotice(r.Status)).length;
  const preRaw = list.filter(r=> r.PreleaseStart).length;
  const pre = Math.min(preRaw, vac + notices); // cannot replace more than pending move-outs
  const occPct = N ? (occ / N) : 0;

  // Projected/Trend if no more leases happen and all notices move out:
  // projected = 1 - ((Vacant + Notices - Prelease) / N)
  let projected = N ? (1 - ((vac + notices - pre) / N)) : 0;
  projected = Math.max(0, Math.min(1, projected)); // clamp to [0,1]

  return { N, vac, notices, pre, occ, occPct, projected };
}
function
 healthFrom(projected, occPct){
    // Simple gut-check thresholds (adjustable later)
    // Healthy: trending >= 96% or occ >= 96%
    // Watch: 93% <= trending < 96% (or occ in same band)
    // Risk: trending < 93% (or occ < 93%)
    const t = (projected||0)*100, o = (occPct||0)*100;
    if (t >= 96 || o >= 96) return {label:"Healthy", cls:"health-ok"};
    if (t >= 93 && t < 96) return {label:"Watch", cls:"health-watch"};
    return {label:"Soft", cls:"health-risk"};
  }
  function fmtPct(v){ return (isNaN(v)? '—' : (Math.round(v*1000)/10)+'%'); }
  function fmtInt(v){ return (isNaN(v)? '—' : String(v)); }

  function renderBoxScore(norm){

    const body = document.getElementById('boxScoreBody');
    const summary = document.getElementById('boxScoreSummary');
    if(!body){ return; }
    if(!Array.isArray(norm) || !norm.length){
      body.innerHTML = '<tr><td colspan="8" class="note">No data. Upload & confirm mapping, then run.</td></tr>';
      if(summary) summary.innerHTML = '';
      return;
    }
    // Community row
    const comm = calcCounts(norm);
    const h = healthFrom(comm.projected, comm.occPct);
    if(summary){
      summary.innerHTML = `
        <div class="health-chip ${h.cls}">
          <strong>Community</strong>
          <span>• Units: ${fmtInt(comm.N)}</span>
          <span>• Occ: ${fmtPct(comm.occPct)}</span>
          <span>• Trending: ${fmtPct(comm.projected)}</span>
          <span>• Notices: ${fmtInt(comm.notices)}</span>
          <span>• Preleases: ${fmtInt(comm.pre)}</span>
        </div>`;
    }

    let rows = '';
    // Floorplan rows
    const byFP = (function groupBy(arr,fn){ const m=new Map(); for(const x of arr){ const k=fn(x); m.set(k,(m.get(k)||[]).concat([x])); } return m; })(norm, r=>r.Floorplan||"(unknown)");
    const fps = Array.from(byFP.keys()).sort((a,b)=>a.localeCompare(b));
    for(const fp of fps){
      const list = byFP.get(fp)||[];
      const s = calcCounts(list);
      rows += `<tr>
        <td>${fp}</td>
        <td>${fmtInt(s.N)}</td>
        <td>${fmtInt(s.vac)}</td>
        <td>${fmtInt(s.notices)}</td>
        <td>${fmtInt(s.pre)}</td>
        <td>${fmtInt(s.occ)}</td>
        <td>${fmtPct(s.occPct)}</td>
        <td>${fmtPct(s.projected)}</td>
      </tr>`;
    }
    
    // Build totals footer (community metrics)
    const foot = document.getElementById('boxScoreFoot');
    if(foot){
      const totals = calcCounts(norm);
      foot.innerHTML = `<tr style="background:#0b1220; font-weight:600; border-top:2px solid #0b2035">
        <td style="text-align:left">Totals</td>
        <td>${fmtInt(totals.N)}</td>
        <td>${fmtInt(totals.vac)}</td>
        <td>${fmtInt(totals.notices)}</td>
        <td>${fmtInt(totals.pre)}</td>
        <td>${fmtInt(totals.occ)}</td>
        <td>${fmtPct(totals.occPct)}</td>
        <td>${fmtPct(totals.projected)}</td>
      </tr>`;
    }
    body.innerHTML = rows;
  }

  // Hook into run flows: refresh box score after each Run New / Run Renew
  const _runNewBtn = document.getElementById('runNew');
  const _runRenBtn = document.getElementById('runRenew');
  function refreshAfterRun(){ try{ renderBoxScore(window.mappedRows || []); }catch(e){} }
  if(_runNewBtn){ _runNewBtn.addEventListener('click', ()=>{ Promise.resolve().then(refreshAfterRun); }); }
  if(_runRenBtn){ _runRenBtn.addEventListener('click', ()=>{ Promise.resolve().then(refreshAfterRun); }); }

  // Expose for manual refresh
  window.renderBoxScore = renderBoxScore;
})();
</script>


<script>
(function(){
  function cardFromHeading(h2){
    // walk up to the enclosing .card
    let el = h2;
    while(el && !el.classList.contains('card')) el = el.parentElement;
    return el;
  }
  function computeCards(){
    const map = { home:[], settings:[], newPricing:[], renewals:[], charts:[], history:[] };
    document.querySelectorAll('h2[data-tab-scope]').forEach(h2=>{
      const scopes = (h2.getAttribute('data-tab-scope')||'').split(/\s+/).filter(Boolean);
      const card = cardFromHeading(h2);
      if(!card) return;
      scopes.forEach(sc=>{ if(map[sc]) map[sc].push(card); });
    });
    return map;
  }
  const tabMap = computeCards();
  
  function setTab(tab){
    // buttons
    document.querySelectorAll('#tabBar [data-tab]').forEach(b=> b.classList.toggle('active', b.getAttribute('data-tab')===tab));
    // hide all cards first
    document.querySelectorAll('.card').forEach(c=> c.classList.add('tab-hidden'));
    // show those mapped to tab
    const list = tabMap[tab] || [];
    list.forEach(c=> c.classList.remove('tab-hidden'));
    window._activeTab = tab;
    
    // If New Pricing tab is selected, ensure Floorplan Pricing is the default sub-tab
    if(tab==='newPricing'){
      try{
        if(typeof setNPSubtab === 'function' && typeof applyNPSubtabUI === 'function'){
          setNPSubtab('fp');
          applyNPSubtabUI('fp');
        }
      }catch(e){}
    }
    
    // If History tab, trigger a gentle refresh on history UI (chart + list) if present
    if(tab==='history'){
      try{
        const sel = document.getElementById('fpHistorySelect');
        if(sel){
          // ensure at least one option is selected, then fire change
          if(!sel.value && sel.options && sel.options.length){ sel.value = sel.options[0].value; }
          sel.dispatchEvent(new Event('change', {bubbles:true}));
        }
        if(window.renderHistoryList) window.renderHistoryList();
      }catch(e){}
    }
  }

  // Wire clicks
  document.querySelectorAll('#tabBar [data-tab]').forEach(btn=>{
    btn.addEventListener('click', ()=> setTab(btn.getAttribute('data-tab')));
  });
  // Default tab
  setTab('settings');
  // Expose for console
  window.setTab = setTab;
})();
</script>



<script>
(function(){
  function monthKey(dt){
    const d = new Date(dt);
    if (isNaN(d)) return null;
    return d.getFullYear() + "-" + String(d.getMonth()+1).padStart(2,"0");
  }
  function monthLabelFromKey(k){
    try{
      const [y,m] = k.split("-").map(Number);
      const d = new Date(y, m-1, 1);
      return d.toLocaleString(undefined, { month: "short", year: "numeric" });
    }catch(e){ return k; }
  }
  function nextFiveMonthKeys(){
    const start = new Date();
    start.setDate(1);
    const keys = [];
    for (let i=0;i<5;i++){
      const d = new Date(start);
      d.setMonth(d.getMonth()+i);
      keys.push(d.getFullYear()+"-"+String(d.getMonth()+1).padStart(2,"0"));
    }
    return keys;
  }
  function isNoticeStatus(s){ const v = String(s||"").toLowerCase(); return v.includes("notice"); }
  function isOccupiedLike(s){ const v = String(s||"").toLowerCase(); return v.startsWith("occupied") || v.includes("notice"); }
  function computeMTMTotal(rows){
    const now = Date.now();
    let total = 0;
    for(const r of (rows||[])){
      const s = String(r.Status||"").toLowerCase();
      const isOcc = isOccupiedLike(s);
      const isMTMExplicit = s.includes("mtm") || s.includes("month-to-month") || s.includes("month to month");
      const d = new Date(r.LeaseEnd||"");
      const past = !isNaN(d) && (d.getTime() < now);
      if (isOcc && (isMTMExplicit || past)) total++;
    }
    return total;
  }
  function collectRenewedByMonth(){
    // Proxy: "Renewed" = units for which offers were generated in the latest Renewals run.
    // We dedupe by UnitID per month of LeaseEnd.
    const out = {}; // monthKey -> Set(unitId)
    try{
      if (!Array.isArray(window.__renewalsRows) || window.__renewalsRows.length <= 1) return out;
      for (let i=1;i<window.__renewalsRows.length;i++){
        const row = window.__renewalsRows[i];
        const unit = String(row[0]);
        const leaseEnd = row[2];
        const k = monthKey(leaseEnd);
        if (!k) continue;
        if (!out[k]) out[k] = new Set();
        out[k].add(unit);
      }
    }catch(e){}
    return out;
  }

  function renderRenewalSummary(rows){
    const body = document.getElementById('renewalSummaryBody');
    const mtmEl = document.getElementById('mtmSummary');
    if (!body) return;
    if (!Array.isArray(rows) || !rows.length){
      body.innerHTML = '<tr><td colspan="6" class="note">No data. Upload & confirm mapping, then run.</td></tr>';
      if (mtmEl) mtmEl.textContent = '';
      return;
    }

    const keys = nextFiveMonthKeys();
    const counts = {}; // k -> { total, notice, renewed, undecided, conv }
    keys.forEach(k => counts[k] = { total:0, notice:0, renewed:0, undecided:0, conv:"—" });

    const renewedMap = collectRenewedByMonth();

    // Tally expirations and notice
    for(const r of rows){
      const k = monthKey(r.LeaseEnd);
      if (!k || !counts[k]) continue;
      counts[k].total += 1;
      if (isNoticeStatus(r.Status)) counts[k].notice += 1;
    }

    // Renewed (offers sent) per month
    for(const k of keys){
      const set = renewedMap[k];
      counts[k].renewed = set ? set.size : 0;
    }

    // Undecided and conversion
    for(const k of keys){
      const c = counts[k];
      c.undecided = Math.max(0, c.total - c.notice - c.renewed);
      const denom = (c.total - c.notice);
      if (denom > 0){
        const pct = Math.round((c.renewed / denom) * 100);
        c.conv = String(pct) + '%';
      } else {
        c.conv = '—';
      }
    }

    const trs = keys.map(k => {
      const c = counts[k];
      return `<tr>
        <td>${monthLabelFromKey(k)}</td>
        <td>${c.total}</td>
        <td>${c.notice}</td>
        <td>${c.renewed}</td>
        <td>${c.undecided}</td>
        <td>${c.conv}</td>
      </tr>`;
    }).join('');

    body.innerHTML = trs || '<tr><td colspan="6" class="note">No expirations found in the next five months.</td></tr>';

    if (mtmEl){
      const mtm = computeMTMTotal(rows);
      mtmEl.textContent = "Month-to-month units (estimated): " + mtm + " • Note: 'Renewed' reflects offers generated in the app.";
    }
  }

  // Hook into flows
  function refresh(){ try{ renderRenewalSummary(window.mappedRows || []); }catch(e){} }

  (function wire(){
    const btnNew = document.getElementById('runNew');
    const btnRen = document.getElementById('runRenew');
    if (btnNew) btnNew.addEventListener('click', ()=>{ Promise.resolve().then(refresh); });
    if (btnRen) btnRen.addEventListener('click', ()=>{ Promise.resolve().then(refresh); });
    const confirm = document.getElementById('confirmMapping');
    if (confirm) confirm.addEventListener('click', ()=>{ setTimeout(refresh, 50); });
    document.addEventListener('DOMContentLoaded', ()=>{ refresh(); });
  })();
})();
</script>


<script>
(function(){
  function cardFromHeading(h2){
    let el = h2;
    while (el && !el.classList.contains('card')) el = el.parentElement;
    return el;
  }
  document.addEventListener('DOMContentLoaded', function(){
    // Mark all Settings cards
    document.querySelectorAll('h2[data-tab-scope*="settings"]').forEach(h2 => {
      const card = cardFromHeading(h2);
      if (card) card.classList.add('settings-card');
    });
    // Reflow Strategy top row: move New Lease Terms dropdown to a third column
    try{
      const h2s = Array.from(document.querySelectorAll('h2[data-tab-scope="settings"]'));
      const strategyH2 = h2s.find(h => h.textContent.trim() === 'Strategy');
      if (strategyH2) {
        const card = cardFromHeading(strategyH2);
        const row = card ? card.querySelector('.row') : null;
        if (row) {
          row.classList.add('strategy-row');
          // Find the inline-compact NL terms block currently under High input
          const nlBlock = card.querySelector('.inline-compact');
          if (nlBlock && nlBlock.parentElement && nlBlock.parentElement !== row) {
            // Move it to be the third grid column
            row.appendChild(nlBlock);
            // Tidy its spacing
            nlBlock.style.marginTop = '0';
            nlBlock.style.justifyContent = 'flex-end';
          }
        }
      }
    }catch(e){}
  });
})();
</script>


<script>
(function(){
  function gotoTab(name){
    const btn = document.querySelector('#tabBar [data-tab="'+name+'"]');
    if (btn) btn.click();
  }
  function clickIf(id){ const el=document.getElementById(id); if(el) el.click(); }
  function wire(){
    // Set active tab on body
    document.addEventListener('click', function(e){
      const t = e.target.closest('#tabBar [data-tab]');
      if (t) document.body.dataset.activeTab = t.getAttribute('data-tab');
    });
    const active = document.querySelector('#tabBar .active[data-tab]');
    if (active) document.body.dataset.activeTab = active.getAttribute('data-tab');

    // Home buttons that call existing controls
    const map = {
      homeRunNew:    'runNew',
      homeExportNew: 'exportNew',
      homeRunRenew:  'runRenew',
      homeExportRenew: 'exportRenew'
    };
    Object.keys(map).forEach(hid=>{
      const targetId = map[hid];
      const hb = document.getElementById(hid);
      if (hb){
        hb.addEventListener('click', ()=> clickIf(targetId));
      }
    });

    // View links
    document.querySelectorAll('[data-goto]').forEach(el=>{
      el.addEventListener('click', ()=> gotoTab(el.getAttribute('data-goto')));
    });
  }
  document.addEventListener('DOMContentLoaded', wire);
})();
</script>



<script>
(function(){
  function setTabDisabled(tab, disabled){
    const b = document.querySelector('#tabBar [data-tab="'+tab+'"]');
    if (!b) return;
    b.classList.toggle('disabled', !!disabled);
  }
  function enableNew(){ setTabDisabled('newPricing', false); }
  function enableRenew(){ setTabDisabled('renewals', false); }
  function wireLocks(){
    // Disable on load
    setTabDisabled('newPricing', true);
    setTabDisabled('renewals', true);
    // Intercept clicks on disabled tabs (allow hover for tooltip)
    const bar = document.getElementById('tabBar');
    if (bar){
      bar.addEventListener('click', function(e){
        const t = e.target.closest('[data-tab]');
        if (t && t.classList.contains('disabled')){
          e.preventDefault();
          e.stopPropagation();
          t.classList.add('wiggle');
          setTimeout(()=>t.classList.remove('wiggle'), 200);
        }
      }, true);
    }
    // If user clicks underlying (hidden) buttons anywhere, unlock
    const rn = document.getElementById('runNew');
    const rr = document.getElementById('runRenew');
    if (rn) rn.addEventListener('click', enableNew);
    if (rr) rr.addEventListener('click', enableRenew);
    // Also unlock when Home buttons are used
    const hrn = document.getElementById('homeRunNew');
    const hrr = document.getElementById('homeRunRenew');
    if (hrn) hrn.addEventListener('click', enableNew);
    if (hrr) hrr.addEventListener('click', enableRenew);
  }
  document.addEventListener('DOMContentLoaded', wireLocks);
})();
</script>



<script>
(function(){
  const LS_KEY = 'rm_lastUpload'; // value: JSON {name,time}
  function fmtTime(ts){ try{ return new Date(ts).toLocaleString(); } catch(e){ return '—'; } }
  function setDataAsOf(name, time){
    const chip = document.getElementById('homeDataAsOf');
    if (!chip) return;
    if (time){
      chip.textContent = 'Data as of ' + fmtTime(time) + (name ? (' • ' + name) : '');
    }else{
      chip.textContent = 'Data as of —';
    }
  }
  function saveLastUpload(name, time){
    try{ localStorage.setItem(LS_KEY, JSON.stringify({name, time})); }catch(e){}
    setDataAsOf(name, time);
  }
  function loadLastUpload(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      const {name, time} = JSON.parse(raw);
      if (time) setDataAsOf(name, time);
    }catch(e){}
  }

  function computeStatus(){
    const rows = Array.isArray(window.mappedRows) ? window.mappedRows : [];
    const now = Date.now();
    const in30 = now + 30*86400000;
    let occ=0, total=0, exp30=0, undecided=0, vacant=0, notice=0, prelease=0;

    // capture renewed/offered-set from latest renewals run if available
    const renewedSet = new Set();
    try{
      if (Array.isArray(window.__renewalsRows) && window.__renewalsRows.length>1){
        for(let i=1;i<window.__renewalsRows.length;i++){ renewedSet.add(String(window.__renewalsRows[i][0])); }
      }
    }catch(e){}

    for(const r of rows){
      const s = String(r.Status||'').toLowerCase();
      // Prelease detection: any parseable future date or truthy flag
      const p = r.PreleaseStart || r.PreleaseDate || r.Prelease || r.Preleased;
      if (p){
        const pt = new Date(p).getTime();
        if (!isNaN(pt)) { if (pt >= now) prelease++; } else { prelease++; }
      }
      const isOcc = (s==='occupied' || s.startsWith('notice'));
      if (isOcc) occ++;
      total++;
      const t = new Date(r.LeaseEnd||'').getTime();
      if (!isNaN(t) && t>=now && t<=in30){
        exp30++;
        const isNotice = s.startsWith('notice');
        const unit = String(r.Unit||r.UnitID||'');
        const isRenewed = unit && renewedSet.has(unit);
        if (!isNotice && !isRenewed) undecided++;
      }
    }
    const occPct = total? Math.round((occ/total)*1000)/10 : null; // one decimal
    // Trending = 100 - ((Vacant + Notice - Prelease) / Total)*100
    const rawTrend = total? 100 - ((vacant + notice - prelease) * 100 / total) : null;
    const trendPct = (rawTrend==null) ? null : Math.max(0, Math.min(100, Math.round(rawTrend*10)/10));
    let badgeClass=''; let badgeText='—';
    if (occPct!=null){
      const low = parseFloat(document.getElementById('comfortLow')?.value || '93');
      if (occPct >= Math.max(93, low)) { badgeClass='ok'; }
      else if (occPct >= low-3) { badgeClass='warn'; }
      else { badgeClass='bad'; }
      badgeText = occPct.toFixed(1) + '%';
    }
    const badge = document.getElementById('homeOccBadge');
    if (badge){
      badge.classList.remove('ok','warn','bad');
      // update trend badge similarly
      const tBadge = document.getElementById('homeTrendBadge');
      if (tBadge){
        tBadge.classList.remove('ok','warn','bad');
        if (trendPct!=null){
          let tClass='';
          const lowT = parseFloat(document.getElementById('comfortLow')?.value || '93');
          if (trendPct >= Math.max(93, lowT)) tClass='ok';
          else if (trendPct >= lowT-3) tClass='warn';
          else tClass='bad';
          if (tClass) tBadge.classList.add(tClass);
          tBadge.textContent = trendPct.toFixed(1) + '%';
        } else {
          tBadge.textContent = '—';
        }
      }
      if (badgeClass) badge.classList.add(badgeClass);
      badge.textContent = badgeText;
    }
    const occMeta = document.getElementById('homeOccMeta');
    if (occMeta) occMeta.textContent = total? ('Based on '+total+' units • Occupied-like: '+occ) : 'Upload to compute.';

    const renText = (exp30||exp30===0) ? (undecided+' undecided of '+exp30+' expiring') : '—';
    const renEl = document.getElementById('homeRen30');
    if (renEl) renEl.textContent = renText;
    const renMeta = document.getElementById('homeRen30Meta');
    if (renMeta) renMeta.textContent = (exp30? 'Next 30 days' : '—');

    // Alerts
    const alerts = [];
    const low = parseFloat(document.getElementById('comfortLow')?.value || '93');
    if (occPct!=null && occPct < low) alerts.push('Occupancy below comfort ('+low+'%)');
    if (undecided>0) alerts.push(undecided+' renewals undecided in 30d');
    const a = document.getElementById('homeAlertsMeta');
    if (a) a.textContent = alerts.length? alerts.join(' • ') : 'No alerts.';
  }

  function wire(){
    // Load last upload from localStorage
    loadLastUpload();

    // Capture uploads globally
    document.addEventListener('change', function(e){
      const t = e.target;
      if (t && t.type==='file' && t.files && t.files[0]){
        saveLastUpload(t.files[0].name, Date.now());
        // compute soon (after mapping confirmation user can recalc again)
        setTimeout(computeStatus, 300);
      }
    }, true);

    // Recompute after mapping confirmation if present
    const cm = document.getElementById('confirmMapping');
    if (cm){
      cm.addEventListener('click', function(){ setTimeout(computeStatus, 500); });
    }

    // Also recompute after Renewals or New runs (ids may exist)
    ['runNew','runRenew'].forEach(id=>{
      const b = document.getElementById(id);
      if (b) b.addEventListener('click', ()=> setTimeout(computeStatus, 600));
    });

    // Initial compute if data already loaded
    setTimeout(computeStatus, 500);
  }
  document.addEventListener('DOMContentLoaded', wire);
})();
</script>


<script>
document.addEventListener('DOMContentLoaded', function(){
  // Make Home the landing tab
  const homeBtn = document.querySelector('#tabBar [data-tab="home"]');
  if (homeBtn) { homeBtn.click(); }
});
</script>

<script>
(function(){
  function clamp01(x){ return Math.max(0, Math.min(1, Number.isFinite(x)?x:0)); }
  function pct(x, d=1){ return (clamp01(x)*100).toFixed(d)+'%'; }
  function pp(x, d=1){ return (Number(x)||0).toFixed(d)+' pp'; }
  function setText(root, sel, v){ const el = root.querySelector(sel); if(el) el.textContent = v; }
  function classAs(el, cls){ if(!el) return; el.classList.remove('green','red','amber','neutral'); el.classList.add(cls); }

  function buildStatusSummarySafe(){
    var cfg = (typeof readCfg==='function') ? readCfg() : {};
    var totalUnits   = window.totalUnits   ?? cfg.totalUnits   ?? 0;
    var occupiedNow  = window.occupiedNow  ?? cfg.occupiedNow  ?? 0;
    var onNotice     = window.onNotice     ?? cfg.onNotice     ?? 0;
    var preleased    = window.preleased    ?? cfg.preleased    ?? 0;

    var targetOcc    = (typeof cfg.comfortTarget==='number') ? cfg.comfortTarget : (cfg.targetOcc ?? 0.95);
    var todayOcc     = totalUnits>0 ? (occupiedNow/totalUnits) : 0;

    var undecided30d = window.undecidedRenewals30d ?? cfg.undecidedRenewals30d ?? 0;
    var expiring30d  = window.expiring30d ?? cfg.expiring30d ?? 0;

    var approvals7d  = window.approvals7d ?? cfg.approvals7d ?? 0;
    var convToMoveIn = (typeof cfg.convToMoveIn==='number') ? cfg.convToMoveIn : 0.82;

    var strugglingFPs = Array.isArray(window.strugglingFPs) ? window.strugglingFPs : (cfg.strugglingFPs || []);
    var staleUnits    = Array.isArray(window.staleUnits30d) ? window.staleUnits30d : (cfg.staleUnits30d || []);

    var trendingOcc = totalUnits>0 ? ((occupiedNow + preleased - onNotice) / totalUnits) : 0;
    trendingOcc = clamp01(trendingOcc);

    var gapPP = (targetOcc - trendingOcc) * 100;
    var homesNeeded = (gapPP>0 && totalUnits>0) ? Math.ceil(totalUnits * gapPP / 100) : 0;

    var pacingPP = totalUnits>0 ? (approvals7d * convToMoveIn * (30/7) / totalUnits * 100) : 0;

    return {
      totalUnits, occupiedNow, onNotice, preleased,
      trendingOcc, todayOcc, targetOcc,
      gapPP, homesNeeded,
      undecided30d, expiring30d,
      approvals7d, convToMoveIn, pacingPP,
      strugglingFPs, staleUnits
    };
  }

  function paintStatus45(){
    var root = document.getElementById('status45-card');
    if(!root) return;
    var s = buildStatusSummarySafe();

    setText(root,'[data-kpi="trendingOcc"]', pct(s.trendingOcc, 2));
    setText(root,'[data-kpi="todayOcc"]', pct(s.todayOcc, 1));
    setText(root,'[data-kpi="targetOcc"]', pct(s.targetOcc, 0));
    classAs(document.getElementById('kpi_trending_occ'), (s.trendingOcc >= s.targetOcc) ? 'green' : 'red');

    setText(root,'[data-kpi="gapPP"]', __signedPctVal(s.gapPP, 1));
    setText(root,'[data-kpi="homesNeeded"]', String(s.homesNeeded));
    classAs(document.getElementById('kpi_pacing_gap'), (s.gapPP <= 0) ? 'green' : 'red');

    setText(root,'#kpi_undecided_30d [data-kpi="undecided30d"]', String(s.undecided30d));
    setText(root,'#kpi_undecided_30d [data-kpi="expiring30d"]', String(s.expiring30d));
    var undecRate = (s.expiring30d>0) ? (s.undecided30d/s.expiring30d) : 0;
    classAs(document.getElementById('kpi_undecided_30d'), undecRate >= 0.40 ? 'red' : 'neutral');
    var undecTile = document.getElementById('kpi_undecided_30d');
    if (undecTile){
      undecTile.onclick = function(){ if (typeof showTab==='function') showTab('renewals'); };
    }

    setText(root,'#kpi_velocity_7d [data-kpi="approvals7d"]', String(s.approvals7d));
    setText(root,'#kpi_velocity_7d [data-kpi="convPct"]', (s.convToMoveIn*100).toFixed(0)+'%');
    setText(root,'#kpi_velocity_7d [data-kpi="pacingPP"]', __signedPctVal(s.pacingPP, 1));
    var helps = (s.gapPP>0 && s.pacingPP>0) || (s.gapPP<=0 && s.pacingPP>=0);
    classAs(document.getElementById('kpi_velocity_7d'), helps ? 'green' : 'red');

    var struggling = Array.isArray(s.strugglingFPs) ? s.strugglingFPs.filter(function(fp){
      return typeof fp.trendingOcc==='number' && fp.trendingOcc < s.targetOcc;
    }) : [];
    setText(root,'#alert_struggling_fps [data-kpi="strugglingCount"]', String(struggling.length));
    var listFP = root.querySelector('[data-list="fps"]');
    if(listFP){
      listFP.innerHTML = '';
      var top = struggling.slice(0,5);
      if(!top.length){
        var li = document.createElement('li'); li.className='alert-item';
        li.innerHTML = '<span>All clear</span><span><small>—</small></span>';
        listFP.appendChild(li);
      } else {
        top.forEach(function(fp){
          var gapPPv = (s.targetOcc - (fp.trendingOcc||0))*100;
          var need = (s.totalUnits>0 && gapPPv>0) ? Math.ceil(s.totalUnits*gapPPv/100) : 0;
          var li = document.createElement('li'); li.className='alert-item';
          li.innerHTML = `<span><strong>${fp.code||fp.floorplan||'—'}</strong> — ${((fp.trendingOcc||0)*100).toFixed(1)}% <small>(${gapPPv.toFixed(1)}%)</small></span><span><small>Need +${need} homes</small></span>`;
          li.style.cursor='pointer';
          li.onclick = function(){ if(typeof showTab==='function') showTab('newPricing'); };
          listFP.appendChild(li);
        });
      }
    }

    var stale = Array.isArray(s.staleUnits) ? s.staleUnits.slice(0,5) : [];
    setText(root,'#alert_stale_units [data-kpi="staleCount"]', String(Array.isArray(s.staleUnits)?s.staleUnits.length:0));
    var listStale = root.querySelector('[data-list="stale"]');
    if(listStale){
      listStale.innerHTML = '';
      if(!stale.length){
        var li2 = document.createElement('li'); li2.className='alert-item';
        li2.innerHTML = '<span>None</span><span><small>—</small></span>';
        listStale.appendChild(li2);
      } else {
        stale.forEach(function(u){
          var fp = u.fp || u.floorplan || '';
          var days = u.days || u.vacantDays || 0;
          var price = (typeof u.fpPrice==='number') ? u.fpPrice : (u.price || null);
          var right = (price!=null) ? (`<small>FP $${Math.round(price)}</small>`) : '<small></small>';
          var li3 = document.createElement('li'); li3.className='alert-item';
          li3.innerHTML = `<span><strong>${u.unit || u.UnitID || '—'}</strong> (${fp}) — ${days}d</span><span>${right}</span>`;
          li3.style.cursor='pointer';
          li3.onclick = function(){ if(typeof showTab==='function') showTab('newPricing'); };
          listStale.appendChild(li3);
        });
      }
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', paintStatus45);
  } else {
    setTimeout(paintStatus45, 0);
  }
  window.repaintStatus45 = paintStatus45;
})();
</script>

<script>
(function(){
  // Add signed percent formatter (e.g., +3.0%)
  function signedPctVal(x, d=1){ return (x>=0?'+':'') + (Number(x)||0).toFixed(d) + '%'; }
  window.__signedPctVal = signedPctVal; // optional global
})();
</script>

<script>
// Carry-Forward Mode functionality
(function() {
  function updateCarryForwardStatus() {
    const statusEl = document.getElementById('carryForwardStatus');
    const infoEl = document.getElementById('carryForwardInfo');
    const detailsEl = document.getElementById('carryForwardDetails');
    
    if (!statusEl || !infoEl || !detailsEl) return;
    
    try {
      const stored = window.loadCarryForwardBaselines && window.loadCarryForwardBaselines();
      
      if (stored && stored.fpBaselines) {
        statusEl.textContent = 'Active';
        statusEl.style.background = '#059669';
        statusEl.style.color = 'white';
        
        infoEl.style.display = 'block';
        
        const fpCount = Object.keys(stored.fpBaselines).length;
        const lastRun = new Date(stored.at).toLocaleString();
        
        detailsEl.innerHTML = `
          <div>Floorplans: ${fpCount}</div>
          <div>Last run: ${lastRun}</div>
          <div>Scenario: ${stored.scenario || 'Default'}</div>
        `;
      } else {
        statusEl.textContent = 'Inactive';
        statusEl.style.background = '#6b7280';
        statusEl.style.color = 'white';
        
        infoEl.style.display = 'none';
      }
    } catch (e) {
      console.warn('[RM] Failed to update carry-forward status:', e);
      statusEl.textContent = 'Error';
      statusEl.style.background = '#dc2626';
      statusEl.style.color = 'white';
    }
  }
  
  function initCarryForwardUI() {
    const resetBtn = document.getElementById('resetCarryForwardBtn');
    
    if (resetBtn) {
      resetBtn.addEventListener('click', function() {
        if (confirm('Reset carry-forward baselines to seed values? This will clear all saved baseline data.')) {
          try {
            if (window.resetCarryForwardBaselines) {
              window.resetCarryForwardBaselines();
              updateCarryForwardStatus();
              
              // Show success message
              const statusEl = document.getElementById('carryForwardStatus');
              if (statusEl) {
                const originalText = statusEl.textContent;
                statusEl.textContent = 'Reset!';
                statusEl.style.background = '#059669';
                setTimeout(() => {
                  statusEl.textContent = originalText;
                  updateCarryForwardStatus();
                }, 2000);
              }
            }
          } catch (e) {
            console.error('[RM] Failed to reset carry-forward:', e);
            alert('Failed to reset carry-forward baselines. Check console for details.');
          }
        }
      });
    }
    
    // Update status on page load
    updateCarryForwardStatus();
    
    // Update status when switching to Settings tab
    const settingsTab = document.querySelector('[data-tab="settings"]');
    if (settingsTab) {
      settingsTab.addEventListener('click', function() {
        setTimeout(updateCarryForwardStatus, 100);
      });
    }
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCarryForwardUI);
  } else {
    initCarryForwardUI();
  }
})();
</script>

<script>
(function(){
  // Step 100: Vacancy Age Pricing Settings
  
  function $(id){ return document.getElementById(id); }
  
  // Vacancy age pricing configuration
  const VACANCY_AGE_CONFIG = {
    minimal: { dailyRate: 0.1, maxDiscount: 5, description: 'Gentle pressure' },
    medium: { dailyRate: 0.2, maxDiscount: 10, description: 'Moderate pressure' },
    aggressive: { dailyRate: 0.3, maxDiscount: 15, description: 'Strong pressure' }
  };
  
  // Load vacancy age settings from localStorage
  function loadVacancyAgeSettings() {
    const settings = JSON.parse(localStorage.getItem('vacancyAgeSettings') || '{}');
    return {
      enabled: settings.enabled || false,
      intensity: settings.intensity || 'medium',
      thresholdDays: 30
    };
  }
  
  // Save vacancy age settings to localStorage
  function saveVacancyAgeSettings(settings) {
    localStorage.setItem('vacancyAgeSettings', JSON.stringify(settings));
  }
  
  // Update vacancy age UI based on current settings
  function updateVacancyAgeUI() {
    const settings = loadVacancyAgeSettings();
    const enabledCheckbox = $('vacancyAgeEnabled');
    const controlsDiv = $('vacancyAgeControls');
    const intensitySelect = $('vacancyAgeIntensity');
    const previewDiv = $('vacancyAgePreview');
    const examplesDiv = $('vacancyAgeExamples');
    
    if (enabledCheckbox) {
      enabledCheckbox.checked = settings.enabled;
    }
    
    if (controlsDiv) {
      controlsDiv.style.display = settings.enabled ? 'block' : 'none';
    }
    
    if (intensitySelect) {
      intensitySelect.value = settings.intensity;
    }
    
    if (settings.enabled && previewDiv && examplesDiv) {
      const config = VACANCY_AGE_CONFIG[settings.intensity];
      previewDiv.style.display = 'block';
      
      // Generate example discounts
      const examples = [];
      for (let days = 30; days <= 90; days += 15) {
        const discount = Math.min(config.dailyRate * (days - 30), config.maxDiscount);
        examples.push(`${days} days: ${discount.toFixed(1)}% off`);
      }
      examplesDiv.innerHTML = examples.join('<br>');
    } else if (previewDiv) {
      previewDiv.style.display = 'none';
    }
  }
  
  // Initialize vacancy age UI
  function initVacancyAgeUI() {
    const enabledCheckbox = $('vacancyAgeEnabled');
    const intensitySelect = $('vacancyAgeIntensity');
    
    if (enabledCheckbox) {
      enabledCheckbox.addEventListener('change', function() {
        const settings = loadVacancyAgeSettings();
        settings.enabled = this.checked;
        saveVacancyAgeSettings(settings);
        updateVacancyAgeUI();
      });
    }
    
    if (intensitySelect) {
      intensitySelect.addEventListener('change', function() {
        const settings = loadVacancyAgeSettings();
        settings.intensity = this.value;
        saveVacancyAgeSettings(settings);
        updateVacancyAgeUI();
      });
    }
    
    // Update UI on page load
    updateVacancyAgeUI();
    
    // Update UI when switching to Settings tab
    const settingsTab = document.querySelector('[data-tab="settings"]');
    if (settingsTab) {
      settingsTab.addEventListener('click', function() {
        setTimeout(updateVacancyAgeUI, 100);
      });
    }
  }
  
  // ============================================================================
  // DATA SETTINGS UI (STRICT MAPPING)
  // ============================================================================
  
  // Helper function for downloading files (DOM-dependent)
  function downloadFile(url, filename) {
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  window.downloadFile = downloadFile;
  
  function loadDataSettings() {
    return {
      strictMappingEnabled: window.isStrictMappingEnabled ? window.isStrictMappingEnabled() : true, // Default ON
      catalogLockEnabled: window.isCatalogLockEnabled ? window.isCatalogLockEnabled() : true, // Default ON
      propertyProfile: window.loadPropertyProfile ? window.loadPropertyProfile() : null
    };
  }
  
  function saveDataSettings(settings) {
    if (window.setStrictMappingEnabled) {
      window.setStrictMappingEnabled(settings.strictMappingEnabled);
    }
    if (window.setCatalogLockEnabled) {
      window.setCatalogLockEnabled(settings.catalogLockEnabled);
    }
  }
  
  function updateDataSettingsUI() {
    const settings = loadDataSettings();
    const propertyProfile = settings.propertyProfile;
    
    // Update checkboxes (default to checked)
    const strictCheckbox = $('strictMappingEnabled');
    const catalogCheckbox = $('catalogLockEnabled');
    const controlsDiv = $('strictMappingControls');
    const propertyStatusDiv = $('propertyStatus');
    const propertyStatusText = $('propertyStatusText');
    const propertyDetails = $('propertyDetails');
    const captureBtn = $('capturePropertyProfileBtn');
    const unlockBtn = $('unlockFloorplansBtn');
    const downloadBtn = $('downloadProfileBtn');
    
    if (strictCheckbox) {
      strictCheckbox.checked = settings.strictMappingEnabled;
    }
    
    if (catalogCheckbox) {
      catalogCheckbox.checked = settings.catalogLockEnabled;
    }
    
    if (controlsDiv) {
      controlsDiv.style.display = 'block'; // Always visible now
    }
    
    // Update property status
    if (propertyStatusDiv && propertyStatusText && propertyDetails) {
      if (propertyProfile) {
        propertyStatusText.textContent = 'Configured';
        propertyDetails.textContent = `${propertyProfile.propertyName || 'Property'} - ${propertyProfile.floorplanCatalog ? propertyProfile.floorplanCatalog.length : 0} floorplans locked`;
        propertyStatusDiv.style.background = '#f0fdf4';
        propertyStatusDiv.style.borderColor = '#22c55e';
        
        if (unlockBtn) unlockBtn.style.display = 'inline-block';
        if (downloadBtn) downloadBtn.style.display = 'inline-block';
      } else {
        propertyStatusText.textContent = 'Not configured';
        propertyDetails.textContent = 'Thorpe Gardens property profile will be initialized automatically';
        propertyStatusDiv.style.background = '#fef3c7';
        propertyStatusDiv.style.borderColor = '#f59e0b';
        
        if (unlockBtn) unlockBtn.style.display = 'none';
        if (downloadBtn) downloadBtn.style.display = 'none';
      }
    }
  }
  
  function initDataSettingsUI() {
    const strictCheckbox = $('strictMappingEnabled');
    const catalogCheckbox = $('catalogLockEnabled');
    const unlockBtn = $('unlockFloorplansBtn');
    const downloadBtn = $('downloadProfileBtn');
    
    if (strictCheckbox) {
      strictCheckbox.addEventListener('change', function() {
        const settings = loadDataSettings();
        settings.strictMappingEnabled = this.checked;
        saveDataSettings(settings);
        updateDataSettingsUI();
      });
    }
    
    if (catalogCheckbox) {
      catalogCheckbox.addEventListener('change', function() {
        const settings = loadDataSettings();
        settings.catalogLockEnabled = this.checked;
        saveDataSettings(settings);
        updateDataSettingsUI();
      });
    }
    
    
    if (unlockBtn) {
      unlockBtn.addEventListener('click', function() {
        if (confirm('⚠️ Temporarily Unlock Floorplans?\n\nThis will allow uploading CSVs with different floorplan catalogs.\n\nOnly use this for testing or special cases.\n\nContinue?')) {
          if (window.setPropertyUnlocked) {
            window.setPropertyUnlocked(true);
            alert('✅ Floorplans temporarily unlocked.\n\nYou can now upload CSVs with different floorplan catalogs.');
            updateDataSettingsUI();
          }
        }
      });
    }
    
    if (downloadBtn) {
      downloadBtn.addEventListener('click', function() {
        const profile = window.loadPropertyProfile ? window.loadPropertyProfile() : null;
        if (profile && window.downloadRentRollProfile) {
          window.downloadRentRollProfile(profile, 'property_profile.json');
        }
      });
    }
    
    // Update UI on page load
    updateDataSettingsUI();
    
    // Update UI when switching to Settings tab
    const settingsTab = document.querySelector('[data-tab="settings"]');
    if (settingsTab) {
      settingsTab.addEventListener('click', function() {
        setTimeout(updateDataSettingsUI, 100);
      });
    }
  }
  
  // Initialize Thorpe Gardens property profile if not exists
  function initializeThorpeGardensProfile() {
    const existingProfile = window.loadPropertyProfile ? window.loadPropertyProfile() : null;
    if (!existingProfile) {
      const thorpeGardensProfile = {
        version: '1.0',
        propertyId: 'thorpe-gardens',
        propertyName: 'Thorpe Gardens',
        floorplanCatalog: ['S0 - Studio', 'A1 1x1', 'B2 2x2', 'C3 3x2 Small'],
        floorplanDetails: {
          'S0 - Studio': { name: 'Studio', bedrooms: 0, units: 50, sampleRent: 1350 },
          'A1 1x1': { name: '1 Bedroom', bedrooms: 1, units: 100, sampleRent: 1500 },
          'B2 2x2': { name: '2 Bedroom', bedrooms: 2, units: 40, sampleRent: 2000 },
          'C3 3x2 Small': { name: '3 Bedroom', bedrooms: 3, units: 10, sampleRent: 2500 }
        },
        createdAt: new Date().toISOString(),
        createdBy: 'system',
        description: 'Thorpe Gardens property floorplan catalog - 200 units, 4 floorplans',
        locked: true,
        metadata: {
          sampleRowCount: 200,
          totalUnits: 200,
          preConfigured: true
        }
      };
      
      if (window.savePropertyProfile) {
        window.savePropertyProfile(thorpeGardensProfile);
        console.log('[RM] Thorpe Gardens property profile initialized');
      }
    }
  }
  
  // Expose to global scope
  window.initializeThorpeGardensProfile = initializeThorpeGardensProfile;

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
      initializeThorpeGardensProfile();
      initDataSettingsUI();
    });
  } else {
    initializeThorpeGardensProfile();
    initDataSettingsUI();
  }
})();
</script>

<!-- ============================================================================
     PRICING ENGINE LOADER (Step 106)
     ============================================================================ -->

<script type="module">
  // Load the pricing engine (Step 106)
  import * as engine from '../dist/browser/src/pricing/engine.js';
  
  // Make engine globally available
  window.__pricingEngine = engine;
  console.log('[RM Step 106] Pricing engine loaded:', Object.keys(engine));
  
  // ============================================================================
  // PRICING ENGINE ADAPTER
  // ============================================================================
  
  /**
   * Create PricingConfig from current settings
   */
  window.__createPricingConfig = function() {
    // Read settings from localStorage
    const comfortTarget = Number(localStorage.getItem('rm:comfort_target') || 0.95);
    const priceResponse = localStorage.getItem('rm:price_response') || 'standard';
    const maxWeeklyDec = Number(localStorage.getItem('rm:max_weekly_dec') || 0.05);
    const minFloorVsCurrentRent = 0.9;
    const referenceTerm = 14;
    const availableTerms = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14];
    
    // Get floorplan setup
    const setupByCode = window.buildSetupByCode ? window.buildSetupByCode() : {};
    const minGapToNextTier = {};
    const stopDownBuffer = {};
    
    if (window.propertySetup && window.propertySetup.floorplans) {
      for (const fp of window.propertySetup.floorplans) {
        if (fp && fp.code) {
          minGapToNextTier[fp.code] = fp.min_gap_to_next_tier_dollars || 0;
          stopDownBuffer[fp.code] = fp.stop_down_buffer_dollars || 0;
        }
      }
    }
    
    return {
      priceResponse,
      comfortTarget,
      maxWeeklyDec,
      minFloorVsCurrentRent,
      minGapToNextTier,
      stopDownBuffer,
      referenceTerm,
      availableTerms,
      vacancyAgePricing: {
        enabled: localStorage.getItem('rm:vacancy_age_enabled') === 'true',
        discountPerDay: 0.002,
        maxDiscount: 0.1,
        thresholdDays: 30,
      },
      seasonalityEnabled: localStorage.getItem('rm:seasonality_enabled') === 'true',
      seasonalityMultipliers: JSON.parse(
        localStorage.getItem('rm:seasonality_multipliers') ||
        '[1.0, 1.0, 1.05, 1.08, 1.10, 1.12, 1.10, 1.08, 1.05, 1.02, 1.0, 1.0]'
      ),
      trendOverridePctByFP: {},
      flags: {
        enableSimulation: false,
        enableCarryForward: true,
      },
    };
  };
  
  /**
   * Create PricingContext from current state
   */
  window.__createPricingContext = function() {
    // Build floorplan trends
    const floorplanTrends = {};
    const setupByCode = window.buildSetupByCode ? window.buildSetupByCode() : {};
    const byFP = window.groupBy ? window.groupBy(window.mappedRows || [], r => r.Floorplan || '') : {};
    
    // Load dev flags
    const devFlags = window.__devFlags || {};
    const trendOverrides = devFlags.trendOverrides || {};
    
    for (const code in setupByCode) {
      const fp = setupByCode[code];
      const units = byFP[code] || [];
      const occupied = units.filter(u => u.Status && !u.Status.toLowerCase().includes('vacant')).length;
      const total = units.length;
      const current = total > 0 ? occupied / total : 0;
      
      // Check for trend override
      let trending = current;
      if (trendOverrides[code] !== undefined && trendOverrides[code] !== null) {
        trending = trendOverrides[code];
        console.log(`[RM Step 107] Using trend override for ${code}: ${(trending * 100).toFixed(1)}%`);
      }
      
      floorplanTrends[code] = {
        code,
        trending,
        current,
        bandLow: (fp.band_low_pct || 93) / 100,
        bandHigh: (fp.band_high_pct || 96) / 100,
        bedrooms: fp.bedrooms || 0,
      };
    }
    
    // Community metrics
    const communityMetrics = {
      trendingOccupancy: window.__trendingOccupancy || 0,
      currentOccupancy: window.__currentOccupancy || 0,
      target: Number(localStorage.getItem('rm:comfort_target') || 0.95),
    };
    
    // Carry-forward baselines
    const carryForwardBaselines = {};
    try {
      const stored = localStorage.getItem('rm_carry_forward_baselines');
      if (stored) {
        const data = JSON.parse(stored);
        if (data && data.fpBaselines) {
          for (const code in data.fpBaselines) {
            carryForwardBaselines[code + '_baseline'] = {
              unitId: code + '_baseline',
              floorplanCode: code,
              priorApprovedRent: Number(data.fpBaselines[code]),
              priorApprovedDate: data.at || new Date().toISOString(),
              term: 14,
            };
          }
        }
      }
    } catch (e) {
      console.warn('[RM Adapter] Failed to load carry-forward baselines:', e);
    }
    
    // Starting rents
    const startingRents = {};
    if (window.propertySetup && window.propertySetup.floorplans) {
      for (const fp of window.propertySetup.floorplans) {
        if (fp && fp.code) {
          startingRents[fp.code] = fp.starting_rent || 0;
        }
      }
    }
    
    return {
      floorplanTrends,
      communityMetrics,
      carryForwardBaselines,
      startingRents,
      today: new Date(),
    };
  };
  
  /**
   * Convert window.mappedRows to UnitState[] format for engine
   */
  window.__convertMappedRowsToUnitStates = function() {
    const mappedRows = window.mappedRows || [];
    const fpMap = _safeLoadFPMap();
    
    return mappedRows.map(row => {
      const floorplanLabel = row.Floorplan || '';
      const floorplanCode = fpMap[floorplanLabel] || firstToken(floorplanLabel);
      
      return {
        unitId: row.UnitID || `unit_${row.Floorplan}_${row.Bedrooms}`,
        floorplanCode: floorplanCode,
        floorplanLabel: floorplanLabel,
        status: row.Status || 'occupied',
        currentRent: Number(row.CurrentRent) || 0,
        leaseEndDate: row.LeaseEnd || undefined,
        preleaseStartDate: row.PreleaseStart || undefined,
        vacantDays: Number(row.VacantDays) || 0,
        moveInDate: row.MoveInDate || undefined,
        amenityAdj: Number(row.AmenityAdj) || 0,
      };
    });
  };
  
  // Helper to extract first token (same as in pricing-fp.js)
  function firstToken(label) {
    const raw = String(label || '')
      .replace(/[×✕✖]/g, 'x')
      .trim()
      .replace(/\s+/g, ' ');
    return (raw.split(/\s+/)[0] || '').replace(/[^A-Za-z0-9]/g, '');
  }
  
  // Helper to load FP map (same as in pricing-fp.js)
  function _safeLoadFPMap() {
    try {
      const propertyId = window.__seedPropertySetup?.property_id || 'thorpe-gardens';
      const fpMapKey = `rm:fpmap:${propertyId}`;
      const saved = JSON.parse(localStorage.getItem(fpMapKey) || '{}');
      const seed = window.__seedFPMap || {};
      return Object.keys(saved).length > 0 ? saved : seed;
    } catch (e) {
      return window.__seedFPMap || {};
    }
  }
  
  console.log('[RM Step 106] Adapter functions loaded');
</script>

<!-- ============================================================================
     SIMULATOR API STUB (Step 1 Phase 2)
     ============================================================================ -->

<script>
(function() {
  'use strict';
  
  // Runner state for Start/Stop continuous stepping
  let runState = {
    isRunning: false,
    timerId: null,
    speed: 1, // 1, 5, or 10
    isProcessing: false
  };
  
  // Speed intervals: 1× = 750ms, 5× = 250ms, 10× = 100ms
  const speedIntervals = {
    1: 750,
    5: 250,
    10: 100
  };
  
  // Start continuous stepping
  function startRunner(speed) {
    if (runState.isRunning) {
      console.log('[RMS] Already running, no-op');
      return;
    }
    
    if (!speed || !speedIntervals[speed]) {
      speed = 1;
    }
    
    runState.isRunning = true;
    runState.speed = speed;
    
    const interval = speedIntervals[speed];
    console.log(`[RMS] Starting runner at ${speed}× speed (interval: ${interval}ms)`);
    
    runState.timerId = setInterval(function() {
      // Guard against re-entrancy
      if (runState.isProcessing) {
        console.log('[RMS] Step still processing, skipping tick');
        return;
      }
      
      runState.isProcessing = true;
      
      try {
        // Call the step function
        if (window.RMS && window.RMS.step) {
          window.RMS.step();
          
          // Update history strip if available
          if (typeof updateHistoryStrip === 'function') {
            updateHistoryStrip();
          }
          
          // Update prices panel if available
          if (typeof updatePricesPanel === 'function') {
            updatePricesPanel();
          }
          
          // Check invariants if available
          if (typeof checkInvariants === 'function') {
            checkInvariants();
          }
        }
      } finally {
        runState.isProcessing = false;
      }
    }, interval);
  }
  
  // Stop continuous stepping
  function stopRunner() {
    if (!runState.isRunning) {
      console.log('[RMS] Not running, no-op');
      return;
    }
    
    console.log('[RMS] Stopping runner');
    runState.isRunning = false;
    
    if (runState.timerId) {
      clearInterval(runState.timerId);
      runState.timerId = null;
    }
  }
  
  // Set speed (if running, restart at new rate)
  function setSpeed(speed) {
    if (!speed || !speedIntervals[speed]) {
      console.warn('[RMS] Invalid speed:', speed);
      return;
    }
    
    console.log(`[RMS] Setting speed to ${speed}×`);
    runState.speed = speed;
    
    // If running, restart at new speed
    if (runState.isRunning) {
      stopRunner();
      startRunner(speed);
    }
  }
  
  // Create window.RMS API stub until browser-adapter.ts is compiled
  window.RMS = window.RMS || {
    mode: 'real',
    history: [],
    lastInvariantCheck: { valid: true },
    trendOccPctByFP: {}, // Track trend % overrides (80–100)
    pricesByFP: {}, // Track current prices per floorplan
    
    setMode: function(mode) { 
      this.mode = mode; 
      console.log('[RMS] Mode set to:', mode);
      if (mode === 'real') {
        stopRunner(); // Stop on mode switch
      }
    },
    getMode: function() { return this.mode; },
    
    setTrendOccPct: function(map) {
      this.trendOccPctByFP = {};
      for (const fp in map) {
        const val = parseFloat(map[fp]);
        if (val >= 80 && val <= 100) {
          this.trendOccPctByFP[fp] = val;
        }
      }
      // Persist to localStorage
      try {
        localStorage.setItem('rms:sim:trendOccPctByFP', JSON.stringify(this.trendOccPctByFP));
      } catch (e) {
        console.warn('[RMS] Failed to persist trendOccPctByFP:', e);
      }
      console.log('[RMS] Trend % overrides set:', this.trendOccPctByFP);
    },
    
    resetTrendOccPct: function() {
      this.trendOccPctByFP = {};
      try {
        localStorage.removeItem('rms:sim:trendOccPctByFP');
      } catch (e) {
        console.warn('[RMS] Failed to clear trendOccPctByFP:', e);
      }
      console.log('[RMS] Trend % overrides reset');
    },
    
    getTrendOccPct: function() { return { ...this.trendOccPctByFP }; }
    
    initSim: function(config) {
      console.log('[RMS] Init simulation:', config);
      this.mode = 'simulation';
      this.config = config;
      this.history = [];
      this.lastInvariantCheck = { valid: true };
      stopRunner(); // Stop on init
    },
    
    resetSim: function(seed) {
      console.log('[RMS] Reset simulation, seed:', seed);
      if (this.config) this.config.seed = seed;
      this.history = [];
      this.lastInvariantCheck = { valid: true };
      stopRunner(); // Stop on reset
    },
    
    runOnce: function() { console.log('[RMS] RunOnce'); },
    step: function() {
      console.log('[RMS] Step forward 1 day');
      
      // Generate dummy prices with deltas for demo
      const fpCodes = ['S0', 'A1', 'B2', 'C3'];
      const basePrices = { 'S0': 1200, 'A1': 1650, 'B2': 2150, 'C3': 2650 };
      const prices = {};
      
      fpCodes.forEach(fp => {
        const override = this.trendOccPctByFP[fp];
        const reasons = override ? [`trend=${override}% (override)`] : [];
        prices[fp] = {
          newRent: basePrices[fp] + (Math.random() - 0.5) * 50,
          delta: (Math.random() - 0.5) * 30,
          reasons: reasons
        };
      });
      
      this.pricesByFP = prices;
      
      // Add a snapshot to history
      this.history.push({
        nowSeconds: Math.floor(Date.now() / 1000),
        dataSource: 'simulation',
        boxScore: { totalUnits: 200, occupiedUnits: 150, onNoticeUnits: 10, vacantReadyUnits: 30, preleasedUnits: 10, occupancyRate: 0.75, projectedOccupancy: 0.85, vacantDaysAvg: 5 },
        lists: { occupied: [], onNotice: [], vacantReady: [], preleased: [] },
        pricesByFP: prices,
        trendOverrides: {},
        trendOccPctByFP: { ...this.trendOccPctByFP },
        propertyInfo: { totalUnits: 200, mixByFP: {} }
      });
      this.lastInvariantCheck = { valid: true };
    },
    
    getHistory: function() { return this.history; },
    loadSnapshot: function(index) { console.log('[RMS] Load snapshot:', index); },
    getInvariantCheck: function() { return this.lastInvariantCheck; },
    
    // Start/Stop controls
    start: function(speed) { startRunner(speed || 1); },
    stop: function() { stopRunner(); },
    setSpeed: function(speed) { setSpeed(speed); },
    getRunningState: function() { return runState; }
  };
  
  console.log('[RM Step 1] window.RMS API stub loaded');
})();
</script>

<!-- ============================================================================
     DEVELOPMENT PANEL CONTROLLER (Step 107)
     ============================================================================ -->

<script>
(function() {
  'use strict';
  
  // Development panel controller
  function initDevPanel() {
    const devPanelCard = document.getElementById('devPanelCard');
    const devPanelToggle = document.getElementById('devPanelToggle');
    const enableSimCheckbox = document.getElementById('devEnableSimulation');
    const enableTrendCheckbox = document.getElementById('devEnableTrendOverrides');
    const trendControls = document.getElementById('trendOverrideControls');
    const sliderContainer = document.getElementById('trendSliderContainer');
    const simStatus = document.getElementById('simulationStatus');
    const dataSourceBadge = document.getElementById('dataSourceBadge');
    const dataSourceText = document.getElementById('dataSourceText');
    
    if (!devPanelCard || !enableSimCheckbox || !enableTrendCheckbox) {
      console.warn('[RM Step 107] Dev panel elements not found');
      return;
    }
    
    // Show dev panel ONLY in development mode (check localStorage for dev mode)
    const devMode = localStorage.getItem('rm:dev_mode') === 'true' || 
                    window.location.hostname === 'localhost' || 
                    window.location.hostname === '127.0.0.1';
    
    if (devMode) {
      devPanelCard.style.display = 'block';
      console.log('[RM Step 107] Dev panel visible (development mode)');
    } else {
      devPanelCard.style.display = 'none';
      console.log('[RM Step 107] Dev panel hidden (production mode)');
    }
    
    // Setup toggle button
    if (devPanelToggle) {
      devPanelToggle.addEventListener('click', function() {
        if (devPanelCard) {
          const isVisible = devPanelCard.style.display !== 'none';
          devPanelCard.style.display = isVisible ? 'none' : 'block';
          this.textContent = isVisible ? 'Show Dev Panel' : 'Hide Dev Panel';
          localStorage.setItem('rm:dev_panel_visible', String(!isVisible));
          console.log('[RM Step 107] Dev panel', isVisible ? 'hidden' : 'shown');
        }
      });
      
      // Restore visibility state
      const savedState = localStorage.getItem('rm:dev_panel_visible');
      if (savedState === 'true' && devMode) {
        devPanelCard.style.display = 'block';
      }
    }
    
    // Load flag states from localStorage
    const simEnabled = localStorage.getItem('rm:dev:enable_simulation') === 'true';
    const trendEnabled = localStorage.getItem('rm:dev:enable_trend_overrides') === 'true';
    
    enableSimCheckbox.checked = simEnabled;
    enableTrendCheckbox.checked = trendEnabled;
    
    // Update UI based on initial state
    updateDevPanelUI();
    
    // Handle simulation toggle
    enableSimCheckbox.addEventListener('change', function() {
      const enabled = this.checked;
      localStorage.setItem('rm:dev:enable_simulation', String(enabled));
      window.__devFlags = window.__devFlags || {};
      window.__devFlags.enableSimulation = enabled;
      updateDevPanelUI();
      console.log('[RM Step 107] Simulation mode:', enabled ? 'ENABLED' : 'disabled');
    });
    
    // Handle trend override toggle
    enableTrendCheckbox.addEventListener('change', function() {
      const enabled = this.checked;
      localStorage.setItem('rm:dev:enable_trend_overrides', String(enabled));
      window.__devFlags = window.__devFlags || {};
      window.__devFlags.enableTrendOverrides = enabled;
      updateDevPanelUI();
      
      if (enabled) {
        buildTrendSliders();
      } else {
        clearTrendSliders();
      }
      
      console.log('[RM Step 107] Trend overrides:', enabled ? 'ENABLED' : 'disabled');
    });
    
    function updateDevPanelUI() {
      const simActive = enableSimCheckbox.checked;
      const trendActive = enableTrendCheckbox.checked;
      
      // Show/hide trend controls
      if (trendControls) {
        trendControls.style.display = trendActive ? 'block' : 'none';
      }
      
      // Show/hide simulation status
      if (simStatus) {
        simStatus.style.display = simActive ? 'block' : 'none';
      }
      
      // Show/hide data source badge
      if (dataSourceBadge) {
        dataSourceBadge.style.display = 'block';
        if (dataSourceText) {
          dataSourceText.textContent = simActive ? 'Simulation' : 'Real';
        }
      }
    }
    
    function buildTrendSliders() {
      if (!sliderContainer) return;
      
      // Clear existing sliders
      sliderContainer.innerHTML = '';
      
      // Get floorplan setup
      const setup = window.propertySetup || {};
      const floorplans = setup.floorplans || [];
      
      if (floorplans.length === 0) {
        sliderContainer.innerHTML = '<div class="note">No floorplans available</div>';
        return;
      }
      
      // Build sliders for each floorplan
      floorplans.forEach(fp => {
        const code = fp.code || '';
        const name = fp.name || code;
        
        // Load stored override (0 = no override)
        const overrideKey = `rm:dev:trend_override:${code}`;
        const storedValue = localStorage.getItem(overrideKey);
        const initialValue = storedValue ? parseFloat(storedValue) : 0;
        
        const sliderGroup = document.createElement('div');
        sliderGroup.style.marginBottom = '12px';
        sliderGroup.style.padding = '8px';
        sliderGroup.style.background = '#f8f9fa';
        sliderGroup.style.borderRadius = '6px';
        
        sliderGroup.innerHTML = `
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
            <label style="font-weight:600; font-size:14px;">${code}</label>
            <span id="trendValue_${code}" style="font-weight:600; color:#0891b2;">${(initialValue * 100).toFixed(1)}%</span>
          </div>
          <div style="display:flex; align-items:center; gap:8px;">
            <input 
              type="range" 
              id="trendSlider_${code}" 
              min="0" 
              max="1" 
              step="0.005" 
              value="${initialValue}"
              style="flex:1;"
            />
            <button 
              class="btn xs" 
              data-fp-code="${code}" 
              style="background:#dc2626; color:white;"
            >
              Reset
            </button>
          </div>
          <div style="font-size:11px; color:#64748b; margin-top:4px;">
            ${name} • ${initialValue === 0 ? 'No override' : 'Overridden'}
          </div>
        `;
        
        sliderContainer.appendChild(sliderGroup);
        
        // Setup slider event listener
        const slider = document.getElementById(`trendSlider_${code}`);
        const valueSpan = document.getElementById(`trendValue_${code}`);
        
        if (slider) {
          slider.addEventListener('input', function() {
            const value = parseFloat(this.value);
            const valueStr = (value * 100).toFixed(1) + '%';
            if (valueSpan) valueSpan.textContent = valueStr;
            
            // Save to localStorage
            localStorage.setItem(overrideKey, String(value));
            
            // Update window flag
            if (!window.__devFlags) window.__devFlags = {};
            if (!window.__devFlags.trendOverrides) window.__devFlags.trendOverrides = {};
            window.__devFlags.trendOverrides[code] = value;
            
            // Update tooltip
            const group = slider.closest('div');
            const tooltip = group?.querySelector('div:last-child');
            if (tooltip) {
              tooltip.innerHTML = `${name} • ${value === 0 ? 'No override' : 'Overridden'}`;
            }
            
            console.log(`[RM Step 107] Trend override ${code}: ${valueStr}`);
          });
        }
        
        // Setup reset button
        const resetBtn = sliderGroup.querySelector('[data-fp-code]');
        if (resetBtn) {
          resetBtn.addEventListener('click', function() {
            const code = this.getAttribute('data-fp-code');
            if (slider) slider.value = '0';
            if (valueSpan) valueSpan.textContent = '0.0%';
            localStorage.setItem(`rm:dev:trend_override:${code}`, '0');
            if (window.__devFlags && window.__devFlags.trendOverrides) {
              window.__devFlags.trendOverrides[code] = 0;
            }
            const group = this.closest('div');
            const tooltip = group?.querySelector('div:last-child');
            if (tooltip) {
              const name = code.split('_')[0] || code;
              tooltip.innerHTML = `${name} • No override`;
            }
            console.log(`[RM Step 107] Trend override ${code} reset`);
            // Trigger slider input event to update display
            if (slider) slider.dispatchEvent(new Event('input'));
          });
        }
      });
      
      console.log(`[RM Step 107] Built ${floorplans.length} trend override sliders`);
    }
    
    function clearTrendSliders() {
      if (sliderContainer) {
        sliderContainer.innerHTML = '';
      }
    }
    
    // Load initial sliders if enabled
    if (trendEnabled) {
      buildTrendSliders();
    }
    
    // Initialize window flags
    if (!window.__devFlags) window.__devFlags = {};
    window.__devFlags.enableSimulation = simEnabled;
    window.__devFlags.enableTrendOverrides = trendEnabled;
    
    // Load saved trend overrides
    if (window.__devFlags.enableTrendOverrides) {
      window.__devFlags.trendOverrides = {};
      const setup = window.propertySetup || {};
      const floorplans = setup.floorplans || [];
      floorplans.forEach(fp => {
        const code = fp.code || '';
        const overrideKey = `rm:dev:trend_override:${code}`;
        const storedValue = localStorage.getItem(overrideKey);
        if (storedValue && !window.__devFlags.trendOverrides) {
          window.__devFlags.trendOverrides = {};
        }
        if (window.__devFlags.trendOverrides) {
          window.__devFlags.trendOverrides[code] = parseFloat(storedValue) || 0;
        }
      });
    }
    
    console.log('[RM Step 107] Dev panel initialized');

    // Simulator Demo Button Handler (KEEP EXISTING BEHAVIOR)
    const simulatorDemoBtn = document.getElementById('simulatorDemoBtn');
    if (simulatorDemoBtn) {
      simulatorDemoBtn.addEventListener('click', function() {
        console.log('[RM Simulator] Loading demo data...');
        
        // Create simulated data
        const demoData = [];
        const floorplans = ['S0', 'A1', 'B2', 'C3'];
        const statuses = ['occupied', 'vacant', 'occupied (on-notice)', 'preleased'];
        
        for (let i = 0; i < 50; i++) {
          const fp = floorplans[i % 4];
          const status = statuses[i % 4];
          const today = new Date();
          
          demoData.push({
            UnitID: `${fp}-${String(i + 1).padStart(3, '0')}`,
            Floorplan: fp,
            Bedrooms: fp === 'S0' ? 0 : fp === 'A1' ? 1 : fp === 'B2' ? 2 : 3,
            Status: status,
            CurrentRent: fp === 'S0' ? 1200 : fp === 'A1' ? 1650 : fp === 'B2' ? 2150 : 2650,
            LeaseEnd: status.includes('occupied') ? new Date(today.getTime() + 180 * 24 * 60 * 60 * 1000).toISOString().split('T')[0] : '',
            PreleaseStart: status === 'preleased' ? new Date(today.getTime() + 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0] : '',
            VacantDays: status === 'vacant' ? Math.floor(Math.random() * 30) : 0,
            MoveInDate: '',
            AmenityAdj: 0
          });
        }
        
        // Store as mapped rows
        window.mappedRows = demoData;
        window.rawRows = demoData;
        window.mapping = {
          UnitID: 'UnitID',
          Floorplan: 'Floorplan',
          Bedrooms: 'Bedrooms',
          Status: 'Status',
          CurrentRent: 'CurrentRent',
          LeaseEnd: 'LeaseEnd',
          PreleaseStart: 'PreleaseStart',
          VacantDays: 'VacantDays',
          MoveInDate: 'MoveInDate',
          AmenityAdj: 'AmenityAdj'
        };
        
        // Update UI
        if (typeof window.__updateStatusFromMappedRows === 'function') {
          window.__updateStatusFromMappedRows(demoData);
        }
        
        // Show success message
        alert(`✅ Simulator Demo Loaded!\n\nLoaded ${demoData.length} simulated units:\n• S0: Studios\n• A1: 1BR\n• B2: 2BR\n• C3: 3BR\n\nYou can now run pricing on this simulated data.\n\nClick "Run New" to see pricing results!`);
        
        console.log('[RM Simulator] Demo data loaded:', demoData.length, 'units');
        
        // Show simulator controls
        const simulatorControls = document.getElementById('simulatorControls');
        if (simulatorControls) {
          simulatorControls.style.display = 'block';
        }
      });
    }

    // Simulator Controls Handlers (Step 1)
    const simInitBtn = document.getElementById('simInitBtn');
    const simResetBtn = document.getElementById('simResetBtn');
    const simRunOnceBtn = document.getElementById('simRunOnceBtn');
    const simStepBtn = document.getElementById('simStepBtn');
    const simStartBtn = document.getElementById('simStartBtn');
    const simStopBtn = document.getElementById('simStopBtn');
    const simSpeed1Btn = document.getElementById('simSpeed1Btn');
    const simSpeed5Btn = document.getElementById('simSpeed5Btn');
    const simSpeed10Btn = document.getElementById('simSpeed10Btn');
    
    if (simInitBtn) {
      simInitBtn.addEventListener('click', function() {
        const totalUnits = parseInt(document.getElementById('simTotalUnits')?.value || '200');
        const seed = parseInt(document.getElementById('simSeed')?.value || '12345');
        
        if (window.RMS && window.RMS.initSim) {
          window.RMS.setMode('simulation');
          window.RMS.initSim({
            seed,
            totalUnits,
            mixByFP: { 'S0': 25, 'A1': 40, 'B2': 30, 'C3': 5 },
            startingRents: { 'S0': 1200, 'A1': 1650, 'B2': 2150, 'C3': 2650 }
          });
          console.log(`[RMS Step 1] Initialized simulator with ${totalUnits} units, seed ${seed}`);
          
          // Show simulator badges
          const seedBadge = document.getElementById('simulatorSeedBadge');
          const seedValue = document.getElementById('simulatorSeedValue');
          if (seedBadge) seedBadge.style.display = 'block';
          if (seedValue) seedValue.textContent = seed.toString();
          
          const dataSourceBadge = document.getElementById('dataSourceBadge');
          const dataSourceText = document.getElementById('dataSourceText');
          if (dataSourceBadge) dataSourceBadge.style.display = 'block';
          if (dataSourceText) dataSourceText.textContent = 'Simulation';
          
          // Show mix sliders
          const mixSliders = document.getElementById('simMixSliders');
          if (mixSliders) mixSliders.style.display = 'block';
          
          // Build mix sliders
          buildMixSliders();
          
          // Build trend % controls
          buildTrendOccPctControls();
          
          // Update visibility
          updateTrendControlsVisibility();
          
          // Enable Start button
          const startBtn = document.getElementById('simStartBtn');
          if (startBtn) startBtn.disabled = false;
          
          alert(`✅ Simulator initialized!\n\nTotal Units: ${totalUnits}\nSeed: ${seed}\n\nReady to run pricing.`);
        } else {
          console.warn('[RMS Step 1] window.RMS not available');
          alert('❌ Simulator API not loaded yet. Please refresh the page.');
        }
      });
    }
    
    if (simResetBtn) {
      simResetBtn.addEventListener('click', function() {
        if (window.RMS && window.RMS.resetSim) {
          const seed = parseInt(document.getElementById('simSeed')?.value || '12345');
          window.RMS.resetSim(seed);
          console.log(`[RMS Step 1] Reset simulator to seed ${seed}`);
          alert(`✅ Simulator reset to seed ${seed}`);
        }
      });
    }
    
    if (simRunOnceBtn) {
      simRunOnceBtn.addEventListener('click', function() {
        if (window.RMS && window.RMS.runOnce) {
          window.RMS.runOnce();
          console.log('[RMS Step 1] RunOnce executed');
        }
      });
    }
    
    if (simStepBtn) {
      simStepBtn.addEventListener('click', function() {
        if (window.RMS && window.RMS.step) {
          window.RMS.step();
          console.log('[RMS Step 1] Stepped forward 1 day');
          
          // Update history strip
          updateHistoryStrip();
          
          // Update prices panel
          updatePricesPanel();
          
          // Check invariants and show warning if needed
          checkInvariants();
        }
      });
    }
    
    // Start/Stop handlers with button state management
    if (simStartBtn) {
      simStartBtn.addEventListener('click', function() {
        if (!window.RMS) return;
        
        const state = window.RMS.getRunningState ? window.RMS.getRunningState() : { isRunning: false, speed: 1 };
        const speed = state.speed || 1;
        
        console.log(`[RMS Step 1] Start at ${speed}× speed`);
        window.RMS.start(speed);
        
        // Update button states
        if (simStartBtn) simStartBtn.disabled = true;
        if (simStopBtn) simStopBtn.disabled = false;
        if (simStepBtn) simStepBtn.disabled = true; // Disable manual Step while running
      });
    }
    
    if (simStopBtn) {
      simStopBtn.addEventListener('click', function() {
        if (!window.RMS) return;
        
        console.log('[RMS Step 1] Stop');
        window.RMS.stop();
        
        // Update button states
        if (simStartBtn) simStartBtn.disabled = false;
        if (simStopBtn) simStopBtn.disabled = true;
        if (simStepBtn) simStepBtn.disabled = false; // Re-enable manual Step
      });
    }
    
    // Speed control handlers
    function updateSpeedButtons(selectedSpeed) {
      const buttons = [simSpeed1Btn, simSpeed5Btn, simSpeed10Btn];
      buttons.forEach((btn, idx) => {
        const speed = [1, 5, 10][idx];
        if (btn) {
          if (speed === selectedSpeed) {
            btn.style.background = '#059669';
            btn.style.color = 'white';
          } else {
            btn.style.background = '';
            btn.style.color = '';
          }
        }
      });
    }
    
    if (simSpeed1Btn) {
      simSpeed1Btn.addEventListener('click', function() {
        window.RMS.setSpeed(1);
        updateSpeedButtons(1);
      });
    }
    
    if (simSpeed5Btn) {
      simSpeed5Btn.addEventListener('click', function() {
        window.RMS.setSpeed(5);
        updateSpeedButtons(5);
      });
    }
    
    if (simSpeed10Btn) {
      simSpeed10Btn.addEventListener('click', function() {
        window.RMS.setSpeed(10);
        updateSpeedButtons(10);
      });
    }
    
    // Initial speed button state
    updateSpeedButtons(1);
    
    // Invariant checking and UI updates
    function checkInvariants() {
      if (!window.RMS || !window.RMS.getInvariantCheck) return;
      
      const check = window.RMS.getInvariantCheck();
      const warningDiv = document.getElementById('simInvariantWarning');
      const messageDiv = document.getElementById('simInvariantMessage');
      
      if (!warningDiv || !messageDiv) return;
      
      if (!check.valid) {
        warningDiv.style.display = 'block';
        messageDiv.textContent = check.message || 'Invariant violation detected';
        
        // Disable Step button
        const stepBtn = document.getElementById('simStepBtn');
        if (stepBtn) stepBtn.disabled = true;
      } else {
        warningDiv.style.display = 'none';
        
        // Re-enable Step button
        const stepBtn = document.getElementById('simStepBtn');
        if (stepBtn) stepBtn.disabled = false;
      }
    }
    
    function updateHistoryStrip() {
      if (!window.RMS || !window.RMS.getHistory) return;
      
      const history = window.RMS.getHistory();
      const historyStrip = document.getElementById('simHistoryStrip');
      if (!historyStrip) return;
      
      historyStrip.innerHTML = history.map((snapshot, idx) => {
        const date = new Date(snapshot.nowSeconds * 1000);
        const timeStr = date.toLocaleTimeString('en-US', { hour12: false });
        return `<div class="history-chip" data-snapshot-idx="${idx}" onclick="window.RMS.loadSnapshot(${idx}); updatePricesPanel(); console.log('Loaded snapshot', ${idx});" style="background:#0891b2; color:white; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:11px;">${timeStr}</div>`;
      }).join('');
    }
    
    // Update window.RMS.loadSnapshot to load prices
    if (window.RMS) {
      const originalLoadSnapshot = window.RMS.loadSnapshot;
      window.RMS.loadSnapshot = function(index) {
        if (originalLoadSnapshot) originalLoadSnapshot.call(this, index);
        const history = this.getHistory();
        const snapshot = history[index];
        if (snapshot && snapshot.pricesByFP) {
          this.pricesByFP = snapshot.pricesByFP;
        }
        updatePricesPanel();
      };
    }
    
    // Build floorplan mix sliders
    function buildMixSliders() {
      const mixContainer = document.getElementById('simMixContainer');
      if (!mixContainer) return;
      
      const floorplans = [
        { code: 'S0', name: 'Studio', default: 25 },
        { code: 'A1', name: '1BR', default: 40 },
        { code: 'B2', name: '2BR', default: 30 },
        { code: 'C3', name: '3BR', default: 5 }
      ];
      
      mixContainer.innerHTML = '';
      
      floorplans.forEach(fp => {
        const row = document.createElement('div');
        row.style.marginBottom = '8px';
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.gap = '8px';
        
        row.innerHTML = `
          <label style="min-width:60px; font-size:12px;">${fp.code}</label>
          <input type="range" min="0" max="100" value="${fp.default}" class="mix-slider" data-fp="${fp.code}" style="flex:1;">
          <span class="mix-value" data-fp="${fp.code}" style="width:50px; text-align:right; font-size:12px;">${fp.default}%</span>
        `;
        
        mixContainer.appendChild(row);
      });
      
      // Update total display
      updateMixTotal();
      
      // Add event listeners
      mixContainer.querySelectorAll('.mix-slider').forEach(slider => {
        slider.addEventListener('input', function() {
          const fp = this.getAttribute('data-fp');
          const value = this.value;
          const valueSpan = mixContainer.querySelector(`.mix-value[data-fp="${fp}"]`);
          if (valueSpan) valueSpan.textContent = value + '%';
          updateMixTotal();
        });
      });
    }
    
    function updateMixTotal() {
      const mixContainer = document.getElementById('simMixContainer');
      if (!mixContainer) return;
      
      const sliders = mixContainer.querySelectorAll('.mix-slider');
      let total = 0;
      sliders.forEach(slider => {
        total += parseInt(slider.value);
      });
      
      // Add total display if not exists
      let totalDisplay = mixContainer.querySelector('.mix-total');
      if (!totalDisplay) {
        totalDisplay = document.createElement('div');
        totalDisplay.className = 'mix-total';
        totalDisplay.style.marginTop = '8px';
        totalDisplay.style.padding = '4px 8px';
        totalDisplay.style.background = total === 100 ? '#dcfce7' : '#fef3c7';
        totalDisplay.style.borderRadius = '4px';
        mixContainer.appendChild(totalDisplay);
      }
      
      totalDisplay.textContent = `Total: ${total}%`;
      totalDisplay.style.background = total === 100 ? '#dcfce7' : (total > 100 ? '#fee2e2' : '#fef3c7');
    }
    
    // Build Trend % controls
    function buildTrendOccPctControls() {
      const container = document.getElementById('simTrendOccPctContainer');
      if (!container) return;
      
      const floorplans = [
        { code: 'S0', name: 'Studio' },
        { code: 'A1', name: '1BR' },
        { code: 'B2', name: '2BR' },
        { code: 'C3', name: '3BR' }
      ];
      
      container.innerHTML = '';
      
      floorplans.forEach(fp => {
        const row = document.createElement('div');
        row.style.marginBottom = '6px';
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.gap = '8px';
        
        // Load saved value or use null
        let savedValue = null;
        try {
          const stored = localStorage.getItem('rms:sim:trendOccPctByFP');
          if (stored) {
            const obj = JSON.parse(stored);
            savedValue = obj[fp.code] || null;
          }
        } catch (e) {}
        
        row.innerHTML = `
          <label style="min-width:60px; font-size:12px;">${fp.code}</label>
          <input type="range" min="80" max="100" value="${savedValue || 92}" class="trend-slider" data-fp="${fp.code}" style="flex:1;">
          <input type="number" min="80" max="100" value="${savedValue || 92}" class="trend-input" data-fp="${fp.code}" style="width:60px; padding:2px 4px;">
          <span class="trend-asterisk" data-fp="${fp.code}" style="width:20px; font-size:14px;">${savedValue ? '*' : ''}</span>
        `;
        
        container.appendChild(row);
      });
      
      // Add event listeners
      container.querySelectorAll('.trend-slider').forEach(slider => {
        slider.addEventListener('input', function() {
          const fp = this.getAttribute('data-fp');
          const value = parseInt(this.value);
          const input = container.querySelector(`.trend-input[data-fp="${fp}"]`);
          const asterisk = container.querySelector(`.trend-asterisk[data-fp="${fp}"]`);
          if (input) input.value = value;
          if (asterisk) asterisk.textContent = '*';
          
          // Update window.RMS
          updateTrendOccPctToRMS();
        });
      });
      
      container.querySelectorAll('.trend-input').forEach(input => {
        input.addEventListener('input', function() {
          const fp = this.getAttribute('data-fp');
          let value = parseInt(this.value);
          if (value < 80) value = 80;
          if (value > 100) value = 100;
          this.value = value;
          
          const slider = container.querySelector(`.trend-slider[data-fp="${fp}"]`);
          const asterisk = container.querySelector(`.trend-asterisk[data-fp="${fp}"]`);
          if (slider) slider.value = value;
          if (asterisk) asterisk.textContent = '*';
          
          // Update window.RMS
          updateTrendOccPctToRMS();
        });
      });
    }
    
    // Update trendOccPctByFP to window.RMS
    function updateTrendOccPctToRMS() {
      if (!window.RMS) return;
      
      const container = document.getElementById('simTrendOccPctContainer');
      if (!container) return;
      
      const map = {};
      container.querySelectorAll('.trend-input').forEach(input => {
        const fp = input.getAttribute('data-fp');
        const asterisk = container.querySelector(`.trend-asterisk[data-fp="${fp}"]`);
        if (asterisk && asterisk.textContent === '*') {
          map[fp] = parseInt(input.value);
        }
      });
      
      window.RMS.setTrendOccPct(map);
    }
    
    // Reset trend % button
    const resetTrendBtn = document.getElementById('simResetTrendBtn');
    if (resetTrendBtn) {
      resetTrendBtn.addEventListener('click', function() {
        if (!window.RMS) return;
        
        window.RMS.resetTrendOccPct();
        
        const container = document.getElementById('simTrendOccPctContainer');
        if (container) {
          container.querySelectorAll('.trend-input').forEach(input => {
            const slider = container.querySelector(`.trend-slider[data-fp="${input.getAttribute('data-fp')}"]`);
            const asterisk = container.querySelector(`.trend-asterisk[data-fp="${input.getAttribute('data-fp')}"]`);
            input.value = 92;
            if (slider) slider.value = 92;
            if (asterisk) asterisk.textContent = '';
          });
        }
        
        console.log('[RM Step 1] Trend % reset to computed');
      });
    }
    
    // Update prices panel
    function updatePricesPanel() {
      if (!window.RMS) return;
      
      const panel = document.getElementById('simPricesPanel');
      const content = document.getElementById('simPricesContent');
      if (!panel || !content) return;
      
      const prices = window.RMS.pricesByFP || {};
      const floorplans = ['S0', 'A1', 'B2', 'C3'];
      
      if (Object.keys(prices).length === 0) {
        content.innerHTML = '<div class="note" style="font-size:12px;">No pricing data yet. Click Step or Start to run.</div>';
        panel.style.display = 'none';
        return;
      }
      
      panel.style.display = 'block';
      
      content.innerHTML = floorplans.map(fp => {
        const p = prices[fp];
        if (!p) return '';
        
        const newRent = p.newRent || 0;
        const delta = p.delta || 0;
        const deltaPct = (newRent - 1200) > 0 ? '+2.5%' : '-1.2%'; // Dummy % for demo
        const reasons = p.reasons || [];
        
        return `
          <div style="margin-bottom:8px; padding:6px; background:white; border-radius:4px;">
            <strong style="font-size:13px;">${fp}</strong>
            <div style="margin-top:4px; font-size:12px;">
              Price: $${newRent.toFixed(0)} | Δ $${delta > 0 ? '+' : ''}${delta.toFixed(0)} | Δ ${deltaPct}
            </div>
            ${reasons.length > 0 ? `<div style="margin-top:4px; font-size:11px; color:#0891b2;">${reasons.join(', ')}</div>` : ''}
          </div>
        `;
      }).join('');
    }
    
    // Show/Hide Trend % controls based on mode
    function updateTrendControlsVisibility() {
      const controls = document.getElementById('simTrendOccPctControls');
      if (!controls) return;
      
      const isSimMode = window.RMS && window.RMS.getMode && window.RMS.getMode() === 'simulation';
      controls.style.display = isSimMode ? 'block' : 'none';
      
      // Show prices panel
      const pricesPanel = document.getElementById('simPricesPanel');
      if (pricesPanel) {
        pricesPanel.style.display = isSimMode ? 'block' : 'none';
      }
    }
    
    console.log('[RM Step 1] Simulator controls initialized');
  }
  
  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initDevPanel);
  } else {
    initDevPanel();
  }
})();
</script>

</body>
</html>


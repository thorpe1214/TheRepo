<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Revenue Management</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0f172a; --panel:#111827; --card:#1f2937; --muted:#94a3b8; --text:#f8fafc;
    --accent:#22d3ee; --ok:#10b981; --warn:#f59e0b; --danger:#ef4444; --ring:#38bdf8;
    --radius:14px;
  }
  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:16px/1.4 "Inter", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
  .wrap{max-width:980px;margin:0 auto;padding:16px}
  h1{font-size:22px;margin:8px 0 12px}
  h2{font-size:16px;margin:0 0 10px;color:#cbd5e1;font-weight:600;letter-spacing:.02em}
  h3{font-size:15px;margin:0 0 8px;color:#cbd5e1}
  .panel{background:var(--panel);border:1px solid #0b1326;border-radius:var(--radius);padding:14px;box-shadow:0 10px 40px rgba(0,0,0,.45)}
  .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:14px}
  @media (max-width:1080px){.grid{grid-template-columns:1fr}}
  .card{background:var(--card);border:1px solid #0b1220;border-radius:12px;padding:12px;margin-bottom:10px}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .row-3{display:grid;grid-template-columns:repeat(3, 1fr);gap:10px}
  .row-4{display:grid;grid-template-columns:repeat(4, 1fr);gap:10px}
  label{display:flex;align-items:center;gap:8px;font-size:12px;color:var(--muted);margin:0 0 6px}
  .help{display:inline-flex;align-items:center;justify-content:center;width:16px;height:16px;border-radius:999px;background:#0b1220;color:#a5b4fc;font-size:11px;cursor:help}
  input[type="number"], input[type="text"], select{
    width:100%;padding:10px 12px;border-radius:10px;border:1px solid #1e293b;background:#0b1220;color:var(--text);
    outline:none;transition:border-color .15s, box-shadow .15s;
  }
  input[type="number"]:focus, input[type="text"]:focus, select:focus{border-color:var(--ring);box-shadow:0 0 0 3px rgba(56,189,248,.15)}
  .switch{display:inline-flex;align-items:center;gap:10px;cursor:pointer;user-select:none}
  .switch input{display:none}
  .toggle{width:48px;height:28px;background:#0b1220;border:1px solid #1e293b;border-radius:999px;position:relative;transition:background .2s,border-color .2s}
  .knob{position:absolute;top:50%;transform:translateY(-50%);left:4px;width:20px;height:20px;background:#e2e8f0;border-radius:50%;transition:left .2s;background-image:linear-gradient(to bottom,#fff,#cbd5e1)}
  .switch input:checked + .toggle{background:var(--ok);border-color:#065f46}
  .switch input:checked + .toggle .knob{left:24px}
  .btn{appearance:none;border:1px solid #1e293b;background:#0b1220;color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer}
  .btn.primary{background:var(--accent);border-color:#0ea5a6;color:#031b21;font-weight:600}
  .btn.warn{background:#ef4444;border-color:#7f1d1d}
  .note{font-size:12px;color:var(--muted);margin-top:6px}
  table.basic{width:100%;border-collapse:collapse;font-size:13px}
  table.basic th, table.basic td{padding:6px;border-top:1px solid #0b2035;text-align:left}
  .badge{display:inline-block;padding:2px 6px;border-radius:9999px;background:#0b1220;color:#cbd5e1;font-size:11px;margin-right:6px;margin-top:4px}
  .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#0b1220;border:1px solid #1e293b;color:#cbd5e1;font-size:12px}
  pre{white-space:pre-wrap;background:#08111d;border:1px solid #0b1322;border-radius:12px;padding:12px;overflow:auto;max-height:60vh}
  .iwrap{position:relative;display:inline-block}
  .itip{position:absolute;display:none;left:20px;top:-6px;min-width:220px;background:#0b1220;border:1px solid #1e293b;color:#cbd5e1;font-size:12px;padding:8px;border-radius:8px;z-index:20}
  .iwrap:hover .itip{display:block}
  .actions{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
</style>
<style>
/* Minimal readability tweak for month inputs (no size/layout changes) */
.months-grid input.month-input{
  text-align:center;
  font-weight:600;
  color:#e5e7eb !important;
  -webkit-text-fill-color:#e5e7eb; /* Safari */
}
</style>

<style>
.btn.sm{ font-size:12px; padding:6px 10px; border:1px solid #334155; border-radius:8px; background:#0f172a; color:#e5e7eb; }
.btn.sm:hover{ border-color:#475569; }
.btn.xs{ font-size:11px; padding:4px 8px; border:1px solid #334155; border-radius:6px; background:#0f172a; color:#e5e7eb; }
.btn.xs:hover{ border-color:#475569; }
</style>


<style>
  .health-chip{ display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid #1e293b; background:#0b1220; }
  .health-ok{ color:#10b981; border-color:#065f46; }
  .health-watch{ color:#f59e0b; border-color:#7c4a03; }
  .health-risk{ color:#ef4444; border-color:#7f1d1d; }
  #boxScoreTable tbody tr:nth-child(odd){ background:rgba(2,6,23,0.35); }
</style>

<!-- Sync target to hidden bandLow/bandHigh for backward compatibility -->
<script>
(function(){
  function _syncBandsFromTarget(){
    try{
      var t = parseFloat(document.getElementById('comfortTarget')?.value || '95');
      if (!isFinite(t)) t = 95;
      var low = Math.max(80, Math.min(100, t - 2));
      var high = Math.max(80, Math.min(100, t + 1));
      var lowEl = document.getElementById('comfortLow');
      var highEl = document.getElementById('comfortHigh');
      if (lowEl) lowEl.value = String(low);
      if (highEl) highEl.value = String(high);
    }catch(e){}
  }
  window._syncBandsFromTarget = _syncBandsFromTarget;
  document.addEventListener('DOMContentLoaded', function(){
    _syncBandsFromTarget();
    var tgt = document.getElementById('comfortTarget');
    if (tgt){
      tgt.addEventListener('input', _syncBandsFromTarget);
      tgt.addEventListener('change', _syncBandsFromTarget);
    }
  });
})();
</script>


<style>
  .tab-hidden { display: none !important; }
  #tabBar .btn.sm.active { background: var(--accent); color:#031b21; border-color:#0ea5a6; font-weight:600; }
</style>

<style>

/* === Option B: Single-column focus & legend hidden === */
.grid { display: block !important; }
.panel { padding: 20px 20px; }
.card { margin: 16px 0; padding: 16px 18px; border-radius: var(--radius); box-shadow: 0 8px 24px rgba(0,0,0,.35); }
h2 { margin-bottom: 12px; letter-spacing: .02em; }
.section-divider { height: 2px; background: linear-gradient(90deg, rgba(34,211,238,.35), transparent); margin: 24px 0; }
.sticky-summary {
  position: sticky; top: 56px; z-index: 50;
  background: rgba(15,23,42,.85);
  backdrop-filter: saturate(120%) blur(6px);
  border: 1px solid #0b1326; border-radius: 12px;
  padding: 10px 12px;
}
#legendCard { display: none !important; }

</style>
<style>

/* === Settings Tab: Compact Executive Layout === */
.settings-card { padding: 12px 14px; margin: 12px 0; }
.settings-card .row, .settings-card .row-3, .settings-card .row-4 { gap: 8px; }
.settings-card label { margin-bottom: 4px; font-size: 12px; color: var(--muted); }
.settings-card input[type="number"], 
.settings-card input[type="text"], 
.settings-card select { padding: 8px 10px; border-radius: 8px; }
.settings-card .note { margin-top: 4px; }
.settings-card h2 { margin-bottom: 10px; }

/* Strategy top row: three columns */
.strategy-row { 
  display: grid; 
  grid-template-columns: 1fr 1fr auto; 
  align-items: end; 
  gap: 12px; 
}
/* Narrower comfort inputs */

/* NL terms button compact */
#nlDropdownBtn { padding: 6px 10px !important; font-size: 12px; border-radius: 8px; }
#nlDropdownPanel { right: 0; }
/* Tighten Seasonality grid within Settings */
.settings-card .months-grid { gap: 6px; }
.settings-card .months-grid input.month-input { padding: 4px 2px; border-radius: 6px; }
/* Reduce card shadows slightly on Settings for visual calm */
.settings-card { box-shadow: 0 6px 18px rgba(0,0,0,.30); }

</style>



<style>
/* === Home CTA styling (screenshot + shade) === */
/* Default Home buttons: dark pill */
.home-only .btn,
.home-only .btn.secondary,
.home-only .btn.xs {
  background: #121a2b;
  color: #e6f6ff;
  border: 1px solid #1f2b44;
  padding: 10px 14px;
  border-radius: 12px;
  font-weight: 600;
  font-size: 13.5px;
  line-height: 1;
  box-shadow: 0 6px 18px rgba(0,0,0,.25);
  transition: filter .15s ease, transform .15s ease, box-shadow .15s ease;
}
/* Accent fill for primary "Run" (with subtle shade/gradient) */
.home-only .btn.accent {
  background: linear-gradient(180deg, var(--accent), #20cfe5);
  color: #001018;
  border: none;
  box-shadow: 0 10px 24px rgba(34,211,238,.35), inset 0 -2px 0 rgba(0,0,0,.20);
}
.home-only .btn:hover { filter: brightness(1.05); transform: translateY(-1px); }
.home-only .btn:active { transform: translateY(0); }
/* Spacing */
.home-only .btn + .btn { margin-left: 6px; }
/* Dark pills brighten on hover */
.home-only .btn:not(.accent):hover {
  box-shadow: 0 8px 22px rgba(0,0,0,.35);
  filter: brightness(1.08);
}

/* Hide in-tab run/export controls (Home is the control surface now) */
#runNew, #exportNew, #runRenew, #exportRenew { display: none !important; }

/* Disable New Pricing & Renewals tabs until runs occur */
#tabBar [data-tab="newPricing"].disabled,
#tabBar [data-tab="renewals"].disabled {
  opacity: .55;
  cursor: not-allowed;
  position: relative;
}

/* Tooltip on hover for disabled tabs */
#tabBar [data-tab].disabled:hover::after {
  content: "üîí Run from Home to unlock";
  position: absolute;
  top: 42px;
  left: 0;
  white-space: nowrap;
  background: #0b1326;
  border: 1px solid #1f2b44;
  color: #cbd5e1;
  padding: 6px 8px;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0,0,0,.35);
  z-index: 100;
}

/* Tiny wiggle to indicate blocked click */
@keyframes wiggleY { 0%{transform:translateY(0)} 25%{transform:translateY(-1px)} 50%{transform:translateY(0)} 75%{transform:translateY(-1px)} 100%{transform:translateY(0)} }
#tabBar [data-tab].wiggle { animation: wiggleY .18s ease-in-out; }
</style>



  
  <style>
  /* === Home: Forward Status at a Glance (Step 45) === */
  .status45 { display:flex; flex-direction:column; gap:16px; }
  .status45 .kpi-row { display:grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap:12px; }
  .status45 .tile { border:1px solid #1e293b; border-radius:12px; padding:14px 16px; background:#0b1220; box-shadow:0 1px 2px rgba(0,0,0,.2); }
  .status45 .tile h3 { margin:0; font-size:12px; text-transform:uppercase; letter-spacing:.04em; color:#94a3b8; }
  .status45 .tile .big { font-size:28px; font-weight:700; margin:6px 0 2px; }
  .status45 .tile .sub { color:#94a3b8; font-size:12px; }
  .status45 .pill { display:inline-block; font-size:11px; padding:2px 8px; border-radius:9999px; margin-left:6px; vertical-align:middle; }
  .status45 .green { color:#10b981; background:rgba(16,185,129,.12); border:1px solid rgba(16,185,129,.35); }
  .status45 .red   { color:#ef4444; background:rgba(239,68,68,.12); border:1px solid rgba(239,68,68,.35); }
  .status45 .amber { color:#f59e0b; background:rgba(245,158,11,.12); border:1px solid rgba(245,158,11,.35); }
  .status45 .neutral { color:#e2e8f0; background:#0f172a; border:1px solid #334155; }

  .status45 .alerts-row { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
  .status45 .alert-card { border:1px solid #1e293b; border-radius:12px; padding:12px 14px; background:#0b1220; }
  .status45 .alert-card h4 { margin:0 0 8px; font-size:13px; font-weight:600; display:flex; align-items:center; gap:8px; }
  .status45 .alert-list { margin:0; padding:0; list-style:none; display:flex; flex-direction:column; gap:6px; }
  .status45 .alert-item { display:flex; justify-content:space-between; gap:12px; font-size:13px; }
  .status45 .alert-item small { color:#94a3b8; }
  @media (max-width: 1024px) {
    .status45 .kpi-row { grid-template-columns: repeat(2, minmax(0,1fr)); }
    .status45 .alerts-row { grid-template-columns: 1fr; }
  }
  </style>

  <style>
  /* --- Step 46: Status widget polish --- */
  #status45-card { margin-top: 2px; }
  .status45 .kpi-row { gap: 14px; }
  .status45 .tile { padding: 16px 18px; border-radius: 14px; transition: transform .06s ease, box-shadow .2s ease, border-color .2s; }
  .status45 .tile:hover { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(0,0,0,.28); border-color: #3b455c; }
  .status45 .tile .big { line-height: 1.1; letter-spacing: .2px; }
  .status45 .tile .sub { margin-top: 2px; opacity: .9; }
  .status45 .pill { margin-left: 8px; padding: 3px 10px; }
  .status45 .alerts-row { gap: 14px; }
  .status45 .alert-card { border-radius: 14px; }
  .status45 .alert-item { align-items: center; }
  </style>

  <style>
  /* Step 48: Funnel band pill */
  .status45 .pill-band { margin-left: 8px; }
  </style>

  <style>
  /* Step 47: Box Score uploader */
  #boxscore-card select { background:#0b1220; color:#e5e7eb; border:1px solid #334155; border-radius:8px; padding:6px 8px; }
  #boxscore-card label { display:flex; flex-direction:column; font-size:12px; color:#94a3b8; gap:4px; }
  </style>

</head>
<body>
<div class="wrap">
  <h1><span class="logo-emoji">üöÄ</span> Revenue Management</h1>
  <div id="tabBar" style="position:sticky; top:0; z-index:100; background:var(--bg); padding:8px 0; margin:0 0 8px; border-bottom:1px solid #0b1326;">
    <div class="actions" style="gap:8px; flex-wrap:wrap">
      <button class="btn sm" data-tab="home">üè† Home</button>
      <button class="btn sm" data-tab="settings">‚öôÔ∏è Settings</button>
      <button class="btn sm" data-tab="newPricing">üíµ New Pricing</button>
      <button class="btn sm" data-tab="renewals">üîÅ Renewals</button>
      <button class="btn sm" data-tab="charts">üìä Charts</button>
      <button class="btn sm" data-tab="history">üïí History</button>
    </div>
  </div>

      

  <div class="grid">
    <div class="panel">


<style>
/* Home visibility harness */
.home-only{ display:none; }
body[data-active-tab="home"] .home-only{ display:block; }
/* Simple horizontal groups */
.home-actions{ display:grid; grid-template-columns:1fr 1fr; gap:12px; }
@media(max-width:900px){ .home-actions{ grid-template-columns:1fr; } }
.home-group{ background:#0f172a; border:1px solid #0b1326; border-radius: var(--radius); padding:12px; }
.home-group .title{ font-weight:600; margin-bottom:8px }
.home-group .btnrow{ display:flex; gap:8px; flex-wrap:wrap; align-items:center }
</style>




      <!-- Privacy -->
      <div class="card">
        <div class="note"><strong>Privacy:</strong> Files are parsed in your browser (no server upload). When we move to SaaS: encryption at rest & in transit, strict retention, and no third party sharing.</div>
      </div>

      <!-- Upload + Mapping -->
      

<!-- Removed Property card (Thorpe Gardens) -->
<div class="card">
        <h2 data-tab-scope="home">Upload Rent Roll</h2>
        <input id="file" type="file" accept=".csv" />
        <div id="automap" style="display:none; margin-top:12px">
          <h3>Column Mapping (auto detected ‚Äî adjust if needed)</h3>
          <div id="mapTable" style="overflow:auto"></div>
          <div id="validationBox" class="note"></div>
          <button id="confirmMapping" class="btn" style="margin-top:8px">Confirm Mapping</button>
      </div>
      </div>
      <div class="home-only">
      
      <div class="card" data-tab-scope="home" id="boxscore-card">
        <h2 data-tab-scope="home">Upload Box Score (optional)</h2>
        <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap">
          <input type="file" id="boxscoreFile" accept=".csv" />
          <button class="btn" id="btnParseBoxScore">Parse</button>
          <span id="boxscoreMeta" style="opacity:.8">No file parsed</span>
        </div>
        <div id="boxscoreMap" style="display:none;margin-top:12px">
          <div style="display:flex;gap:12px;flex-wrap:wrap">
            <label>Date
              <select id="map_bs_date"></select>
            </label>
            <label>Leads
              <select id="map_bs_leads"></select>
            </label>
            <label>Applications
              <select id="map_bs_apps"></select>
            </label>
            <label>Approvals
              <select id="map_bs_approvals"></select>
            </label>
          </div>
          <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
            <button class="btn" id="btnConfirmBoxScore">Confirm Mapping</button>
            <small style="opacity:.8">Daily rows preferred. Weekly works too.</small>
          </div>
        </div>
      </div>
  <div class="card">
    <h2 data-tab-scope="home">Run & Export</h2>
    <div class="home-actions">
      <div class="home-group">
        <div class="title">üíµ New Pricing</div>
        <div class="btnrow">
          <button class="btn" id="homeRunNew" class="btn accent" class="btn accent">Run New</button>
          <button class="btn secondary sm" id="homeExportNew">Export New</button>
          <button class="btn xs" data-goto="newPricing">View</button>
        </div>
      </div>
      <div class="home-group">
        <div class="title">üîÅ Renewals</div>
        <div class="btnrow">
          <button class="btn" id="homeRunRenew" class="btn accent" class="btn accent">Run Renewals</button>
          <button class="btn secondary sm" id="homeExportRenew">Export Renew</button>
          <button class="btn xs" data-goto="renewals">View</button>
        </div>
      </div>
    </div>
    <!-- Hidden fallbacks for legacy code; auto-synced from target -->
    <input id="comfortLow" type="hidden" value="93">
    <input id="comfortHigh" type="hidden" value="96">
  </div>

      <!-- Status 45: Forward-looking widget (placed under Run & Export) -->
      <div class="card" data-tab-scope="home" id="status45-card">
        <h2 data-tab-scope="home">Status at a Glance</h2>
        <div class="status45">

          <!-- Row 1: KPI tiles -->
          <div class="kpi-row">
            <!-- Trending Occupancy -->
            <div class="tile" id="kpi_trending_occ">
              <h3>Trending Occupancy</h3>
              <div class="big" data-kpi="trendingOcc">‚Äî</div>
              <div class="sub">
                Today <span data-kpi="todayOcc">‚Äî</span> ‚Ä¢ Target <span data-kpi="targetOcc">‚Äî</span>
                <span class="pill neutral">Occ + Preleased ‚àí On-Notice</span>
              </div>
            </div>

            <!-- Pacing to Target -->
            <div class="tile" id="kpi_pacing_gap">
              <h3>Pacing to Target</h3>
              <div class="big" data-kpi="gapPP">‚Äî</div>
              <div class="sub">Need <span data-kpi="homesNeeded">‚Äî</span> homes</div>
            </div>

            <!-- Undecided Renewals (30d) -->
            <div class="tile" id="kpi_undecided_30d" style="cursor:pointer">
              <h3>Undecided Renewals (30d)</h3>
              <div class="big"><span data-kpi="undecided30d">‚Äî</span></div>
              <div class="sub">of <span data-kpi="expiring30d">‚Äî</span> expiring</div>
            </div>

            <!-- Leasing Pacing (7d) -->
            <div class="tile" id="kpi_velocity_7d">
              <h3>Leasing Pacing (7d)</h3>
              <div class="big"><span data-kpi="pacingPP">‚Äî</span></div>
              <div class="sub"><span data-kpi="approvals7d">‚Äî</span> approvals ‚Ä¢ conv <span data-kpi="convPct">‚Äî</span></div>
            </div>
          </div>

          <!-- Row 2: Alerts -->
          <div class="alerts-row">
            <div class="alert-card" id="alert_struggling_fps">
              <h4>Struggling Floorplans <span class="pill neutral" data-kpi="strugglingCount">0</span></h4>
              <ul class="alert-list" data-list="fps"></ul>
            </div>

            <div class="alert-card" id="alert_stale_units">
              <h4>Stale Vacancies (‚â•30d) <span class="pill neutral" data-kpi="staleCount">0</span></h4>
              <ul class="alert-list" data-list="stale"></ul>
            </div>
          </div>

        </div>
      </div>





</div>


      <!-- Strategy -->
<style>
  #comfortTarget { max-width: 160px; }
</style>
      <div class="card">
        <h2 data-tab-scope="settings">Strategy</h2>
        <div class="row" id="comfortTargetRow">
          <div style="max-width: 200px;">
            <label>
              <span class="iwrap">Comfort Target Trend %
                <span class="help">i</span>
                <span class="itip">Single target trending occupancy (e.g., 95). We will switch logic in a later step.</span>
              </span>
            </label>
            <input id="comfortTarget" type="number" step="0.1" min="80" max="100" value="95" placeholder="e.g., 95">
          </div>
        </div>
        <div class="row">
          <div>
            <!-- Low/High controls removed in favor of single target -->
          </div>
          <div>
            <div class="inline-compact" style="margin-top:6px; display:flex; gap:8px; align-items:center; justify-content:flex-end;">
              <label style="margin:0;">
                <span class="iwrap">New Lease Terms (Months)
                  <span class="help">i</span>
                  <span class="itip">Select which terms to quote for new leases. Defaults 2‚Äì14; up to 24 supported.</span>
                </span>
              </label>
              <div class="dropdown" style="position:relative;">
                <button id="nlDropdownBtn" type="button" class="btn sm" style="padding:6px 10px;">2‚Äì14</button>
                <div id="nlDropdownPanel" class="panel" style="display:none; position:absolute; right:0; top:110%; background:#0b1220; border:1px solid #334155; border-radius:8px; padding:8px; box-shadow:0 8px 24px rgba(0,0,0,.35); z-index:50; width:220px; max-height:220px; overflow:auto;">
                  <div id="nlTermList" style="display:grid; grid-template-columns:repeat(4,1fr); gap:6px;"></div>
                  <div style="display:flex; justify-content:space-between; margin-top:8px;">
                    <button id="nlAll" class="btn xs" type="button">All</button>
                    <button id="nlNone" class="btn xs" type="button">None</button>
                    <button id="nlDefault" class="btn xs" type="button">2‚Äì14</button>
                  </div>
                </div>
              </div>
            </div>

        </div>
        </div>
        <div class="row-3" style="margin-top:8px">
          <div>
            <label>
              <span class="iwrap">Conversion Sensitivity
                <span class="help">i</span>
                <span class="itip">How strongly we react to applications vs leads when inside the band.</span>
              </span>
            </label>
            <select id="convSensitivity">
              <option value="low">Low</option>
              <option value="medium" selected>Medium</option>
              <option value="high">High</option>
            </select>
          </div>
          <div>
            <label>
              <span class="iwrap">Pricing Adjustment Style
                <span class="help">i</span>
                <span class="itip">Controls how quickly prices adjust each run: Conservative, Standard, or Aggressive.</span>
              </span>
            </label>
            <select id="priceResponse">
              <option value="gentle">Conservative</option>
              <option value="standard" selected>Standard</option>
              <option value="fast">Aggressive</option>
            </select>
          </div>
          <div>
            <label>
              <span class="iwrap">Floorplan Independence
                <span class="help">i</span>
                <span class="itip">Choose how independently the floorplan moves vs the community: Follows Community, Balanced, Independent.</span>
              </span>
            </label>
            <select id="fpSensitivity">
              <option value="low">Follows Community</option>
              <option value="medium" selected>Balanced</option>
              <option value="high">Independent</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Seasonality -->
      <div class="card">
        <h2 data-tab-scope="settings">Seasonality</h2>
        <div class="row">
          <div>
            <label>
              <span class="iwrap">Seasonality Preset
                <span class="help">i</span>
                <span class="itip">Distribute expirations across the year. Choose Normal/Minimal/Aggressive, or use Custom to input your own monthly % targets.</span>
              </span>
            </label>
            <select id="seasonalityCurve">
              <option value="minimal">Minimal</option>
              <option value="normal" selected>Normal</option>
              <option value="aggressive">Aggressive</option>
              <option value="custom">Custom</option>
            </select>
            <style>
              .months-grid input.month-input{
                text-align:center;
                font-weight:600;
                width:100%;
                color:#e5e7eb !important;
                background-color:#0b1220;
                border:1px solid #334155;
                border-radius:8px;
                padding:6px 4px;
              }
              .months-grid input.month-input[readonly]{opacity:0.85;}
              #seasonalityTotal.ok { color: inherit; border-color:#334155; }
              #seasonalityTotal.bad { color:#ef4444; border-color:#ef4444; }
            </style>
            <div id="seasonalityGrid" style="margin-top:10px;">
              <label><strong>Monthly Expiration Targets (%)</strong></label>
              <div class="months-grid" style="display:grid;grid-template-columns:repeat(13,1fr);gap:8px;margin-top:6px;align-items:end;">
                <div><small>Jan</small><input class="month-input" data-idx="0" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Feb</small><input class="month-input" data-idx="1" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Mar</small><input class="month-input" data-idx="2" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Apr</small><input class="month-input" data-idx="3" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>May</small><input class="month-input" data-idx="4" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Jun</small><input class="month-input" data-idx="5" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Jul</small><input class="month-input" data-idx="6" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Aug</small><input class="month-input" data-idx="7" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Sep</small><input class="month-input" data-idx="8" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Oct</small><input class="month-input" data-idx="9" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Nov</small><input class="month-input" data-idx="10" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div><small>Dec</small><input class="month-input" data-idx="11" type="number" min="0" max="100" step="0.1" value="0"></div>
                <div style="text-align:right;">
                  <small>Total</small>
                  <div id="seasonalityTotal" class="ok" style="padding:6px 8px;border-radius:6px;border:1px solid #334155;">0%</div>
                </div>
              </div>
              <p class="note">Tip: Values should equal 100%. Presets show read only values; choose Custom to edit.</p>
            </div>

          </div>
        </div>
        <div class="row" style="margin-top:8px"></div>
      </div>

      <!-- Renewals -->
      <div class="card">
        <h2 data-tab-scope="settings">Renewals</h2>
        <div class="row">
          <div>
            <label>
              <span class="iwrap">Allow Renewal Decrease
                <span class="help">i</span>
                <span class="itip">If current rent is above today's new lease, allow decrease.</span>
              </span>
            </label>
            <label class="switch">
              <input id="allowDecAbove" type="checkbox">
              <span class="toggle"><span class="knob"></span></span>
              <span>On</span>
            </label>
          </div>
          <div>
            <label>
              <span class="iwrap">Apply Guardrails to All Terms
                <span class="help">i</span>
                <span class="itip">Apply the same min/max % change caps across all renewal terms.</span>
              </span>
            </label>
            <label class="switch">
              <input id="capAllTerms" type="checkbox">
              <span class="toggle"><span class="knob"></span></span>
              <span>On</span>
            </label>
          </div>
        </div>
        <div class="row-3" style="margin-top:8px">
          <div>
            <label>
              <span class="iwrap">Percent-to-New (%) (when below)
                <span class="help">i</span>
                <span class="itip">Enter how far renewals move toward the current new lease price when below (e.g., 50 = halfway).</span>
              </span>
            </label>
            <input id="pctToNew" type="number" step="1" min="0" max="100" value="50" placeholder="e.g., 50">
          </div>
        </div>
        <div class="row-3" style="margin-top:8px">
          <div>
            <label>
              <span class="iwrap">Min % (below new)
                <span class="help">i</span>
                <span class="itip">Minimum allowed change when below new lease.</span>
              </span>
            </label>
            <input id="renMin" type="number" step="1" min="-100" max="100" value="0" placeholder="e.g., 0">
          </div>
          <div>
            <label>
              <span class="iwrap">Max % (below new)
                <span class="help">i</span>
                <span class="itip">Maximum allowed increase when below new lease.</span>
              </span>
            </label>
            <input id="renMax" type="number" step="1" min="-100" max="100" value="10" placeholder="e.g., 8">
          </div>
        </div>
        <div class="row-3" style="margin-top:8px">
          <div>
            <label>
              <span class="iwrap">Min % (above new)
                <span class="help">i</span>
                <span class="itip">Minimum allowed change when already above new lease.</span>
              </span>
            </label>
            <input id="renAboveMin" type="number" step="1" min="-100" max="100" value="0" placeholder="e.g., 0">
          </div>
          <div>
            <label>
              <span class="iwrap">Max % (above new)
                <span class="help">i</span>
                <span class="itip">Maximum allowed change when already above new lease.</span>
              </span>
            </label>
            <input id="renAboveMax" type="number" step="1" min="-100" max="100" value="0" placeholder="e.g., 5">
          </div>
          <div>
            <label>
              <span class="iwrap">Renewal Terms (Months)
                <span class="help">i</span>
                <span class="itip">Choose renewal terms to offer; defaults 2‚Äì14, up to 24 supported.</span>
              </span>
            </label>
            <div class="inline-compact" style="margin-top:6px; display:flex; gap:8px; align-items:center; justify-content:flex-start;">
              <div class="dropdown" style="position:relative;">
                <button id="renDropdownBtn" type="button" class="btn sm" style="padding:6px 10px;">2‚Äì14</button>
                <div id="renDropdownPanel" class="panel" style="display:none; position:absolute; left:0; top:110%; background:#0b1220; border:1px solid #334155; border-radius:8px; padding:8px; box-shadow:0 8px 24px rgba(0,0,0,.35); z-index:50; width:220px; max-height:220px; overflow:auto;">
                  <div id="renTermList" style="display:grid; grid-template-columns:repeat(4,1fr); gap:6px;"></div>
                  <div style="display:flex; justify-content:space-between; margin-top:8px;">
                    <button id="renAll" class="btn xs" type="button">All</button>
                    <button id="renNone" class="btn xs" type="button">None</button>
                    <button id="renDefault" class="btn xs" type="button">2‚Äì14</button>
                  </div>
                </div>
              </div>
            </div>
            <div id="renTermBox" style="display:none"></div>
          </div>
        </div>
      </div>

      <!-- Safety & Governance -->
      <div class="card">
        <h2 data-tab-scope="settings">Safety & Governance</h2>
        <div class="row">
          <div>
            <label>
              <span class="iwrap">Change Frequency Limit
                <span class="help">i</span>
                <span class="itip">Choose how often pricing can change: "Daily" allows one publish per day; "Off" removes the limit.</span>
              </span>
            </label>
            <select id="changeCadence">
              <option value="daily" selected>Daily</option>
              <option value="off">Off</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Old Run block hidden to avoid duplicate controls in Step 1 -->
      <div class="card" style="display:none">
        <button id="run" class="btn primary">Run Pricing</button> <button id="exportXLSX" class="btn" disabled>Export XLSX</button>
        <div class="note">Uploads stay local. Results include an expirations chart and suggested new & renewal pricing.</div>
      </div>
    </div>

    <!-- Right column: Seasonality and Results -->
    <div class="panel">
      
      <div class="card" id="boxScoreCard">
        <div class="actions sticky-summary" style="justify-content:space-between">
          <h2 style="margin:0" data-tab-scope="charts">Box Score</h2>
          <div class="note">Floorplan rows ‚Ä¢ Assumes all notices move out</div>
        </div>
        <div id="boxScoreSummary" style="margin:6px 0 0; display:none;"></div>
        <div id="boxScoreWrap" style="overflow:auto; margin-top:6px;">
          <table class="basic" id="boxScoreTable">
            <thead>
              <tr>
                <th style="white-space:nowrap">Group</th>
                <th># Units</th>
                <th># Vacant</th>
                <th># Notices</th>
                <th># Preleased</th>
                <th># Occupied</th>
                <th>Occupied %</th>
                <th>Projected %</th>
              </tr>
            </thead>
            <tbody id="boxScoreBody">
              <tr><td colspan="8" class="note">Run New or Renew to populate.</td></tr>
            </tbody>
            <tfoot id="boxScoreFoot"><tr><td colspan="8" class="note">Totals will appear after you run.</td></tr></tfoot>
          </table>
        </div>
      </div>
<div class="card">
        <h2 data-tab-scope="charts">Seasonality (Next 12 Months)</h2>
        <div style="height:260px;max-height:260px">
          <canvas id="seasonChart" style="width:100%;height:100%"></canvas>
        </div>
        <div class="note">Shows actual expirations (blue bars) vs allowed capacity (line). Overages trigger higher-seasonality pressure.</div>
      </div>
      
      <div class="card">
        <h2 data-tab-scope="charts">Renewal Summary (Next 5 Months)</h2>
        <div id="renewalSummaryWrap" style="overflow:auto; margin-top:6px;">
          <table class="basic" id="renewalSummaryTable">
            <thead>
              <tr>
                <th>Month</th>
                <th>Total Expiring</th>
                <th>Given Notice</th>
                <th>Renewed</th>
                <th>Undecided</th>
                <th>Conversion %</th>
              </tr>
            </thead>
            <tbody id="renewalSummaryBody">
              <tr><td colspan="6" class="note">Run Renewals to populate Renewed. Upload & confirm mapping to see expirations.</td></tr>
            </tbody>
          </table>
          <div id="mtmSummary" class="note" style="margin-top:6px"></div>
        </div>
      </div>

      <div class="card">
        <h2 style="margin-bottom:8px" data-tab-scope="history">Floorplan Price Movement (History)</h2>
        <div class="row" style="align-items:end; margin-bottom:8px;">
          <div>
            <label><span class="iwrap">Select Floorplan
              <span class="help">i</span>
              <span class="itip">Choose a floorplan to view its adjusted base price over recent runs.</span>
            </span></label>
            <select id="fpHistorySelect"></select>
          </div>
          <div>
            <label><span class="iwrap">Points
              <span class="help">i</span>
              <span class="itip">How many recent runs to plot (max 100).</span>
            </span></label>
            <input id="fpHistoryLimit" type="number" min="5" max="100" step="5" value="30">
          </div>
        </div>
        <div style="height:220px;max-height:220px">
          <canvas id="fpHistoryChart" style="width:100%;height:100%"></canvas>
        </div>
        <div class="note">Plots the adjusted base price captured on each <strong>New</strong> run. Does not include term premiums or seasonality.</div>
      </div>


      <div class="card">
        <div class="actions" style="justify-content:space-between">
          <h2 style="margin:0" data-tab-scope="newPricing">New Lease Pricing</h2>
          <div class="actions">
            <button id="runNew" class="btn primary">Run New</button>
            <button id="exportNew" class="btn" disabled>Export New</button>
          </div>
        </div>
        <div id="nlBadge" class="note" style="margin:6px 0 4px; display:none;"></div>
        <div id="nlTables"></div>
      </div>

      <div class="card">
        <div class="actions sticky-summary" style="justify-content:space-between">
          <h2 style="margin:0" data-tab-scope="renewals">Renewal Offers</h2>
          <div class="actions">
            <button id="runRenew" class="btn primary">Run Renewals</button>
            <button id="exportRenew" class="btn" disabled>Export Renew</button>
          </div>
        </div>
        <div id="renBadge" class="note" style="margin:6px 0 4px; display:none;"></div>
        <div id="renTables"></div>
      </div>

      <div class="card" id="legendCard">
        <h2 data-tab-scope="newPricing renewals charts settings">Flags & Legend</h2>
        <ul id="flagList"></ul>
        <div class="note">
          üö© Over max allowed expirations (seasonality) ‚Ä¢ üè∑Ô∏è Floor applied ‚Ä¢ ‚è≥ Vacant too long (30/60/90d) ‚Ä¢
          üìâ Renewal capped by guardrails ‚Ä¢ üï∞Ô∏è Tenure ‚â•30m ‚Ä¢ üíö Above new lease by >10%
        </div>
      </div>

      <div class="card" id="historyCard" style="display:block">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <h2 style="margin:0">History (Local)</h2>
          <button id="clearHistoryBtn" class="btn xs" type="button">Clear history</button>
        </div>
        <div id="historyList" class="note" style="margin-top:8px"></div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script>
(()=>{
  const $ = id => document.getElementById(id);
  const num = (v,d=0)=>{const n=Number(v);return isNaN(n)?d:n};
  const clamp=(x,lo,hi)=>Math.min(Math.max(x,lo),hi);
  const fmt=(v)=> (v==null||isNaN(v)?"":"$"+Math.round(v).toLocaleString());
  const fmtDate = (s)=>{const d=new Date(s); return isNaN(d)? "‚Äî" : d.toLocaleDateString(); };
  const monthKey=(dt)=>{const d=new Date(dt);if(isNaN(d))return null;return d.getFullYear()+"-"+String(d.getMonth()+1).padStart(2,"0");};
  let allowedPctByMonth = [0.04,0.04,0.07,0.09,0.11,0.12,0.12,0.11,0.09,0.07,0.06,0.08];

  
  // --- Export capture storage (split by panel) ---
  let __newPricingRows = [];             // [["Floorplan","Term (mo)","Price ($)"], ...] for New Pricing
  let __seasonalityNewRows = [];         // [["Month","Actual Expirations","Allowed Max"], ...] for New run

  let __renewalsRows = [];               // [["Unit","Floorplan","Lease End","Term (mo)","Offer ($)",...], ...] for Renewals
  let __seasonalityRenewRows = [];       // [["Month","Actual Expirations","Allowed Max"], ...] for Renew run
  // expose buffers to window for cross-module access
  window.__newPricingRows = __newPricingRows;
  window.__seasonalityNewRows = __seasonalityNewRows;
  window.__renewalsRows = __renewalsRows;
  window.__seasonalityRenewRows = __seasonalityRenewRows;

  function resetNewBuffers(){
    __newPricingRows = [["Floorplan","Term (mo)","Price ($)"]];
    __seasonalityNewRows = [["Month","Actual Expirations","Allowed Max"]];
    window.__newPricingRows = __newPricingRows;
    window.__seasonalityNewRows = __seasonalityNewRows;
  }
  function resetRenewBuffers(){
  __renewalsRows = [[
    "Unit","Floorplan","Lease End","Term (mo)",
    "Offer ($)","Current ($)","Baseline New ($)",
    "Pct-to-New","Guardrail Max",
    "BasePct","TermPremiumPct","FinalPctApplied","GuardrailsOn",
    "ShortTermPct","OverCapPct","SeasonalityPct"
  ]];
    __seasonalityRenewRows = [["Month","Actual Expirations","Allowed Max"]];
    window.__renewalsRows = __renewalsRows;
    window.__seasonalityRenewRows = __seasonalityRenewRows;
  }

  // Per-panel export buttons
  function enableExportNew(on){ const b=$("exportNew"); if(b) b.disabled=!on; }
  function enableExportRenew(on){ const b=$("exportRenew"); if(b) b.disabled=!on; }

  function exportNew(){
    if (__newPricingRows.length <= 1 || __seasonalityNewRows.length <= 1){
      alert("Run New first."); return;
    }
    const wb = XLSX.utils.book_new();
    const ws1 = XLSX.utils.aoa_to_sheet(__newPricingRows);
    const ws2 = XLSX.utils.aoa_to_sheet(__seasonalityNewRows);
    XLSX.utils.book_append_sheet(wb, ws1, "New Pricing");
    XLSX.utils.book_append_sheet(wb, ws2, "Seasonality");
    const fname = "export_new_" + new Date().toISOString().slice(0,19).replace(/[:T]/g,"-") + ".xlsx";
    XLSX.writeFile(wb, fname);
  }

  
  function setBadge(elId, kind, rows){
    const el = $(elId);
    if(!el) return;
    const ts = new Date();
    const stamp = ts.toLocaleString();
    const label = kind === "new" ? "New" : "Renew";
    const count = Math.max(0, rows|0);
    el.textContent = `Last run: ${label} ‚Ä¢ rows: ${count} ‚Ä¢ ${stamp}`;
    el.style.display = "block";
  }

  function exportRenew(){
    if (__renewalsRows.length <= 1 || __seasonalityRenewRows.length <= 1){
      alert("Run Renewals first."); return;
    }
    const wb = XLSX.utils.book_new();
    const ws1 = XLSX.utils.aoa_to_sheet(__renewalsRows);
    const ws2 = XLSX.utils.aoa_to_sheet(__seasonalityRenewRows);
    XLSX.utils.book_append_sheet(wb, ws1, "Renewals");
    XLSX.utils.book_append_sheet(wb, ws2, "Seasonality");
    const fname = "export_renew_" + new Date().toISOString().slice(0,19).replace(/[:T]/g,"-") + ".xlsx";
    XLSX.writeFile(wb, fname);
  }
  // (removed global click dispatcher to avoid double-trigger on export buttons)
// (Deprecated in Step 2.1) Legacy single export left in place but unused.
  function enableExportBtn(){}
  function exportXLSX(){ alert("Use the panel-specific Export buttons."); }
  // NEW: per-panel export enablers (Step 1 uses existing all-in-one exporter)

  function enableExportNew(on){ const b=$("exportNew"); if(b) b.disabled=!on; }
  function enableExportRenew(on){ const b=$("exportRenew"); if(b) b.disabled=!on; }

  // Build renewal terms 2..24 months
  function buildRenTerms(){
    const el=$("renTermBox"); el.innerHTML="";
    for(let t=2;t<=24;t++){
      const id="ren_t_"+t;
      el.insertAdjacentHTML("beforeend",`
        <label style="display:flex;align-items:center;gap:6px;">
          <input type="checkbox" id="${id}" value="${t}" ${t<=14?'checked':''}>
          <span>${t}</span>
        </label>
      `);
    }
  }
  buildRenTerms();
  const readRenTerms = ()=> Array.from(document.querySelectorAll("#renTermBox input:checked")).map(x=>parseInt(x.value)).sort((a,b)=>a-b);

  // CSV mapping
  let rawRows=[], mapping=null, mappedRows=[];
  const targetFields = [
    {key:"UnitID", req:true,  hints:["unitid","unit","apt"]},
    {key:"Floorplan", req:true, hints:["floorplan","type","unittype","plan"]},
    {key:"Bedrooms", req:false, hints:["bedrooms","beds","br","bd","bed"]},
    {key:"Status", req:true, hints:["status","occupancy","occ"]},
    {key:"CurrentRent", req:true, hints:["currentrent","rent","base rent"]},
    {key:"LeaseEnd", req:false, hints:["leaseend","expiration","exp date","move out"]},
    {key:"PreleaseStart", req:false, hints:["prelease","future lease","future start"]},
    {key:"VacantDays", req:false, hints:["vacantdays","days vacant"]},
    {key:"MoveInDate", req:false, hints:["movein","lease start"]},
    {key:"AmenityAdj", req:false, hints:["amenity adj","premium","discount"]},
  ];
  const normalizeHeader=(s)=> String(s||"").toLowerCase().replace(/[^a-z0-9]/g,"");

  $("file").addEventListener("change",(e)=>{
    const f=e.target.files?.[0]; if(!f) return;
    Papa.parse(f,{header:true,skipEmptyLines:true,complete:(r)=>{
      rawRows=r.data;
      const cols=Object.keys(rawRows[0]||{});
      mapping={};
      const lower = cols.map(c=>({orig:c, norm:normalizeHeader(c)}));
      for(const tf of targetFields){
        let best = lower.find(c=>c.norm===normalizeHeader(tf.key));
        if(!best) best = lower.find(c=>tf.hints.some(h=>c.norm===normalizeHeader(h)));
        mapping[tf.key] = best ? best.orig : "";
      }
      renderMappingTable(cols, mapping); $("automap").style.display="block"; validateMappingPreview();
    },error:(err)=>alert("Parse error: "+err.message)});
  });

  function renderMappingTable(cols, mapping){
    const opts = sel => ["",...cols].map(c=>`<option ${mapping[sel]===c?"selected":""}>${c}</option>`).join("");
    const rows = targetFields.map(tf=>`
      <tr><td>${tf.key}${tf.req?" *":""}</td>
      <td><select class="sel mapSel" data-key="${tf.key}">${opts(tf.key)}</select></td></tr>`).join("");
    $("mapTable").innerHTML = `<table class="basic"><thead><tr><th>Field</th><th>CSV Column</th></tr></thead><tbody>${rows}</tbody></table>`;
    document.querySelectorAll(".mapSel").forEach(el=> el.addEventListener("change",()=>{mapping[el.dataset.key]=el.value; validateMappingPreview();}));
  }
  function validateMappingPreview(){
    const reqMissing = targetFields.filter(tf=>tf.req && !mapping[tf.key]);
    $("validationBox").textContent = reqMissing.length ? `Missing required: ${reqMissing.map(x=>x.key).join(", ")}` : "Looks good.";
    return !reqMissing.length;
  }

  $("confirmMapping").onclick=()=>{
    if(!validateMappingPreview()){ alert("Fix required fields first."); return; }
    mappedRows = rawRows.map(r=>({
      UnitID:       mapping.UnitID       ? r[mapping.UnitID]       : "",
      Floorplan:    mapping.Floorplan    ? r[mapping.Floorplan]    : "",
      Bedrooms:     mapping.Bedrooms     ? Number(r[mapping.Bedrooms]) : NaN,
      Status:       (mapping.Status      ? String(r[mapping.Status]) : "").toLowerCase(),
      CurrentRent:  mapping.CurrentRent  ? Number(r[mapping.CurrentRent]) : NaN,
      LeaseEnd:     mapping.LeaseEnd     ? r[mapping.LeaseEnd]     : "",
      PreleaseStart:mapping.PreleaseStart? r[mapping.PreleaseStart]: "",
      VacantDays:   mapping.VacantDays   ? Number(r[mapping.VacantDays]) : 0,
      MoveInDate:   mapping.MoveInDate   ? r[mapping.MoveInDate]   : "",
      AmenityAdj:   mapping.AmenityAdj   ? Number(r[mapping.AmenityAdj]) : 0
    }));
    alert("Mapping confirmed. Use Run New or Run Renewals to generate results."); window.mappedRows = mappedRows;

    /* Step 46: derive live status numbers from mappedRows */
    (function(){
      function statusStr(s){ return String(s||"").toLowerCase(); }
      function isVacant(s){ s=statusStr(s); return s.includes("vacant"); }
      function isNotice(s){ s=statusStr(s); return s.includes("notice"); }
      function isOccLike(s){ s=statusStr(s); return s.startsWith("occupied") || s.includes("notice"); }

      function calcTrending(rows){
        const N = rows.length;
        let vac=0, notices=0, preRaw=0, occ=0;
        for(const r of rows){
          const s = statusStr(r.Status);
          if (isVacant(s)) vac++;
          if (isNotice(s)) notices++;
          if (isOccLike(s)) occ++;
          if (r.PreleaseStart) preRaw++;
        }
        const pre = Math.min(preRaw, vac + notices);
        const todayOcc = N ? (occ / N) : 0;
        const trending = N ? ((occ + pre - notices) / N) : 0;
        return { todayOcc, trending: Math.max(0, Math.min(1, trending)), total: N, occ, notices, pre };
      }

      function calcStrugglingFPs(rows, targetOcc){
        const by = new Map();
        for(const r of rows){
          const fp = r.Floorplan || "(unknown)";
          if (!by.has(fp)) by.set(fp, []);
          by.get(fp).push(r);
        }
        const out=[];
        for (const [fp, list] of by.entries()){
          const t = calcTrending(list).trending;
          if (t < targetOcc) out.push({ code: fp, trendingOcc: t });
        }
        out.sort((a,b)=> (a.trendingOcc - b.trendingOcc));
        return out;
      }

      function calcStale(rows){
        const list = rows.filter(r => (Number(r.VacantDays)||0) >= 30 && isVacant(r.Status));
        list.sort((a,b)=> (Number(b.VacantDays)||0) - (Number(a.VacantDays)||0));
        return list.map(r => ({
          unit: r.UnitID || r.Unit || "‚Äî",
          fp: r.Floorplan || "",
          days: Number(r.VacantDays)||0,
          fpPrice: r.Price || r.NewPrice || null,
          hasPre: !!r.PreleaseStart
        }));
      }

      function calcExpiring(rows){
        const in30 = new Date(); in30.setDate(in30.getDate()+30);
        let exp=0;
        for(const r of rows){
          if(!r.LeaseEnd) continue;
          const d = new Date(r.LeaseEnd);
          if(!isNaN(d) && d <= in30) exp++;
        }
        return { expiring30d: exp, undecided30d: exp };
      }

      function updateWidgetData(rows){
        const cfg = (typeof readCfg==='function') ? readCfg() : { comfortTarget: 0.95 };
        const t = calcTrending(rows);
        const exp = calcExpiring(rows);
        const stale = calcStale(rows);
        const fps = calcStrugglingFPs(rows, cfg.comfortTarget || 0.95);

        window.totalUnits = t.total;
        window.occupiedNow = t.occ;
        window.onNotice = t.notices;
        window.preleased = t.pre;

        window.todayOcc = t.todayOcc;
        window.undecidedRenewals30d = exp.undecided30d;
        window.expiring30d = exp.expiring30d;
        window.approvals7d = window.approvals7d || 0;
        window.strugglingFPs = fps;
        window.staleUnits30d = stale;

        if (typeof repaintStatus45 === 'function') repaintStatus45();
      }

      window.__updateStatusFromMappedRows = updateWidgetData;
    })();

    // Call it immediately after mapping confirmation
    if (Array.isArray(window.mappedRows)) { window.__updateStatusFromMappedRows(window.mappedRows); }
  };

  // Seasonality chart + over-cap calc
  let seasonChart, overByKey={};
  function renderSeasonality(norm, rowsTarget){
        const start=new Date(); start.setDate(1);
    const keys=[], labels=[];
    for(let i=0;i<12;i++){ const d=new Date(start); d.setMonth(d.getMonth()+i); keys.push(d.getFullYear()+"-"+String(d.getMonth()+1).padStart(2,"0")); labels.push(d.toLocaleString(undefined,{month:"short"})); }
    const count=Object.fromEntries(keys.map(k=>[k,0]));
    norm.filter(r=>r.LeaseEnd).forEach(r=>{ const k=monthKey(r.LeaseEnd); if(k && count[k]!=null) count[k]++; });
    const actual = keys.map(k=>count[k]||0);
    const allowed = keys.map((k,i)=>Math.round((norm.length)*allowedPctByMonth[i%12]));
    overByKey={};
    keys.forEach((k,i)=>{ const over=Math.max(0,(actual[i]||0)-(allowed[i]||0)); if(over>0) overByKey[k]=over; });
    const ctx=$("seasonChart").getContext("2d");
    if(seasonChart) seasonChart.destroy();
    seasonChart = new Chart(ctx,{type:"bar",data:{labels, datasets:[{label:"Actual expirations",data:actual},{label:"Max allowed",type:"line",data:allowed}]},options:{responsive:true,maintainAspectRatio:false,plugins:{legend:{position:"bottom"}},scales:{x:{grid:{display:false}},y:{beginAtZero:true}}}});
    if (rowsTarget && Array.isArray(rowsTarget)) { for(let i=0;i<keys.length;i++){ rowsTarget.push([labels[i], actual[i]||0, allowed[i]||0]); } }
    const overMonths = keys.map((k,i)=> actual[i]>allowed[i]? labels[i]:null).filter(Boolean);
    if(overMonths.length){ flag(`üö© Over max allowed expirations in: ${overMonths.join(", ")}`); }
  }
  const seasonalityMultiplier=(curve,endKey)=>{
    const curveAlpha = {minimal:0.01, normal:0.02, aggressive:0.03}[curve]||0.02;
    const over = overByKey[endKey]||0;
    return 1 + curveAlpha * over;
  };

  function flag(msg){ const li=document.createElement("li"); li.textContent=msg; $("flagList").appendChild(li); }
  function groupBy(arr,fn){ const m=new Map(); for(const x of arr){ const k=fn(x); m.set(k,(m.get(k)||[]).concat([x])); } return m; }

  // Pricing pieces
  function readCfg(){
    return {
      comfortTarget: num($("comfortTarget").value,95)/100,
      bandLow: Math.max(0.80, Math.min(1.00, (num($("comfortTarget").value,95)-2)/100)),
      bandHigh: Math.max(0.80, Math.min(1.00, (num($("comfortTarget").value,95)+1)/100)),
      convSensitivity: $("convSensitivity").value,
      priceResponse: $("priceResponse").value,
      fpSensitivity: $("fpSensitivity").value,
      seasonalityCurve: $("seasonalityCurve").value,
      agedVacantPolicy: $("agedVacantPolicy").value,
      showDiscount: $("showDiscount").checked,
      floorBadge: $("floorBadge").checked,
      // renewals
      allowDecAbove: $("allowDecAbove").checked,
      capAllTerms: $("capAllTerms").checked,
      strengthToMarket: $("strengthToMarket").value,
      pctToNew: num($("pctToNew").value,50)/100,
      renMin: num($("renMin").value,0)/100,
      renMax: num($("renMax").value,10)/100,
      renAboveMin: num($("renAboveMin").value,0)/100,
      renAboveMax: num($("renAboveMax").value,0)/100,
      renewalAwareness: $("renewalAwareness").value,
      renTerms: (window.readRenTermsCompact ? window.readRenTermsCompact() : readRenTerms()),
      nlTerms: (window.readNLTerms ? window.readNLTerms() : [2,3,4,5,6,7,8,9,10,11,12,13,14]),
      maxWeeklyDec: num($("maxWeeklyDec").value,2)/100,
      // safety
      changeCadence: $("changeCadence").value,
      reviewLarge: $("reviewLarge").checked
    };
  }

  // Conversion map
  const CONV = { low:{target:0.20,tol:0.03,step:0.005}, medium:{target:0.25,tol:0.02,step:0.010}, high:{target:0.30,tol:0.015,step:0.015} };
  const PRICE_STEP = {gentle:0.0075, standard:0.015, fast:0.025};


  function computeMoveSingleThreshold(cfg, fpTrend, commTrend, nFp){
    const T = cfg.comfortTarget || 0.95;       // target trend (0..1)
    const DB = 0.005;                          // ¬±0.5pp deadband
    const GateDown = T - 0.02;                 // block increases if comm <= T-2pp
    const GateUp   = T + 0.01;                 // mild boost if comm >= T+1pp
    const STEP = (PRICE_STEP && PRICE_STEP[cfg.priceResponse]) || 0.015;

    // widen deadband for small samples (approx +0.7pp / sqrt(n))
    const widen = 0.007 / Math.max(1, Math.sqrt(Math.max(1, nFp)));
    const dbEff = DB + widen;

    const dist = fpTrend - T;
    const ad = Math.abs(dist);
    if (ad <= dbEff) return 0;

    // ramp: full step once ~5pp from target
    const scale = Math.min(1, ad / 0.05);
    let step = STEP;
    let dir = (dist > 0) ? +1 : -1;

    // community as stopper/gate
    if (commTrend <= GateDown){
      if (dir > 0) return 0; // block increases when community soft
      const softness = Math.min(1, (T - fpTrend) / 0.05);
      step *= (0.5 + 0.5 * softness);
    } else if (commTrend >= GateUp){
      if (dir > 0) step *= 1.25; // small boost if community strong
    }

    return dir * step * scale;
  }
function computeTrending(norm){
  // Box Score-equivalent helpers
  const status = (s)=> String(s||'').toLowerCase();
  const isVac = (s)=> status(s).includes('vacant');
  const isNotice = (s)=> status(s).includes('notice');
  const isOccLike = (s)=> status(s).startsWith('occupied') || status(s).includes('notice');

  // Community counts
  const N = norm.length;
  let vac = 0, notices = 0, preRaw = 0, occ = 0;
  for(const r of norm){
    const s = status(r.Status);
    if (isVac(s)) vac++;
    if (isNotice(s)) notices++;
    if (isOccLike(s)) occ++;
    if (r.PreleaseStart) preRaw++;
  }
  const pre = Math.min(preRaw, vac + notices); // cannot replace more than pending move-outs
  const occPct = N ? (occ / N) : 0;
  const projected = N ? (1 - ((vac + notices - pre) / N)) : 0;
  const tComm = Math.max(0, Math.min(1, projected));

  // Floorplan-level projected (same rules)
  const byFP = (function groupBy(arr,fn){ const m=new Map(); for(const x of arr){ const k=fn(x); m.set(k,(m.get(k)||[]).concat([x])); } return m; })(norm, r => r.Floorplan || "(unknown)");
  const tFP = {};
  for (const [fp, list] of byFP.entries()){
    const n = list.length;
    let v = 0, no = 0, pr = 0, oc = 0;
    for(const r of list){
      const s = status(r.Status);
      if (isVac(s)) v++;
      if (isNotice(s)) no++;
      if (isOccLike(s)) oc++;
      if (r.PreleaseStart) pr++;
    }
    const pre2 = Math.min(pr, v + no);
    const proj2 = n ? (1 - ((v + no - pre2) / n)) : 0;
    tFP[fp] = Math.max(0, Math.min(1, proj2));
  }

  return { tComm, tFP, occPct }; // occPct included for possible UI chips
}


  function applyIFTHEN(cfg, tFP, tComm, fp){
    const f=tFP[fp]; const c=tComm;
    const low=cfg.bandLow, high=cfg.bandHigh;
    const outsideStep = PRICE_STEP[cfg.priceResponse];
    if (f>high && c<low) return 0;
    if (f>high && c>=low && c<=high) return +outsideStep;
    if (f>high && c>high) return -outsideStep;
    if (f>=low && f<=high && c>high) return 0;
    if (f>=low && f<=high && c>=low && c<=high) return 0;
    if (f>=low && f<=high && c<low) return 0;
    if (f<low && c<low) return -outsideStep;
    if (f<low && c>=low && c<=high) return -outsideStep;
    if (f<low && c>high) return 0;
    return 0;
  }

  function vacancySpecialPct(v){
    if (v>=90) return 0.15;
    if (v>=60) return 0.10;
    if (v>=30) return 0.05;
    return 0;
  }

  function shortTermAdj(base, term){
    if (term>=10) return base;
    const start = 0.08, taper = 0.01;
    const extra = Math.max(0, start - (term-2)*taper);
    return base*(1+extra);
  }

  function renewalBase(current,newLease,cfg,isAbove){
    // Helper: order-aware clamp
    const ordClamp = (x, a, b) => {
      const lo = Math.min(a, b);
      const hi = Math.max(a, b);
      return Math.min(Math.max(x, lo), hi);
    };

    if(!isAbove){
      // BELOW NEW: move toward new by pctToNew, then clamp by [renMin, renMax] (order-aware)
      const target = current + (newLease - current) * (cfg.pctToNew || 0);
      let d = (target / Math.max(1, current)) - 1; // expected >= 0
      const lo = (typeof cfg.renMin === 'number') ? cfg.renMin : 0;
      const hi = (typeof cfg.renMax === 'number') ? cfg.renMax : 0;
      d = ordClamp(d, lo, hi);
      return current * (1 + d);
    } else {
      // ABOVE NEW: move toward new by pctToNew (typically negative), respect allowDecAbove,
      // then clamp by [renAboveMin, renAboveMax] (order-aware; values may be negative)
      const toward = current - (current - newLease) * (cfg.pctToNew || 0);
      let d = (toward / Math.max(1, current)) - 1; // typically < 0
      if (!cfg.allowDecAbove) d = Math.max(0, d); // disallow decreases if configured

      const loRaw = (typeof cfg.renAboveMin === 'number') ? cfg.renAboveMin : -1;
      const hiRaw = (typeof cfg.renAboveMax === 'number') ? cfg.renAboveMax : 0; // negative max => allow decreases
      d = ordClamp(d, loRaw, hiRaw);

      return current * (1 + d);
    }
  }

  function applyRenewalGuardrailMax(cfg, pctChange, isAbove, allowDecAbove){
    // pctChange is (finalPrice/current) - 1 AFTER premiums
    if (!isAbove){
      // BELOW new lease path: cap upward % by renMax; do NOT enforce a min.
      const cappedUp = Math.min(pctChange, cfg.renMax||0);
      return cappedUp;
    } else {
      // ABOVE new lease path:
      // - If decreases are not allowed, clamp negatives to 0 first.
      let p = allowDecAbove ? pctChange : Math.max(0, pctChange);
      // Apply above-new "max %" as an absolute magnitude cap (symmetric)
      const limit = Math.abs(cfg.renAboveMax||0);
      if (p > 0) p = Math.min(p, limit);
      if (p < 0) p = Math.max(p, -limit);
      return p;
    }
  }

  function explain(chips){
    const cap=chips.slice(0,3);
    return `<div>${cap.map(c=>`<span class="badge">${c}</span>`).join(" ")}</div>`;
  }

  // Debug helpers for base formula (added for Renewals debug)
  if (typeof _fmtPct !== 'function'){
    function _fmtPct(p){ return ((p*100).toFixed(1) + '%'); }
  }
  if (typeof _clampOrdered !== 'function'){
    function _clampOrdered(x, a, b){ const lo = Math.min(a, b), hi = Math.max(a, b); return Math.min(Math.max(x, lo), hi); }
  }
  if (typeof buildRenewalBaseFormulaDebug !== 'function'){
    function buildRenewalBaseFormulaDebug(current, newLease, cfg){
      const isAbove = current > newLease;
      const pctToNew = cfg.pctToNew || 0;
      if (!isAbove){
        const target = current + (newLease - current) * pctToNew;
        const rawPct = (target / Math.max(1, current)) - 1;
        const lo = (typeof cfg.renMin === 'number') ? cfg.renMin : 0;
        const hi = (typeof cfg.renMax === 'number') ? cfg.renMax : 0;
        const basePct = _clampOrdered(rawPct, lo, hi);
        const base = Math.round(current * (1 + basePct));
        return [
          'Base (below-new): ',
          `target = ${fmt(target)} = ${fmt(current)} + ${_fmtPct(pctToNew)}√ó(${fmt(newLease)} ‚àí ${fmt(current)})`,
          `; raw ${_fmtPct(rawPct)} ‚Üí clamp[${_fmtPct(lo)}, ${_fmtPct(hi)}] = ${_fmtPct(basePct)}`,
          ` ‚Üí base ${fmt(base)}`
        ].join('');
      } else {
        const toward = current - (current - newLease) * pctToNew;
        let rawPct = (toward / Math.max(1, current)) - 1; // typically negative
        const allowDec = !!cfg.allowDecAbove;
        const loRaw = (typeof cfg.renAboveMin === 'number') ? cfg.renAboveMin : -1;
        const hiRaw = (typeof cfg.renAboveMax === 'number') ? cfg.renAboveMax : 0;
        const afterAllow = allowDec ? rawPct : Math.max(0, rawPct);
        const basePct = _clampOrdered(afterAllow, loRaw, hiRaw);
        const base = Math.round(current * (1 + basePct));
        return [
          'Base (above-new): ',
          `toward = ${fmt(toward)} = ${fmt(current)} ‚àí ${_fmtPct(pctToNew)}√ó(${fmt(current)} ‚àí ${fmt(newLease)})`,
          `; raw ${_fmtPct(rawPct)}`,
          allowDec ? '' : ' ‚Üí no-decrease max(0, raw)',
          ` ‚Üí clamp[${_fmtPct(loRaw)}, ${_fmtPct(hiRaw)}] = ${_fmtPct(basePct)}`,
          ` ‚Üí base ${fmt(base)}`
        ].join('');
      }
    }
  }

  // Debug helpers for base formula (safe additions)
  if (typeof _fmtPct !== 'function'){
    function _fmtPct(p){ return ((p*100).toFixed(1) + '%'); }
  }
  if (typeof _clampOrdered !== 'function'){
    function _clampOrdered(x, a, b){ const lo = Math.min(a, b), hi = Math.max(a, b); return Math.min(Math.max(x, lo), hi); }
  }
  if (typeof buildRenewalBaseFormulaDebug !== 'function'){
    function buildRenewalBaseFormulaDebug(current, newLease, cfg){
      const isAbove = current > newLease;
      const pctToNew = cfg.pctToNew || 0;
      if (!isAbove){
        const target = current + (newLease - current) * pctToNew;
        const rawPct = (target / Math.max(1, current)) - 1;
        const lo = (typeof cfg.renMin === 'number') ? cfg.renMin : 0;
        const hi = (typeof cfg.renMax === 'number') ? cfg.renMax : 0;
        const basePct = _clampOrdered(rawPct, lo, hi);
        const base = Math.round(current * (1 + basePct));
        return [
          'Base (below-new): ',
          `target = ${fmt(target)} = ${fmt(current)} + ${_fmtPct(pctToNew)}√ó(${fmt(newLease)} ‚àí ${fmt(current)})`,
          `; raw ${_fmtPct(rawPct)} ‚Üí clamp[${_fmtPct(lo)}, ${_fmtPct(hi)}] = ${_fmtPct(basePct)}`,
          ` ‚Üí base ${fmt(base)}`
        ].join('');
      } else {
        const toward = current - (current - newLease) * pctToNew;
        let rawPct = (toward / Math.max(1, current)) - 1; // typically negative
        const allowDec = !!cfg.allowDecAbove;
        const loRaw = (typeof cfg.renAboveMin === 'number') ? cfg.renAboveMin : -1;
        const hiRaw = (typeof cfg.renAboveMax === 'number') ? cfg.renAboveMax : 0;
        const afterAllow = allowDec ? rawPct : Math.max(0, rawPct);
        const basePct = _clampOrdered(afterAllow, loRaw, hiRaw);
        const base = Math.round(current * (1 + basePct));
        return [
          'Base (above-new): ',
          `toward = ${fmt(toward)} = ${fmt(current)} ‚àí ${_fmtPct(pctToNew)}√ó(${fmt(current)} ‚àí ${fmt(newLease)})`,
          `; raw ${_fmtPct(rawPct)}`,
          allowDec ? '' : ' ‚Üí no-decrease max(0, raw)',
          ` ‚Üí clamp[${_fmtPct(loRaw)}, ${_fmtPct(hiRaw)}] = ${_fmtPct(basePct)}`,
          ` ‚Üí base ${fmt(base)}`
        ].join('');
      }
    }
  }

  
function collectNewFloorplanPoints(cfg, norm, tState){
  // returns [{fp, price}], where price = adjusted base before term-specific premiums/seasonality
  const byFP = groupBy(norm, r => r.Floorplan || "(unknown)");
  const out = [];
  for(const [fp, list] of byFP.entries()){
    const base = list.reduce((s,r)=>s+(r.CurrentRent||0),0)/Math.max(1,list.length);
    const fpN = list.length;
    const fpTrend = tState.tFP[fp];
    const commTrend = tState.tComm;
    const dir = computeMoveSingleThreshold(cfg, fpTrend, commTrend, fpN);
    let adjusted = base*(1+dir);
    if (dir<0) adjusted = Math.max(adjusted, base*(1-cfg.maxWeeklyDec));
    const vacs = list.filter(r=>r.Status==="vacant").map(r=> (r.VacantDays||0));
    let avgVacPct = 0;
    if(vacs.length){
      const vacPct = vacs.map(v => (v>=90?0.15:(v>=60?0.10:(v>=30?0.05:0))));
      avgVacPct = vacPct.reduce((a,b)=>a+b,0)/vacs.length;
    }
    if (avgVacPct>0) adjusted *= (1-avgVacPct);
    out.push({ fp, price: Math.round(adjusted) });
  }
  // stable sort by name for consistency
  out.sort((a,b)=> a.fp.localeCompare(b.fp));
  return out;
}

  function renderNewLease(cfg,norm,tState){
    const wrap=$("nlTables"); wrap.innerHTML="";
    const byFP=groupBy(norm,r=>r.Floorplan||"(unknown)");
    for(const [fp,list] of byFP.entries()){
      const base = list.reduce((s,r)=>s+(r.CurrentRent||0),0)/Math.max(1,list.length);
      const fpN = list.length;
      const fpTrend = tState.tFP[fp];
      const commTrend = tState.tComm;
      const dir = computeMoveSingleThreshold(cfg, fpTrend, commTrend, fpN);
      const T = (typeof cfg?.comfortTarget === 'number') ? cfg.comfortTarget : 0.95;
      const DB = 0.005;
      // decide reference term = longest selected new-lease term
      const terms = (cfg && Array.isArray(cfg.nlTerms) && cfg.nlTerms.length)
        ? cfg.nlTerms
        : [2,3,4,5,6,7,8,9,10,11,12,13,14];
      const refTerm = Math.max.apply(null, terms);
      var _refPrice = null; // will capture later

      let adjusted = base*(1+dir);
      if (dir<0) adjusted = Math.max(adjusted, base*(1-cfg.maxWeeklyDec));
      const vacs = list.filter(r=>r.Status==="vacant").map(r=>vacancySpecialPct(r.VacantDays||0));
      const avgVac = vacs.length? (vacs.reduce((a,b)=>a+b,0)/vacs.length) : 0;
      if (avgVac>0) adjusted *= (1-avgVac);

      let trs="";
      for(const term of terms){
        // compute pieces explicitly so we can show compact math on the right
        const tpApplied = shortTermAdj(adjusted, term);                  // base after term premium
        const termPremPct = (tpApplied / Math.max(1, adjusted)) - 1;     // relative to adjusted base

        const end = new Date(); end.setMonth(end.getMonth()+term);
        const key = end.getFullYear()+"-"+String(end.getMonth()+1).padStart(2,"0");

        const monthMult = seasonalityMultiplier($("seasonalityCurve").value, key);
        const overCapCount = (typeof overByKey === 'object' && overByKey) ? (overByKey[key] || 0) : 0;
        const overCapPct = monthMult - 1;                                 // additional monthly premium (could be negative/zero)

        let p = tpApplied * monthMult;

        // capture reference term display price
        if (term === refTerm) { _refPrice = Math.round(p); }

        // format compact math: X% & over cap (N) Y% = Z%
        const x = (termPremPct * 100);
        const y = (overCapPct * 100);
        const totalPct = ((p / Math.max(1, adjusted)) - 1) * 100;         // net vs adjusted base
        const signFmt = (v)=> (v>=0? '+' : '‚àí') + Math.abs(v).toFixed(1) + '%';
        const notes = `Term premium ${signFmt(x)} & over cap (${overCapCount}) ${signFmt(y)} = ${signFmt(totalPct)}`;

        // single row: term | price | notes (right-aligned)
        trs += `<tr>
                  <td>${term} mo</td>
                  <td>${fmt(p)}</td>
                  <td style="text-align:right; opacity:.9"><small>${notes}</small></td>
                </tr>`;

        // export stays the same (only the price)
        __newPricingRows.push([fp, term, Math.round(p)]);
      }

      const arrow = (dir > 0.0001) ? "‚Üë" : (dir < -0.0001) ? "‚Üì" : "‚Üí";
      const dbgLine = `
        <div class="note" style="margin-top:6px;opacity:.9">
          Debug ‚Äî ${arrow} reference: ${refTerm} mo @ ${fmt(_refPrice)}
          ‚Ä¢ move=${(dir*100).toFixed(2)}%
          ‚Ä¢ Target ${(T*100).toFixed(1)}%
          ‚Ä¢ FP ${(fpTrend*100).toFixed(1)}%
          ‚Ä¢ Comm ${(commTrend*100).toFixed(1)}%
          ‚Ä¢ n=${fpN}
        </div>`;
      // Simple Target/Gate debug line (no extra helpers)
      const _gateDown = T - 0.02;
      const _gateUp   = T + 0.01;
      const _fpVsT_pp = ((fpTrend - T) * 100);          // percent-points
      const _fpVsT_txt = (Math.abs(_fpVsT_pp) < 0.05)
        ? "FP vs Target: 0.0pp"
        : ("FP vs Target: " + (_fpVsT_pp > 0 ? "+" : "‚àí") + Math.abs(_fpVsT_pp).toFixed(1) + "pp");
      const _gate_txt = (commTrend <= _gateDown)
        ? "Community gate: Blocked"
        : (commTrend >= _gateUp ? "Community gate: Boost" : "Community gate: Neutral");
      const dbgLine2 = `
        <div class="note" style="margin-top:2px;opacity:.85">
          ${_fpVsT_txt} ‚Ä¢ ${_gate_txt}
        </div>`;

      wrap.insertAdjacentHTML("beforeend",`
        <div style="border:1px solid #0b2035;border-radius:10px;padding:10px;margin:8px 0">
          <div style="font-weight:600">${fp}</div>
          <table class="basic" style="margin-top:6px">
            <thead><tr><th>Term</th><th>Price</th><th style="text-align:right;">Notes</th></tr></thead>
            <tbody>${trs}</tbody>
            <tfoot id="boxScoreFoot"><tr><td colspan="8" class="note">Totals will appear after you run.</td></tr></tfoot>
          </table>
          ${explain([
            tState.tFP[fp]>$("comfortHigh").value/100? "Trend above comfort":"Trend below/within comfort",
            "Price response: "+$("priceResponse").value,
            avgVac>0? "Aged vacant discount applied": "Seasonality: "+$("seasonalityCurve").value
          ])}
          ${dbgLine}
        </div>`);
    }
  }


  function renderRenewals(cfg,norm,tState){
  const wrap = $("renTables"); 
  wrap.innerHTML = "";

  const byFP = groupBy(norm, r => r.Floorplan || "(unknown)");
  const terms = (cfg && Array.isArray(cfg.renTerms) && cfg.renTerms.length)
    ? cfg.renTerms
    : (window.readRenTermsCompact ? window.readRenTermsCompact() : readRenTerms());
  const refTerm = Math.max.apply(null, terms);

  // occupied units with a lease-end date, oldest first
  const renewals = (norm||[])
    .filter(x => String(x.Status||"").toLowerCase().startsWith("occupied") && x.LeaseEnd)
    .sort((a,b)=> new Date(a.LeaseEnd) - new Date(b.LeaseEnd));

    for (const r of renewals){
    const fp = r.Floorplan || "(unknown)";
    const fpList = byFP.get(fp) || [];
    const fpAvg = fpList.reduce((s,u)=> s + (u.CurrentRent||0), 0) / Math.max(1, fpList.length);
    const fpN = fpList.length;

    // trending + move direction
    const fpTrend   = tState.tFP[fp];
    const commTrend = tState.tComm;
    const dir = computeMoveSingleThreshold(cfg, fpTrend, commTrend, fpN);

    // === Baseline new (no term premium, no over-cap/month pressure) ===
    const baselineNew = fpAvg * (1 + dir);
    const curr = r.CurrentRent || 0;

    let trs = "";
    let _refRenewPrice = NaN;

    for (const term of terms){
      // Whether current is above today's baseline-new
      const isAboveNew = curr > baselineNew;

// --- RENEWALS: per-term computation (surgical patch) ---
// 1) Build base using existing renewalBase
const basePrice = renewalBase(curr, baselineNew, cfg, isAboveNew);
let basePct = (basePrice / Math.max(1, curr)) - 1;

// 2) Term premiums = short-term (2‚Äì9) + seasonality.
const end = new Date(); end.setMonth(end.getMonth() + term);
const key = end.getFullYear() + "-" + String(end.getMonth()+1).padStart(2, "0");

// Start from basePrice to compute the multiplicative term effects just like New
const baseAfterShort = shortTermAdj(basePrice, term); // if term>=10, it's unchanged
const shortTermPctDec = (baseAfterShort / Math.max(1, basePrice)) - 1; // decimal

const monthMult = seasonalityMultiplier(cfg.seasonalityCurve, key) || 1;
const seasonalityPctDec = (monthMult - 1); // decimal
const overCount = (overByKey && overByKey[key]) ? overByKey[key] : 0;

// Apply term effects multiplicatively to basePrice to get the raw term price
const rawTermPrice = baseAfterShort * monthMult;

// 3) Convert to final % vs current and apply guardrails policy
let pctFinal = (rawTermPrice / Math.max(1, curr)) - 1;
if (cfg.capAllTerms === true) {
  // Per-term MAX-only cap after premiums
  pctFinal = applyRenewalGuardrailMax(cfg, pctFinal, isAboveNew, cfg.allowDecAbove);
} else {
  // No per-term cap. If above-new and decreases are not allowed, prevent negative final pct.
  if (isAboveNew && !cfg.allowDecAbove) {
    pctFinal = Math.max(0, pctFinal);
  }
}

// Final offer (rounded)
const offer = Math.round(curr * (1 + pctFinal));

// --- Notes formatting (match New style). When guardrails OFF, omit "max-cap ..." ---
const pctToStr = v => `${(v*100).toFixed(1)}%`;
const parts = [];
parts.push(`term premium ${pctToStr(shortTermPctDec)}`);
if (overCount && seasonalityPctDec !== 0) {
  parts.push(`& over cap (${overCount}) ${pctToStr(Math.max(0, seasonalityPctDec))}`);
} else {
  parts.push(`& seasonality ${pctToStr(seasonalityPctDec)}`);
}
const termSumDec = shortTermPctDec + seasonalityPctDec;
const left = `${parts.join(' ')} = ${pctToStr(termSumDec)}`;
let note = left + ` ‚Üí applied ${pctToStr(pctFinal)}`;
if (cfg.capAllTerms === true) {
  const maxCap = isAboveNew ? Math.abs(cfg.renAboveMax || 0) : Math.abs(cfg.renMax || 0);
  note = `${left} ‚Üí max-cap ${pctToStr(maxCap)} ‚Üí applied ${pctToStr(pctFinal)}`;
}

      trs += `<tr>
                <td>${term} mo</td>
                <td>${fmt(offer)}</td>
                <td style="text-align:right;opacity:.9"><small>${note}</small></td>
              </tr>`;

      // Keep export schema; "New Lease Today" column carries the baseline value
      __renewalsRows.push([
        r.UnitID, fp, fmtDate(r.LeaseEnd), term,
        offer, Math.round(curr), Math.round(baselineNew),
        Math.round((cfg.pctToNew||0)*100)+'%',
        (isAboveNew?cfg.renAboveMin:cfg.renMin), (isAboveNew?cfg.renAboveMax:cfg.renMax)
      ]);
    }

    // Footer debug: Current vs baseline-new, plus knobs and applied on reference term
  const appliedPct = (isFinite(_refRenewPrice) && curr>0) ? ((_refRenewPrice/curr - 1)*100) : NaN;
  const appliedTxt = isFinite(appliedPct) ? ((appliedPct>=0?'+':'‚àí')+Math.abs(appliedPct).toFixed(1)+'%') : '‚Äî';
  const pctToNewTxt = Math.round((cfg.pctToNew||0)*100) + '%';
  const maxOnly = Math.max(0, (cfg.renMax||0), (cfg.renAboveMax||0));
  const maxTxt = maxOnly ? (Math.round(maxOnly*1000)/10).toFixed(1)+'%' : '‚Äî';
  const baseLine = (typeof buildRenewalBaseFormulaDebug==='function') ? buildRenewalBaseFormulaDebug(curr, baselineNew, cfg) : '';

    const footerDebug = `
      <div class="note" style="margin-top:6px;opacity:.9">
        Debug ‚Äî Current ${fmt(curr)} vs baseline-new ${fmt(baselineNew)}
        ‚Ä¢ pct-to-new: ${pctToNewTxt} ‚Ä¢ max: ${maxTxt} ‚Üí applied ${appliedTxt}
        <br><span style="opacity:.85">${baseLine}</span>
      </div>`;

    wrap.insertAdjacentHTML("beforeend", `
      <div style="border:1px solid #0b2035;border-radius:10px;padding:10px;margin:8px 0">
        <div style="font-weight:600">Unit ${r.UnitID} ‚Äî ${fp} ‚Äî Lease End ${fmtDate(r.LeaseEnd)} ‚Äî Current ${fmt(curr)}</div>
        <table class="basic" style="margin-top:6px">
          <thead><tr><th>Term</th><th>Offer</th><th style="text-align:right;">Notes</th></tr></thead>
          <tbody>${trs}</tbody>
        </table>
        ${footerDebug}
        ${explain([
          (curr >= baselineNew) ? "Above baseline-new" : "Below baseline-new",
          "Percent-to-new: " + Math.round((cfg.pctToNew||0)*100) + "%",
          cfg.capAllTerms ? "Guardrails: max only" : "Guardrails off"
        ])}
      </div>`);
  }
}


  // STEP 1: split run paths
  function canRun(){
    if(!mappedRows?.length){ alert("Upload & confirm mapping first."); return false; }
    if(window.applySeasonalityFromUI && !window.applySeasonalityFromUI()) return false;
    return true;
  }
  function computeState(){ if (typeof window._syncBandsFromTarget === 'function') window._syncBandsFromTarget(); const cfg = readCfg(); const tState = computeTrending(mappedRows); return {cfg,tState}; }

  $("runNew").addEventListener("click",()=>{
    if(!canRun()) return;
    $("flagList").innerHTML="";
    resetNewBuffers();
    renderSeasonality(mappedRows, __seasonalityNewRows);
    const {cfg,tState} = computeState();
    const fpPts = collectNewFloorplanPoints(cfg, mappedRows, tState);
    renderNewLease(cfg,mappedRows,tState);
    setBadge("nlBadge","new", (__newPricingRows.length>0? (__newPricingRows.length-1):0));
    addHistory("new", cfg, tState, (__newPricingRows.length>0? (__newPricingRows.length-1):0), fpPts);
    enableExportNew(true);
    if (Array.isArray(window.mappedRows) && typeof window.__updateStatusFromMappedRows==='function'){
      window.__updateStatusFromMappedRows(window.mappedRows);
    }
  });

  $("runRenew").addEventListener("click",()=>{
    if(!canRun()) return;
    $("flagList").innerHTML="";
    resetRenewBuffers();
    renderSeasonality(mappedRows, __seasonalityRenewRows);
    const {cfg,tState} = computeState();
    renderRenewals(cfg,mappedRows,tState);
    setBadge("renBadge","renew", (__renewalsRows.length>0? (__renewalsRows.length-1):0));
    addHistory("renew", cfg, tState, (__renewalsRows.length>0? (__renewalsRows.length-1):0));
    enableExportRenew(true);
    if (Array.isArray(window.mappedRows) && typeof window.__updateStatusFromMappedRows==='function'){
      window.__updateStatusFromMappedRows(window.mappedRows);
    }
  });

  // Temporary: both export buttons use the existing combined exporter (Step 2 will split)
  $("exportNew").addEventListener("click", exportNew);
  $("exportRenew").addEventListener("click", exportRenew);

})();

// --- Local History (scaffold) ---
let __history = []; // keep last 100 runs

function snapshotCfg(cfg){
  try{
    // shallow copy only of keys we care about
    const keys = ["comfortTarget","bandLow","bandHigh","convSensitivity","priceResponse","fpSensitivity","seasonalityCurve",
                  "allowDecAbove","capAllTerms","pctToNew","renMin","renMax","renAboveMin","renAboveMax",
                  "renTerms","nlTerms","changeCadence"];
    const out = {};
    keys.forEach(k => out[k] = Array.isArray(cfg[k]) ? [...cfg[k]] : cfg[k]);
    return out;
  }catch(e){ return {}; }
}

function addHistory(kind, cfg, tState, rowCount, fpPoints){
  const item = {
    ts: new Date().toISOString(),
    kind: kind,                    // "new" | "renew"
    rows: rowCount|0,
    cfg: snapshotCfg(cfg),
    t: {
      comm: (typeof tState?.tComm === "number" ? Math.round(tState.tComm*1000)/1000 : null),
      fps: tState && tState.tFP ? Object.keys(tState.tFP).length : null
    }
  };
  if(kind === 'new' && Array.isArray(fpPoints)) item.fpPoints = fpPoints;
  __history.unshift(item);
  if(__history.length > 100) __history = __history.slice(0,100);
  // Placeholder: future UI rendering goes here.
}

window.getHistory = () => __history.slice(); // read-only copy
window.clearHistory = () => { __history = []; };
</script>

<script>
(function(){
  const btn = document.getElementById('confirmMapping');
  const automap = document.getElementById('automap');
  if(btn && automap){
    btn.addEventListener('click', function(){
      automap.style.display = 'none';
      try { document.getElementById('file')?.scrollIntoView({behavior:'smooth'}); } catch(e){}
    });
  }
})();
</script>

<!-- Backfill hidden controls removed from UI to keep logic working -->
<div id="ui-backfill" style="display:none">
  <input type="checkbox" id="showDiscount">
  <input type="checkbox" id="floorBadge" checked>
  <select id="agedVacantPolicy">
    <option value="off" selected>Off</option>
  </select>
  <select id="strengthToMarket">
    <option value="standard" selected>Standard</option>
  </select>
</div>

<!-- Hidden backfill for removed control to keep logic intact -->
<div style="display:none">
  <select id="renewalAwareness">
    <option value="off">Off</option>
    <option value="standard" selected>Standard (60‚Äì90d)</option>
    <option value="strong">Strong (90‚Äì120d)</option>
  </select>
</div>

<!-- Hidden backfill to keep logic intact after removing the visible control -->
<div style="display:none">
  <input id="maxWeeklyDec" type="number" value="2">
</div>

<!-- Hidden backfill: always enforce review for ‚â•5% changes -->
<div style="display:none">
  <input id="reviewLarge" type="checkbox" checked>
</div>

<script>
(function(){
  const sel = document.getElementById('seasonalityCurve');
  const inputs = Array.from(document.querySelectorAll('#seasonalityGrid .month-input'));
  const totalEl = document.getElementById('seasonalityTotal');

  const PRESETS = {
    normal:    [4,4,7,9,11,12,12,11,9,7,6,8],
    minimal:   [8,8,8,8,8,9,9,9,9,8,8,8],
    aggressive:[5,5,6,7,9,10,12,11,10,8,8,9]
  };

  function fill(values){
    for(let i=0;i<12;i++){
      const v = (values && values[i] != null) ? Number(values[i]) : 0;
      const s = (Math.round(v*10)/10).toString();
      inputs[i].value = s;
      inputs[i].setAttribute('value', s);
      inputs[i].style.color = '#e5e7eb';
    }
    updateTotal();
  }

  function setReadOnly(ro){
    inputs.forEach(inp=>{
      inp.readOnly = !!ro;
      inp.style.opacity = ro ? 0.85 : 1;
    });
  }

  function readInputs(){
    return inputs.map(inp => parseFloat(inp.value||'0')||0);
  }

  function updateTotal(){
    const sum = readInputs().reduce((a,b)=>a+b,0);
    const rounded = Math.round(sum*10)/10;
    totalEl.textContent = rounded + '%';
    const ok = Math.abs(rounded - 100.0) < 0.05;
    totalEl.classList.toggle('bad', !ok);
    totalEl.classList.toggle('ok', ok);
    return ok;
  }

  function applyFromSelect(){
    const val = (sel && sel.value) ? sel.value : 'normal';
    if(val === 'custom'){
      const current = readInputs();
      const allZero = current.every(v => v === 0);
      if(allZero) fill(PRESETS.normal);
      setReadOnly(false);
    }else{
      fill(PRESETS[val] || PRESETS.normal);
      setReadOnly(true);
    }
  }

  window.applySeasonalityFromUI = function(){
    const val = (sel && sel.value) ? sel.value : 'normal';
    if(val === 'custom'){
      if(!updateTotal()){
        alert('Seasonality total must equal 100% for Custom.');
        return false;
      }
      allowedPctByMonth = readInputs().map(v => v/100);
      return true;
    }else{
      const arr = (PRESETS[val] || PRESETS.normal).map(v => v/100);
      allowedPctByMonth = arr;
      return true;
    }
  };

  if(sel){ sel.addEventListener('change', applyFromSelect); }
  inputs.forEach(inp => inp.addEventListener('input', updateTotal));
  applyFromSelect();
  document.addEventListener("DOMContentLoaded", applyFromSelect);
})();
</script>

<script>
(function(){
  const btn = document.getElementById('nlDropdownBtn');
  const panel = document.getElementById('nlDropdownPanel');
  const list = document.getElementById('nlTermList');
  if(!btn || !panel || !list) return;

  function build(){
    list.innerHTML = "";
    for(let t=2;t<=24;t++){
      const id = "nl_opt_" + t;
      const checked = (t>=2 && t<=14) ? 'checked' : '';
      list.insertAdjacentHTML('beforeend', `
        <label style="display:flex; align-items:center; gap:6px;">
          <input type="checkbox" id="${id}" value="${t}" ${checked}>
          <span>${t}</span>
        </label>
      `);
    }
    updateBtnLabel();
  }

  function getSelected(){
    return Array.from(list.querySelectorAll('input:checked')).map(x => parseInt(x.value)).sort((a,b)=>a-b);
  }

  function setSelected(range){
    list.querySelectorAll('input').forEach(inp => {
      const v = parseInt(inp.value);
      inp.checked = range ? (v >= range[0] && v <= range[1]) : false;
    });
    updateBtnLabel();
  }

  function updateBtnLabel(){
    const sel = getSelected();
    if(sel.length === 0){ btn.textContent = "Select"; return; }
    let contiguous = true;
    for(let i=1;i<sel.length;i++){ if(sel[i] !== sel[i-1]+1){ contiguous=false; break; } }
    btn.textContent = contiguous ? `${sel[0]}‚Äì${sel[sel.length-1]}` : sel.slice(0,6).join(',') + (sel.length>6?'‚Ä¶':'');
  }

  window.readNLTerms = function(){
    return getSelected();
  };

  const btnAll = document.getElementById('nlAll');
  const btnNone = document.getElementById('nlNone');
  const btnDef = document.getElementById('nlDefault');
  if(btnAll) btnAll.addEventListener('click', ()=>{ setSelected([2,24]); });
  if(btnNone) btnNone.addEventListener('click', ()=>{ setSelected(null); });
  if(btnDef) btnDef.addEventListener('click', ()=>{ setSelected([2,14]); });

  function togglePanel(){ panel.style.display = (panel.style.display==='block') ? 'none' : 'block'; }
  btn.addEventListener('click', (e)=>{ e.stopPropagation(); togglePanel(); });
  document.addEventListener('click', ()=>{ panel.style.display = 'none'; });
  panel.addEventListener('click', (e)=> e.stopPropagation());

  list.addEventListener('change', updateBtnLabel);
  build();
})();
</script>

<script>
(function(){
  const btn = document.getElementById('renDropdownBtn');
  const panel = document.getElementById('renDropdownPanel');
  const list = document.getElementById('renTermList');
  if(!btn || !panel || !list) return;

  function build(){
    list.innerHTML = "";
    for(let t=2;t<=24;t++){
      const checked = (t>=2 && t<=14) ? 'checked' : '';
      list.insertAdjacentHTML('beforeend', `
        <label style="display:flex; align-items:center; gap:6px;">
          <input type="checkbox" value="${t}" ${checked}>
          <span>${t}</span>
        </label>
      `);
    }
    updateBtnLabel();
  }

  function getSelected(){
    return Array.from(list.querySelectorAll('input:checked')).map(x => parseInt(x.value)).sort((a,b)=>a-b);
  }

  function setSelected(range){
    list.querySelectorAll('input').forEach(inp => {
      const v = parseInt(inp.value);
      inp.checked = range ? (v >= range[0] && v <= range[1]) : false;
    });
    updateBtnLabel();
  }

  function updateBtnLabel(){
    const sel = getSelected();
    if(sel.length === 0){ btn.textContent = "Select"; return; }
    let contiguous = true;
    for(let i=1;i<sel.length;i++){ if(sel[i] !== sel[i-1]+1){ contiguous=false; break; } }
    btn.textContent = contiguous ? `${sel[0]}‚Äì${sel[sel.length-1]}` : sel.slice(0,6).join(',') + (sel.length>6?'‚Ä¶':'');
  }

  window.readRenTermsCompact = function(){
    const arr = getSelected();
    return arr.length ? arr : [2,3,4,5,6,7,8,9,10,11,12,13,14];
  };

  const btnAll = document.getElementById('renAll');
  const btnNone = document.getElementById('renNone');
  const btnDef = document.getElementById('renDefault');
  if(btnAll) btnAll.addEventListener('click', ()=>{ setSelected([2,24]); });
  if(btnNone) btnNone.addEventListener('click', ()=>{ setSelected(null); });
  if(btnDef) btnDef.addEventListener('click', ()=>{ setSelected([2,14]); });

  function togglePanel(){ panel.style.display = (panel.style.display==='block') ? 'none' : 'block'; }
  btn.addEventListener('click', (e)=>{ e.stopPropagation(); togglePanel(); });
  document.addEventListener('click', ()=>{ panel.style.display = 'none'; });
  panel.addEventListener('click', (e)=> e.stopPropagation());

  list.addEventListener('change', updateBtnLabel);
  build();
})();
</script>

<script>
(function(){
  if (typeof window.readRenTermsCompact === 'function') {
    window.readRenTerms = function(){ return window.readRenTermsCompact(); };
  }
})();
</script>


<script>
(function(){
  let fpChart, fpChartCtx;
  const sel = document.getElementById('fpHistorySelect');
  const lim = document.getElementById('fpHistoryLimit');

  function getAllFloorplansFromHistory(){
    try{
      const hist = (typeof window.getHistory === 'function') ? window.getHistory() : [];
      const set = new Set();
      for(const h of hist){
        if(h && h.kind === 'new' && Array.isArray(h.fpPoints)){
          for(const p of h.fpPoints){ if(p && p.fp) set.add(p.fp); }
        }
      }
      return Array.from(set).sort((a,b)=> a.localeCompare(b));
    }catch(e){ return []; }
  }

  function ensureSelectOptions(){
    if(!sel) return;
    const fps = getAllFloorplansFromHistory();
    const current = sel.value;
    sel.innerHTML = fps.map(fp => `<option value="${fp.replace(/"/g,'&quot;')}">${fp}</option>`).join("");
    // try to keep selection if still present
    if(current && fps.includes(current)) sel.value = current;
  }

  function buildSeries(fp, limitN){
    const hist = (typeof window.getHistory === 'function') ? window.getHistory() : [];
    const pts = [];
    for(const h of hist){
      if(h && h.kind === 'new' && Array.isArray(h.fpPoints)){
        const m = h.fpPoints.find(x => x.fp === fp);
        if(m){
          pts.push({ x: new Date(h.ts), y: m.price });
        }
      }
    }
    // reverse chronological -> chronological for plotting
    pts.reverse();
    if(limitN && limitN > 0 && pts.length > limitN){
      // take the last 'limitN' chronological points
      return pts.slice(pts.length - limitN);
    }
    return pts;
  }

  function renderChart(){
    if(!sel || !lim) return;
    const fp = sel.value;
    if(!fp){ return; }
    const n = Math.max(5, Math.min(100, parseInt(lim.value||'30',10)));
    const dataPts = buildSeries(fp, n);

    if(!fpChartCtx){
      fpChartCtx = document.getElementById('fpHistoryChart').getContext('2d');
    }
    if(fpChart){ fpChart.destroy(); }
    fpChart = new Chart(fpChartCtx, {
      type: 'line',
      data: {
        datasets: [{
          label: fp + " base price",
          parsing: false,
          data: dataPts,
          tension: 0.2
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, position: 'bottom' },
          tooltip: {
            callbacks: {
              label: (ctx)=> {
                const v = ctx.parsed.y;
                const d = ctx.parsed.x;
                try{
                  const ds = new Date(d).toLocaleString();
                  return `$${Math.round(v).toLocaleString()} ‚Äî ${ds}`;
                }catch(e){ return `$${Math.round(v).toLocaleString()}`; }
              }
            }
          }
        },
        scales: {
          x: { type: 'time', time: { unit:'day' }, ticks:{ autoSkip:true } },
          y: { beginAtZero: false }
        }
      }
    });
  }

  function refreshUI(){
    ensureSelectOptions();
    if(sel && !sel.value){
      const opts = sel.querySelectorAll('option');
      if(opts.length) sel.value = opts[0].value;
    }
    renderChart();
  }

  // Init on DOM ready
  document.addEventListener('DOMContentLoaded', refreshUI);

  // Re-render on selection change
  if(sel) sel.addEventListener('change', renderChart);
  if(lim) lim.addEventListener('input', renderChart);

  // Also refresh after each run by monkey-patching addHistory to trigger a small refresh.
  if(typeof window.addHistory === 'function'){
    const _addHistory = window.addHistory;
    window.addHistory = function(kind, cfg, tState, rowCount, fpPoints){
      const result = _addHistory.apply(this, arguments);
      // Only refresh if a new run occurred
      try { refreshUI(); } catch(e){}
      return result;
    };
  }
})();
</script>


<script>
(function(){
  const listEl = document.getElementById('historyList');
  const clearBtn = document.getElementById('clearHistoryBtn');

  function formatKind(k){ return k==='new' ? 'New' : (k==='renew' ? 'Renew' : String(k||'')); }
  function formatTs(s){ try{ return new Date(s).toLocaleString(); }catch(e){ return s; } }

  window.renderHistoryList = function(){
    if(!listEl) return;
    const hist = (typeof window.getHistory === 'function') ? window.getHistory() : [];
    if(!hist.length){
      listEl.innerHTML = '<em>No history yet. Run New or Renew to populate.</em>';
      return;
    }
    const rows = hist.map((h,i)=>{
      const parts = [
        `<strong>#${hist.length - i}</strong>`,
        `‚Ä¢ ${formatKind(h.kind)}`,
        `‚Ä¢ rows: ${h.rows||0}`,
        `‚Ä¢ ${formatTs(h.ts)}`
      ];
      return `<div style="padding:4px 0; border-top:1px solid #0b2035">${parts.join(' ')}</div>`;
    }).join('');
    listEl.innerHTML = rows;
  };

  // Wire clear button
  if(clearBtn){
    clearBtn.addEventListener('click', ()=>{
      try{ window.clearHistory && window.clearHistory(); }catch(e){}
      window.renderHistoryList && window.renderHistoryList();
    });
  }

  // Initial render on DOM ready
  document.addEventListener('DOMContentLoaded', ()=>{
    window.renderHistoryList && window.renderHistoryList();
  });

  // Hook into addHistory so the list refreshes after each run
  if(typeof window.addHistory === 'function'){
    const _addHistory = window.addHistory;
    window.addHistory = function(kind, cfg, tState, rowCount, fpPoints){
      const r = _addHistory.apply(this, arguments);
      try{ window.renderHistoryList && window.renderHistoryList(); }catch(e){}
      return r;
    };
  }
})();
</script>


<script>
(function(){
  // Apply a settings snapshot to the UI without running pricing.
  function setVal(id, val){
    const el = document.getElementById(id);
    if(!el) return;
    if(el.type === 'checkbox'){
      el.checked = !!val;
    } else if(el.tagName === 'SELECT' || el.tagName === 'INPUT'){
      el.value = val;
    }
  }

  function setTermCheckboxes(listSelector, terms){
    try{
      const list = document.querySelectorAll(listSelector + ' input[type="checkbox"]');
      const set = new Set((terms||[]).map(Number));
      list.forEach(inp => { inp.checked = set.has(parseInt(inp.value,10)); });
    }catch(e){}
  }

  function setNLButtonLabel(){
    const btn = document.getElementById('nlDropdownBtn');
    const sel = Array.from(document.querySelectorAll('#nlTermList input:checked')).map(x=>parseInt(x.value,10)).sort((a,b)=>a-b);
    if(!btn) return;
    if(sel.length===0){ btn.textContent = "Select"; return; }
    let contiguous = true;
    for(let i=1;i<sel.length;i++){ if(sel[i] !== sel[i-1]+1){ contiguous=false; break; } }
    btn.textContent = contiguous ? `${sel[0]}‚Äì${sel[sel.length-1]}` : sel.slice(0,6).join(',') + (sel.length>6?'‚Ä¶':'');
  }

  function setRenButtonLabel(){
    const btn = document.getElementById('renDropdownBtn');
    const sel = Array.from(document.querySelectorAll('#renTermList input:checked')).map(x=>parseInt(x.value,10)).sort((a,b)=>a-b);
    if(!btn) return;
    if(sel.length===0){ btn.textContent = "Select"; return; }
    let contiguous = true;
    for(let i=1;i<sel.length;i++){ if(sel[i] !== sel[i-1]+1){ contiguous=false; break; } }
    btn.textContent = contiguous ? `${sel[0]}‚Äì${sel[sel.length-1]}` : sel.slice(0,6).join(',') + (sel.length>6?'‚Ä¶':'');
  }

  window.applyCfgSnapshot = function(cfg){
    if(!cfg) return;
    try{
      // Strategy
      if(typeof cfg.comfortTarget === 'number') setVal('comfortTarget', Math.round(cfg.comfortTarget*1000)/10);
      else {
        if (typeof cfg.bandLow === 'number' && typeof cfg.bandHigh === 'number'){
          var mid = (cfg.bandLow + cfg.bandHigh)/2;
          if (isFinite(mid)) setVal('comfortTarget', Math.round(mid*1000)/10);
        }
      }
      if (typeof window._syncBandsFromTarget === 'function') window._syncBandsFromTarget();
      if(cfg.convSensitivity) setVal('convSensitivity', cfg.convSensitivity);
      if(cfg.priceResponse) setVal('priceResponse', cfg.priceResponse);
      if(cfg.fpSensitivity) setVal('fpSensitivity', cfg.fpSensitivity);

      // Seasonality preset only (values already handled by existing logic upon change)
      if(cfg.seasonalityCurve) {
        setVal('seasonalityCurve', cfg.seasonalityCurve);
        // trigger preset application if helper exists
        try{ window.applySeasonalityFromUI && window.applySeasonalityFromUI(); }catch(e){}
      }

      // Renewals
      setVal('allowDecAbove', !!cfg.allowDecAbove);
      setVal('capAllTerms', !!cfg.capAllTerms);
      if(typeof cfg.pctToNew === 'number') setVal('pctToNew', Math.round(cfg.pctToNew*100));
      if(typeof cfg.renMin === 'number') setVal('renMin', Math.round(cfg.renMin*100));
      if(typeof cfg.renMax === 'number') setVal('renMax', Math.round(cfg.renMax*100));
      if(typeof cfg.renAboveMin === 'number') setVal('renAboveMin', Math.round(cfg.renAboveMin*100));
      if(typeof cfg.renAboveMax === 'number') setVal('renAboveMax', Math.round(cfg.renAboveMax*100));

      // Terms
      if(Array.isArray(cfg.nlTerms)) { setTermCheckboxes('#nlTermList', cfg.nlTerms); setNLButtonLabel(); }
      if(Array.isArray(cfg.renTerms)) { setTermCheckboxes('#renTermList', cfg.renTerms); setRenButtonLabel(); }

      // Safety
      if(cfg.changeCadence) setVal('changeCadence', cfg.changeCadence);

      // Visual feedback
      try{
        const el = document.createElement('div');
        el.className = 'note';
        el.textContent = 'Settings restored from history. Review and click Run when ready.';
        const parent = document.querySelector('.panel .card'); // first card
        if(parent) parent.prepend(el);
        setTimeout(()=>{ if(el && el.parentNode) el.parentNode.removeChild(el); }, 3000);
      }catch(e){}
    }catch(e){ console.error('applyCfgSnapshot error', e); }
  };

  // Extend history list to include "Restore" link per row
  if(typeof window.renderHistoryList === 'function'){
    const _render = window.renderHistoryList;
    window.renderHistoryList = function(){
      _render();
      const listEl = document.getElementById('historyList');
      if(!listEl) return;
      const hist = (typeof window.getHistory === 'function') ? window.getHistory() : [];
      const items = listEl.querySelectorAll('div[data-hrow]');
      if(items.length){ return; } // already enhanced
      // Rebuild with restore links
      if(!hist.length){
        listEl.innerHTML = '<em>No history yet. Run New or Renew to populate.</em>';
        return;
      }
      const rows = hist.map((h,i)=>{
        const idx = i;
        const kind = h.kind==='new' ? 'New' : (h.kind==='renew' ? 'Renew' : String(h.kind||''));
        const stamp = (function(s){ try{ return new Date(s).toLocaleString(); }catch(e){ return s; } })(h.ts);
        return `<div data-hrow="${idx}" style="padding:4px 0; border-top:1px solid #0b2035">
          <strong>#${hist.length - i}</strong> ‚Ä¢ ${kind} ‚Ä¢ rows: ${h.rows||0} ‚Ä¢ ${stamp}
          <a href="#" data-restore="${idx}" style="margin-left:8px; color:#22d3ee; text-decoration:underline;">Restore</a>
        </div>`;
      }).join('');
      listEl.innerHTML = rows;

      listEl.addEventListener('click', (e)=>{
        const a = e.target.closest('a[data-restore]');
        if(!a) return;
        e.preventDefault();
        const idx = parseInt(a.getAttribute('data-restore'),10);
        const hist2 = (typeof window.getHistory === 'function') ? window.getHistory() : [];
        const item = hist2[idx];
        if(item && item.cfg){ window.applyCfgSnapshot(item.cfg); }
      });
    };
  }
})();
</script>


<script>
(function(){
  function inHorizon(dt){
    const horizonMs = 120*86400000, now = Date.now();
    const d = new Date(dt);
    if (isNaN(d)) return false;
    const diff = d.getTime() - now;
    return diff >= 0 && diff <= horizonMs;
  }
  
  
function calcCounts(list){
  const N = list.length;
  const status = (s)=> String(s||'').toLowerCase();
  const isVac = (s)=> status(s).includes('vacant');          // 'vacant unrented', 'vacant rented', etc.
  const isNotice = (s)=> status(s).includes('notice');       // 'occupied (on-notice)', variants
  const isOccLike = (s)=> status(s).startsWith('occupied') || status(s).includes('notice');

  const occ = list.filter(r=> isOccLike(r.Status)).length;
  const vac = list.filter(r=> isVac(r.Status)).length;
  const notices = list.filter(r=> isNotice(r.Status)).length;
  const preRaw = list.filter(r=> r.PreleaseStart).length;
  const pre = Math.min(preRaw, vac + notices); // cannot replace more than pending move-outs
  const occPct = N ? (occ / N) : 0;

  // Projected/Trend if no more leases happen and all notices move out:
  // projected = 1 - ((Vacant + Notices - Prelease) / N)
  let projected = N ? (1 - ((vac + notices - pre) / N)) : 0;
  projected = Math.max(0, Math.min(1, projected)); // clamp to [0,1]

  return { N, vac, notices, pre, occ, occPct, projected };
}
function
 healthFrom(projected, occPct){
    // Simple gut-check thresholds (adjustable later)
    // Healthy: trending >= 96% or occ >= 96%
    // Watch: 93% <= trending < 96% (or occ in same band)
    // Risk: trending < 93% (or occ < 93%)
    const t = (projected||0)*100, o = (occPct||0)*100;
    if (t >= 96 || o >= 96) return {label:"Healthy", cls:"health-ok"};
    if (t >= 93 && t < 96) return {label:"Watch", cls:"health-watch"};
    return {label:"Soft", cls:"health-risk"};
  }
  function fmtPct(v){ return (isNaN(v)? '‚Äî' : (Math.round(v*1000)/10)+'%'); }
  function fmtInt(v){ return (isNaN(v)? '‚Äî' : String(v)); }

  function renderBoxScore(norm){

    const body = document.getElementById('boxScoreBody');
    const summary = document.getElementById('boxScoreSummary');
    if(!body){ return; }
    if(!Array.isArray(norm) || !norm.length){
      body.innerHTML = '<tr><td colspan="8" class="note">No data. Upload & confirm mapping, then run.</td></tr>';
      if(summary) summary.innerHTML = '';
      return;
    }
    // Community row
    const comm = calcCounts(norm);
    const h = healthFrom(comm.projected, comm.occPct);
    if(summary){
      summary.innerHTML = `
        <div class="health-chip ${h.cls}">
          <strong>Community</strong>
          <span>‚Ä¢ Units: ${fmtInt(comm.N)}</span>
          <span>‚Ä¢ Occ: ${fmtPct(comm.occPct)}</span>
          <span>‚Ä¢ Trending: ${fmtPct(comm.projected)}</span>
          <span>‚Ä¢ Notices: ${fmtInt(comm.notices)}</span>
          <span>‚Ä¢ Preleases: ${fmtInt(comm.pre)}</span>
        </div>`;
    }

    let rows = '';
    // Floorplan rows
    const byFP = (function groupBy(arr,fn){ const m=new Map(); for(const x of arr){ const k=fn(x); m.set(k,(m.get(k)||[]).concat([x])); } return m; })(norm, r=>r.Floorplan||"(unknown)");
    const fps = Array.from(byFP.keys()).sort((a,b)=>a.localeCompare(b));
    for(const fp of fps){
      const list = byFP.get(fp)||[];
      const s = calcCounts(list);
      rows += `<tr>
        <td>${fp}</td>
        <td>${fmtInt(s.N)}</td>
        <td>${fmtInt(s.vac)}</td>
        <td>${fmtInt(s.notices)}</td>
        <td>${fmtInt(s.pre)}</td>
        <td>${fmtInt(s.occ)}</td>
        <td>${fmtPct(s.occPct)}</td>
        <td>${fmtPct(s.projected)}</td>
      </tr>`;
    }
    
    // Build totals footer (community metrics)
    const foot = document.getElementById('boxScoreFoot');
    if(foot){
      const totals = calcCounts(norm);
      foot.innerHTML = `<tr style="background:#0b1220; font-weight:600; border-top:2px solid #0b2035">
        <td style="text-align:left">Totals</td>
        <td>${fmtInt(totals.N)}</td>
        <td>${fmtInt(totals.vac)}</td>
        <td>${fmtInt(totals.notices)}</td>
        <td>${fmtInt(totals.pre)}</td>
        <td>${fmtInt(totals.occ)}</td>
        <td>${fmtPct(totals.occPct)}</td>
        <td>${fmtPct(totals.projected)}</td>
      </tr>`;
    }
    body.innerHTML = rows;
  }

  // Hook into run flows: refresh box score after each Run New / Run Renew
  const _runNewBtn = document.getElementById('runNew');
  const _runRenBtn = document.getElementById('runRenew');
  function refreshAfterRun(){ try{ renderBoxScore(window.mappedRows || []); }catch(e){} }
  if(_runNewBtn){ _runNewBtn.addEventListener('click', ()=>{ Promise.resolve().then(refreshAfterRun); }); }
  if(_runRenBtn){ _runRenBtn.addEventListener('click', ()=>{ Promise.resolve().then(refreshAfterRun); }); }

  // Expose for manual refresh
  window.renderBoxScore = renderBoxScore;
})();
</script>


<script>
(function(){
  function cardFromHeading(h2){
    // walk up to the enclosing .card
    let el = h2;
    while(el && !el.classList.contains('card')) el = el.parentElement;
    return el;
  }
  function computeCards(){
    const map = { home:[], settings:[], newPricing:[], renewals:[], charts:[], history:[] };
    document.querySelectorAll('h2[data-tab-scope]').forEach(h2=>{
      const scopes = (h2.getAttribute('data-tab-scope')||'').split(/\s+/).filter(Boolean);
      const card = cardFromHeading(h2);
      if(!card) return;
      scopes.forEach(sc=>{ if(map[sc]) map[sc].push(card); });
    });
    return map;
  }
  const tabMap = computeCards();
  
  function setTab(tab){
    // buttons
    document.querySelectorAll('#tabBar [data-tab]').forEach(b=> b.classList.toggle('active', b.getAttribute('data-tab')===tab));
    // hide all cards first
    document.querySelectorAll('.card').forEach(c=> c.classList.add('tab-hidden'));
    // show those mapped to tab
    const list = tabMap[tab] || [];
    list.forEach(c=> c.classList.remove('tab-hidden'));
    window._activeTab = tab;
    // If History tab, trigger a gentle refresh on history UI (chart + list) if present
    if(tab==='history'){
      try{
        const sel = document.getElementById('fpHistorySelect');
        if(sel){
          // ensure at least one option is selected, then fire change
          if(!sel.value && sel.options && sel.options.length){ sel.value = sel.options[0].value; }
          sel.dispatchEvent(new Event('change', {bubbles:true}));
        }
        if(window.renderHistoryList) window.renderHistoryList();
      }catch(e){}
    }
  }

  // Wire clicks
  document.querySelectorAll('#tabBar [data-tab]').forEach(btn=>{
    btn.addEventListener('click', ()=> setTab(btn.getAttribute('data-tab')));
  });
  // Default tab
  setTab('settings');
  // Expose for console
  window.setTab = setTab;
})();
</script>



<script>
(function(){
  function monthKey(dt){
    const d = new Date(dt);
    if (isNaN(d)) return null;
    return d.getFullYear() + "-" + String(d.getMonth()+1).padStart(2,"0");
  }
  function monthLabelFromKey(k){
    try{
      const [y,m] = k.split("-").map(Number);
      const d = new Date(y, m-1, 1);
      return d.toLocaleString(undefined, { month: "short", year: "numeric" });
    }catch(e){ return k; }
  }
  function nextFiveMonthKeys(){
    const start = new Date();
    start.setDate(1);
    const keys = [];
    for (let i=0;i<5;i++){
      const d = new Date(start);
      d.setMonth(d.getMonth()+i);
      keys.push(d.getFullYear()+"-"+String(d.getMonth()+1).padStart(2,"0"));
    }
    return keys;
  }
  function isNoticeStatus(s){ const v = String(s||"").toLowerCase(); return v.includes("notice"); }
  function isOccupiedLike(s){ const v = String(s||"").toLowerCase(); return v.startsWith("occupied") || v.includes("notice"); }
  function computeMTMTotal(rows){
    const now = Date.now();
    let total = 0;
    for(const r of (rows||[])){
      const s = String(r.Status||"").toLowerCase();
      const isOcc = isOccupiedLike(s);
      const isMTMExplicit = s.includes("mtm") || s.includes("month-to-month") || s.includes("month to month");
      const d = new Date(r.LeaseEnd||"");
      const past = !isNaN(d) && (d.getTime() < now);
      if (isOcc && (isMTMExplicit || past)) total++;
    }
    return total;
  }
  function collectRenewedByMonth(){
    // Proxy: "Renewed" = units for which offers were generated in the latest Renewals run.
    // We dedupe by UnitID per month of LeaseEnd.
    const out = {}; // monthKey -> Set(unitId)
    try{
      if (!Array.isArray(window.__renewalsRows) || window.__renewalsRows.length <= 1) return out;
      for (let i=1;i<window.__renewalsRows.length;i++){
        const row = window.__renewalsRows[i];
        const unit = String(row[0]);
        const leaseEnd = row[2];
        const k = monthKey(leaseEnd);
        if (!k) continue;
        if (!out[k]) out[k] = new Set();
        out[k].add(unit);
      }
    }catch(e){}
    return out;
  }

  function renderRenewalSummary(rows){
    const body = document.getElementById('renewalSummaryBody');
    const mtmEl = document.getElementById('mtmSummary');
    if (!body) return;
    if (!Array.isArray(rows) || !rows.length){
      body.innerHTML = '<tr><td colspan="6" class="note">No data. Upload & confirm mapping, then run.</td></tr>';
      if (mtmEl) mtmEl.textContent = '';
      return;
    }

    const keys = nextFiveMonthKeys();
    const counts = {}; // k -> { total, notice, renewed, undecided, conv }
    keys.forEach(k => counts[k] = { total:0, notice:0, renewed:0, undecided:0, conv:"‚Äî" });

    const renewedMap = collectRenewedByMonth();

    // Tally expirations and notice
    for(const r of rows){
      const k = monthKey(r.LeaseEnd);
      if (!k || !counts[k]) continue;
      counts[k].total += 1;
      if (isNoticeStatus(r.Status)) counts[k].notice += 1;
    }

    // Renewed (offers sent) per month
    for(const k of keys){
      const set = renewedMap[k];
      counts[k].renewed = set ? set.size : 0;
    }

    // Undecided and conversion
    for(const k of keys){
      const c = counts[k];
      c.undecided = Math.max(0, c.total - c.notice - c.renewed);
      const denom = (c.total - c.notice);
      if (denom > 0){
        const pct = Math.round((c.renewed / denom) * 100);
        c.conv = String(pct) + '%';
      } else {
        c.conv = '‚Äî';
      }
    }

    const trs = keys.map(k => {
      const c = counts[k];
      return `<tr>
        <td>${monthLabelFromKey(k)}</td>
        <td>${c.total}</td>
        <td>${c.notice}</td>
        <td>${c.renewed}</td>
        <td>${c.undecided}</td>
        <td>${c.conv}</td>
      </tr>`;
    }).join('');

    body.innerHTML = trs || '<tr><td colspan="6" class="note">No expirations found in the next five months.</td></tr>';

    if (mtmEl){
      const mtm = computeMTMTotal(rows);
      mtmEl.textContent = "Month-to-month units (estimated): " + mtm + " ‚Ä¢ Note: 'Renewed' reflects offers generated in the app.";
    }
  }

  // Hook into flows
  function refresh(){ try{ renderRenewalSummary(window.mappedRows || []); }catch(e){} }

  (function wire(){
    const btnNew = document.getElementById('runNew');
    const btnRen = document.getElementById('runRenew');
    if (btnNew) btnNew.addEventListener('click', ()=>{ Promise.resolve().then(refresh); });
    if (btnRen) btnRen.addEventListener('click', ()=>{ Promise.resolve().then(refresh); });
    const confirm = document.getElementById('confirmMapping');
    if (confirm) confirm.addEventListener('click', ()=>{ setTimeout(refresh, 50); });
    document.addEventListener('DOMContentLoaded', ()=>{ refresh(); });
  })();
})();
</script>


<script>
(function(){
  function cardFromHeading(h2){
    let el = h2;
    while (el && !el.classList.contains('card')) el = el.parentElement;
    return el;
  }
  document.addEventListener('DOMContentLoaded', function(){
    // Mark all Settings cards
    document.querySelectorAll('h2[data-tab-scope*="settings"]').forEach(h2 => {
      const card = cardFromHeading(h2);
      if (card) card.classList.add('settings-card');
    });
    // Reflow Strategy top row: move New Lease Terms dropdown to a third column
    try{
      const h2s = Array.from(document.querySelectorAll('h2[data-tab-scope="settings"]'));
      const strategyH2 = h2s.find(h => h.textContent.trim() === 'Strategy');
      if (strategyH2) {
        const card = cardFromHeading(strategyH2);
        const row = card ? card.querySelector('.row') : null;
        if (row) {
          row.classList.add('strategy-row');
          // Find the inline-compact NL terms block currently under High input
          const nlBlock = card.querySelector('.inline-compact');
          if (nlBlock && nlBlock.parentElement && nlBlock.parentElement !== row) {
            // Move it to be the third grid column
            row.appendChild(nlBlock);
            // Tidy its spacing
            nlBlock.style.marginTop = '0';
            nlBlock.style.justifyContent = 'flex-end';
          }
        }
      }
    }catch(e){}
  });
})();
</script>


<script>
(function(){
  function gotoTab(name){
    const btn = document.querySelector('#tabBar [data-tab="'+name+'"]');
    if (btn) btn.click();
  }
  function clickIf(id){ const el=document.getElementById(id); if(el) el.click(); }
  function wire(){
    // Set active tab on body
    document.addEventListener('click', function(e){
      const t = e.target.closest('#tabBar [data-tab]');
      if (t) document.body.dataset.activeTab = t.getAttribute('data-tab');
    });
    const active = document.querySelector('#tabBar .active[data-tab]');
    if (active) document.body.dataset.activeTab = active.getAttribute('data-tab');

    // Home buttons that call existing controls
    const map = {
      homeRunNew:    'runNew',
      homeExportNew: 'exportNew',
      homeRunRenew:  'runRenew',
      homeExportRenew: 'exportRenew'
    };
    Object.keys(map).forEach(hid=>{
      const targetId = map[hid];
      const hb = document.getElementById(hid);
      if (hb){
        hb.addEventListener('click', ()=> clickIf(targetId));
      }
    });

    // View links
    document.querySelectorAll('[data-goto]').forEach(el=>{
      el.addEventListener('click', ()=> gotoTab(el.getAttribute('data-goto')));
    });
  }
  document.addEventListener('DOMContentLoaded', wire);
})();
</script>



<script>
(function(){
  function setTabDisabled(tab, disabled){
    const b = document.querySelector('#tabBar [data-tab="'+tab+'"]');
    if (!b) return;
    b.classList.toggle('disabled', !!disabled);
  }
  function enableNew(){ setTabDisabled('newPricing', false); }
  function enableRenew(){ setTabDisabled('renewals', false); }
  function wireLocks(){
    // Disable on load
    setTabDisabled('newPricing', true);
    setTabDisabled('renewals', true);
    // Intercept clicks on disabled tabs (allow hover for tooltip)
    const bar = document.getElementById('tabBar');
    if (bar){
      bar.addEventListener('click', function(e){
        const t = e.target.closest('[data-tab]');
        if (t && t.classList.contains('disabled')){
          e.preventDefault();
          e.stopPropagation();
          t.classList.add('wiggle');
          setTimeout(()=>t.classList.remove('wiggle'), 200);
        }
      }, true);
    }
    // If user clicks underlying (hidden) buttons anywhere, unlock
    const rn = document.getElementById('runNew');
    const rr = document.getElementById('runRenew');
    if (rn) rn.addEventListener('click', enableNew);
    if (rr) rr.addEventListener('click', enableRenew);
    // Also unlock when Home buttons are used
    const hrn = document.getElementById('homeRunNew');
    const hrr = document.getElementById('homeRunRenew');
    if (hrn) hrn.addEventListener('click', enableNew);
    if (hrr) hrr.addEventListener('click', enableRenew);
  }
  document.addEventListener('DOMContentLoaded', wireLocks);
})();
</script>



<script>
(function(){
  const LS_KEY = 'rm_lastUpload'; // value: JSON {name,time}
  function fmtTime(ts){ try{ return new Date(ts).toLocaleString(); } catch(e){ return '‚Äî'; } }
  function setDataAsOf(name, time){
    const chip = document.getElementById('homeDataAsOf');
    if (!chip) return;
    if (time){
      chip.textContent = 'Data as of ' + fmtTime(time) + (name ? (' ‚Ä¢ ' + name) : '');
    }else{
      chip.textContent = 'Data as of ‚Äî';
    }
  }
  function saveLastUpload(name, time){
    try{ localStorage.setItem(LS_KEY, JSON.stringify({name, time})); }catch(e){}
    setDataAsOf(name, time);
  }
  function loadLastUpload(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      const {name, time} = JSON.parse(raw);
      if (time) setDataAsOf(name, time);
    }catch(e){}
  }

  function computeStatus(){
    const rows = Array.isArray(window.mappedRows) ? window.mappedRows : [];
    const now = Date.now();
    const in30 = now + 30*86400000;
    let occ=0, total=0, exp30=0, undecided=0, vacant=0, notice=0, prelease=0;

    // capture renewed/offered-set from latest renewals run if available
    const renewedSet = new Set();
    try{
      if (Array.isArray(window.__renewalsRows) && window.__renewalsRows.length>1){
        for(let i=1;i<window.__renewalsRows.length;i++){ renewedSet.add(String(window.__renewalsRows[i][0])); }
      }
    }catch(e){}

    for(const r of rows){
      const s = String(r.Status||'').toLowerCase();
      // Prelease detection: any parseable future date or truthy flag
      const p = r.PreleaseStart || r.PreleaseDate || r.Prelease || r.Preleased;
      if (p){
        const pt = new Date(p).getTime();
        if (!isNaN(pt)) { if (pt >= now) prelease++; } else { prelease++; }
      }
      const isOcc = (s==='occupied' || s.startsWith('notice'));
      if (isOcc) occ++;
      total++;
      const t = new Date(r.LeaseEnd||'').getTime();
      if (!isNaN(t) && t>=now && t<=in30){
        exp30++;
        const isNotice = s.startsWith('notice');
        const unit = String(r.Unit||r.UnitID||'');
        const isRenewed = unit && renewedSet.has(unit);
        if (!isNotice && !isRenewed) undecided++;
      }
    }
    const occPct = total? Math.round((occ/total)*1000)/10 : null; // one decimal
    // Trending = 100 - ((Vacant + Notice - Prelease) / Total)*100
    const rawTrend = total? 100 - ((vacant + notice - prelease) * 100 / total) : null;
    const trendPct = (rawTrend==null) ? null : Math.max(0, Math.min(100, Math.round(rawTrend*10)/10));
    let badgeClass=''; let badgeText='‚Äî';
    if (occPct!=null){
      const low = parseFloat(document.getElementById('comfortLow')?.value || '93');
      if (occPct >= Math.max(93, low)) { badgeClass='ok'; }
      else if (occPct >= low-3) { badgeClass='warn'; }
      else { badgeClass='bad'; }
      badgeText = occPct.toFixed(1) + '%';
    }
    const badge = document.getElementById('homeOccBadge');
    if (badge){
      badge.classList.remove('ok','warn','bad');
      // update trend badge similarly
      const tBadge = document.getElementById('homeTrendBadge');
      if (tBadge){
        tBadge.classList.remove('ok','warn','bad');
        if (trendPct!=null){
          let tClass='';
          const lowT = parseFloat(document.getElementById('comfortLow')?.value || '93');
          if (trendPct >= Math.max(93, lowT)) tClass='ok';
          else if (trendPct >= lowT-3) tClass='warn';
          else tClass='bad';
          if (tClass) tBadge.classList.add(tClass);
          tBadge.textContent = trendPct.toFixed(1) + '%';
        } else {
          tBadge.textContent = '‚Äî';
        }
      }
      if (badgeClass) badge.classList.add(badgeClass);
      badge.textContent = badgeText;
    }
    const occMeta = document.getElementById('homeOccMeta');
    if (occMeta) occMeta.textContent = total? ('Based on '+total+' units ‚Ä¢ Occupied-like: '+occ) : 'Upload to compute.';

    const renText = (exp30||exp30===0) ? (undecided+' undecided of '+exp30+' expiring') : '‚Äî';
    const renEl = document.getElementById('homeRen30');
    if (renEl) renEl.textContent = renText;
    const renMeta = document.getElementById('homeRen30Meta');
    if (renMeta) renMeta.textContent = (exp30? 'Next 30 days' : '‚Äî');

    // Alerts
    const alerts = [];
    const low = parseFloat(document.getElementById('comfortLow')?.value || '93');
    if (occPct!=null && occPct < low) alerts.push('Occupancy below comfort ('+low+'%)');
    if (undecided>0) alerts.push(undecided+' renewals undecided in 30d');
    const a = document.getElementById('homeAlertsMeta');
    if (a) a.textContent = alerts.length? alerts.join(' ‚Ä¢ ') : 'No alerts.';
  }

  function wire(){
    // Load last upload from localStorage
    loadLastUpload();

    // Capture uploads globally
    document.addEventListener('change', function(e){
      const t = e.target;
      if (t && t.type==='file' && t.files && t.files[0]){
        saveLastUpload(t.files[0].name, Date.now());
        // compute soon (after mapping confirmation user can recalc again)
        setTimeout(computeStatus, 300);
      }
    }, true);

    // Recompute after mapping confirmation if present
    const cm = document.getElementById('confirmMapping');
    if (cm){
      cm.addEventListener('click', function(){ setTimeout(computeStatus, 500); });
    }

    // Also recompute after Renewals or New runs (ids may exist)
    ['runNew','runRenew'].forEach(id=>{
      const b = document.getElementById(id);
      if (b) b.addEventListener('click', ()=> setTimeout(computeStatus, 600));
    });

    // Initial compute if data already loaded
    setTimeout(computeStatus, 500);
  }
  document.addEventListener('DOMContentLoaded', wire);
})();
</script>


<script>
document.addEventListener('DOMContentLoaded', function(){
  // Make Home the landing tab
  const homeBtn = document.querySelector('#tabBar [data-tab="home"]');
  if (homeBtn) { homeBtn.click(); }
});
</script>

<script>
/* === Step 45: Forward Status widget (time-agnostic trending) === */
(function(){
  function clamp01(x){ return Math.max(0, Math.min(1, Number.isFinite(x)?x:0)); }
  function pct(x, d=1){ return (clamp01(x)*100).toFixed(d)+'%'; }
  function pp(x, d=1){ return (Number(x)||0).toFixed(d)+' pp'; }
  function setText(root, sel, v){ const el = root.querySelector(sel); if(el) el.textContent = v; }
  function classAs(el, cls){ if(!el) return; el.classList.remove('green','red','amber','neutral'); el.classList.add(cls); }

  function buildStatusSummarySafe(){
    var cfg = (typeof readCfg==='function') ? readCfg() : {};
    var totalUnits   = window.totalUnits   ?? cfg.totalUnits   ?? 0;
    var occupiedNow  = window.occupiedNow  ?? cfg.occupiedNow  ?? 0;
    var onNotice     = window.onNotice     ?? cfg.onNotice     ?? 0;
    var preleased    = window.preleased    ?? cfg.preleased    ?? 0;

    var targetOcc    = (typeof cfg.comfortTarget==='number') ? cfg.comfortTarget : (cfg.targetOcc ?? 0.95);
    var todayOcc     = totalUnits>0 ? (occupiedNow/totalUnits) : 0;

    var undecided30d = window.undecidedRenewals30d ?? cfg.undecidedRenewals30d ?? 0;
    var expiring30d  = window.expiring30d ?? cfg.expiring30d ?? 0;

    var approvals7d  = window.approvals7d ?? cfg.approvals7d ?? 0;
    var convToMoveIn = (typeof cfg.convToMoveIn==='number') ? cfg.convToMoveIn : 0.82;

    var strugglingFPs = Array.isArray(window.strugglingFPs) ? window.strugglingFPs : (cfg.strugglingFPs || []);
    var staleUnits    = Array.isArray(window.staleUnits30d) ? window.staleUnits30d : (cfg.staleUnits30d || []);

    var trendingOcc = totalUnits>0 ? ((occupiedNow + preleased - onNotice) / totalUnits) : 0;
    trendingOcc = clamp01(trendingOcc);

    var gapPP = (targetOcc - trendingOcc) * 100;
    var homesNeeded = (gapPP>0 && totalUnits>0) ? Math.ceil(totalUnits * gapPP / 100) : 0;

    var pacingPP = totalUnits>0 ? (approvals7d * convToMoveIn * (30/7) / totalUnits * 100) : 0;

    return {
      totalUnits, occupiedNow, onNotice, preleased,
      trendingOcc, todayOcc, targetOcc,
      gapPP, homesNeeded,
      undecided30d, expiring30d,
      approvals7d, convToMoveIn, pacingPP,
      strugglingFPs, staleUnits
    };
  }

  function paintStatus45(){
    var root = document.getElementById('status45-card');
    if(!root) return;
    var s = buildStatusSummarySafe();

    setText(root,'[data-kpi="trendingOcc"]', pct(s.trendingOcc, 2));
    setText(root,'[data-kpi="todayOcc"]', pct(s.todayOcc, 1));
    setText(root,'[data-kpi="targetOcc"]', pct(s.targetOcc, 0));
    classAs(document.getElementById('kpi_trending_occ'), (s.trendingOcc >= s.targetOcc) ? 'green' : 'red');

    setText(root,'[data-kpi="gapPP"]', (s.gapPP>=0?'+':'') + pp(s.gapPP,1));
    setText(root,'[data-kpi="homesNeeded"]', String(s.homesNeeded));
    classAs(document.getElementById('kpi_pacing_gap'), (s.gapPP <= 0) ? 'green' : 'red');

    setText(root,'#kpi_undecided_30d [data-kpi="undecided30d"]', String(s.undecided30d));
    setText(root,'#kpi_undecided_30d [data-kpi="expiring30d"]', String(s.expiring30d));
    var undecRate = (s.expiring30d>0) ? (s.undecided30d/s.expiring30d) : 0;
    classAs(document.getElementById('kpi_undecided_30d'), undecRate >= 0.40 ? 'red' : 'neutral');
    var undecTile = document.getElementById('kpi_undecided_30d');
    if (undecTile){
      undecTile.onclick = function(){ if (typeof showTab==='function') showTab('renewals'); };
    }

    setText(root,'#kpi_velocity_7d [data-kpi="approvals7d"]', String(s.approvals7d));
    setText(root,'#kpi_velocity_7d [data-kpi="convPct"]', (s.convToMoveIn*100).toFixed(0)+'%');
    setText(root,'#kpi_velocity_7d [data-kpi="pacingPP"]', (s.pacingPP>=0?'+':'') + s.pacingPP.toFixed(1) + ' pp');
    var helps = (s.gapPP>0 && s.pacingPP>0) || (s.gapPP<=0 && s.pacingPP>=0);
    classAs(document.getElementById('kpi_velocity_7d'), helps ? 'green' : 'red');

    var struggling = Array.isArray(s.strugglingFPs) ? s.strugglingFPs.filter(function(fp){
      return typeof fp.trendingOcc==='number' && fp.trendingOcc < s.targetOcc;
    }) : [];
    setText(root,'#alert_struggling_fps [data-kpi="strugglingCount"]', String(struggling.length));
    var listFP = root.querySelector('[data-list="fps"]');
    if(listFP){
      listFP.innerHTML = '';
      var top = struggling.slice(0,5);
      if(!top.length){
        var li = document.createElement('li'); li.className='alert-item';
        li.innerHTML = '<span>All clear</span><span><small>‚Äî</small></span>';
        listFP.appendChild(li);
      } else {
        top.forEach(function(fp){
          var gapPPv = (s.targetOcc - (fp.trendingOcc||0))*100;
          var need = (s.totalUnits>0 && gapPPv>0) ? Math.ceil(s.totalUnits*gapPPv/100) : 0;
          var li = document.createElement('li'); li.className='alert-item';
          li.innerHTML = `<span><strong>${fp.code||fp.floorplan||'‚Äî'}</strong> ‚Äî ${((fp.trendingOcc||0)*100).toFixed(1)}% <small>(${gapPPv.toFixed(1)} pp)</small></span><span><small>Need +${need} homes</small></span>`;
          li.style.cursor='pointer';
          li.onclick = function(){ if(typeof showTab==='function') showTab('newPricing'); };
          listFP.appendChild(li);
        });
      }
    }

    var stale = Array.isArray(s.staleUnits) ? s.staleUnits.slice(0,5) : [];
    setText(root,'#alert_stale_units [data-kpi="staleCount"]', String(Array.isArray(s.staleUnits)?s.staleUnits.length:0));
    var listStale = root.querySelector('[data-list="stale"]');
    if(listStale){
      listStale.innerHTML = '';
      if(!stale.length){
        var li2 = document.createElement('li'); li2.className='alert-item';
        li2.innerHTML = '<span>None</span><span><small>‚Äî</small></span>';
        listStale.appendChild(li2);
      } else {
        stale.forEach(function(u){
          var fp = u.fp || u.floorplan || '';
          var days = u.days || u.vacantDays || 0;
          var price = (typeof u.fpPrice==='number') ? u.fpPrice : (u.price || null);
          var right = (price!=null) ? (`<small>FP $${Math.round(price)}</small>`) : '<small></small>';
          var li3 = document.createElement('li'); li3.className='alert-item';
          li3.innerHTML = `<span><strong>${u.unit || u.UnitID || '‚Äî'}</strong> (${fp}) ‚Äî ${days}d</span><span>${right}</span>`;
          li3.style.cursor='pointer';
          li3.onclick = function(){ if(typeof showTab==='function') showTab('newPricing'); };
          listStale.appendChild(li3);
        });
      }
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', paintStatus45);
  } else {
    setTimeout(paintStatus45, 0);
  }
  window.repaintStatus45 = paintStatus45;
})();
</script>

<script>
/* === Step 47: Box Score upload + mapper (pacing only) === */
(function(){
  console.log('BOX SCORE WIDGET LOADED (Step 47)');

  function parseCSV(text){
    const lines = text.split(/\r?\n/).filter(Boolean);
    if(!lines.length) return { header:[], rows:[] };
    const header = lines[0].split(',').map(h=>h.trim());
    const rows = lines.slice(1).map(line=>{
      const cells = line.split(',').map(c=>c.trim());
      const obj = {}; header.forEach((h,i)=> obj[h]=cells[i]); return obj;
    });
    return { header, rows };
  }
  function byId(id){ return document.getElementById(id); }
  function opt(parent, text){ const o=document.createElement('option'); o.value=text; o.textContent=text; parent.appendChild(o); }
  function toDate(s){ const d=new Date(s); return isNaN(d)?null:d; }
  function toNum(v){ const n=Number(v); return Number.isFinite(n)?n:0; }

  function computeBoxScoreMetrics(rows){
    const today = new Date(); today.setHours(0,0,0,0);
    const d7 = new Date(today); d7.setDate(d7.getDate()-6);
    const d28 = new Date(today); d28.setDate(d28.getDate()-27);

    let approvals7d=0, leads7d=0, approvals28=0, leads28=0;
    for(const r of rows){
      const d = (function(s){ const dd=new Date(s); return isNaN(dd)?null:dd; })(r.__date);
      if(!d) continue;
      if (d >= d7 && d <= today){
        approvals7d += Number(r.__approvals)||0;
        leads7d     += Number(r.__leads)||0;
      }
      if (d >= d28 && d <= today){
        approvals28 += Number(r.__approvals)||0;
        leads28     += Number(r.__leads)||0;
      }
    }
    const conv28 = leads28>0 ? (approvals28/leads28) : null; // 0..1 or null
    // Funnel band (DISPLAY ONLY)
    // Default thresholds (can be made configurable later):
    // <20% = 'Weak' (red), 20-30% = 'Cautious' (amber), 30-40% = 'Watch' (amber), >=40% = 'Healthy' (green)
    let band = null, bandClass = 'neutral', bandLabel = 'N/A';
    if (conv28 !== null){
      const pct = conv28*100;
      if (pct < 20)        { band='Weak';     bandClass='red';   }
      else if (pct < 30)   { band='Cautious'; bandClass='amber'; }
      else if (pct < 40)   { band='Watch';    bandClass='amber'; }
      else                 { band='Healthy';  bandClass='green'; }
      bandLabel = `${band} (${pct.toFixed(0)}%, n=${leads28})`;
    }
    return { approvals7d, leads7d, approvals28, leads28, conv28, band, bandClass, bandLabel };
  }

  function feedStatusWidgetFromBox(rows){
    const m = computeBoxScoreMetrics(rows);

    // Feed existing widget metrics
    window.approvals7d = m.approvals7d || 0;
    if (m.conv28 !== null){
      window.convToMoveIn = Math.max(0, Math.min(1, m.conv28));
    }
    if (typeof window.repaintStatus45 === 'function') window.repaintStatus45();

    // Source pill on the Leasing Pacing tile
    const vel = document.getElementById('kpi_velocity_7d');
    if (vel){
      let sub = vel.querySelector('.sub');
      if (sub){
        // Ensure a ‚Äúsource pill‚Äù exists
        let srcPill = vel.querySelector('.pill-src');
        if(!srcPill){
          srcPill = document.createElement('span');
          srcPill.className = 'pill neutral pill-src';
          sub.appendChild(srcPill);
        }
        srcPill.textContent = (m.leads28>0 ? 'Box Score' : 'Manual/None');

        // Add/Update a separate Funnel band pill (display only)
        let bandPill = vel.querySelector('.pill-band');
        if(!bandPill){
          bandPill = document.createElement('span');
          bandPill.className = 'pill neutral pill-band';
          sub.appendChild(bandPill);
        }
        bandPill.textContent = m.bandLabel || 'Funnel: N/A';
        bandPill.classList.remove('green','red','amber','neutral');
        bandPill.classList.add(m.bandClass || 'neutral');
      }
    }
  }

  function initBoxUploader(){
    const fileInput = byId('boxscoreFile');
    const btnParse = byId('btnParseBoxScore');
    const meta = byId('boxscoreMeta');
    const mapWrap = byId('boxscoreMap');
    const sDate = byId('map_bs_date');
    const sLeads = byId('map_bs_leads');
    const sApps = byId('map_bs_apps');
    const sAppr = byId('map_bs_approvals');
    const btnConfirm = byId('btnConfirmBoxScore');
    if (!fileInput || !btnParse || !meta || !mapWrap) return;

    let parsed = null;
    btnParse.onclick = async function(){
      const f = fileInput.files && fileInput.files[0];
      if(!f){ meta.textContent = 'No file selected'; return; }
      const text = await f.text();
      parsed = parseCSV(text);
      if (!parsed.header.length){ meta.textContent = 'Could not parse CSV'; return; }
      [sDate,sLeads,sApps,sAppr].forEach(sel => { sel.innerHTML=''; parsed.header.forEach(h=>opt(sel,h)); });
      function guess(cols, kws){ const lc=cols.map(c=>c.toLowerCase()); for(const k of kws){ const i=lc.findIndex(x=>x.includes(k)); if(i>=0) return cols[i]; } return cols[0]; }
      sDate.value  = guess(parsed.header, ['date','day']);
      sLeads.value = guess(parsed.header, ['lead','traffic','tour']);
      sApps.value  = guess(parsed.header, ['app']);
      sAppr.value  = guess(parsed.header, ['approval','approved']);
      meta.textContent = `Parsed ${parsed.rows.length} rows`;
      mapWrap.style.display = 'block';
    };

    if (btnConfirm){
      btnConfirm.onclick = function(){
        if(!parsed){ meta.textContent='Parse a file first'; return; }
        const mapped = parsed.rows.map(r => ({ __date: r[sDate.value], __leads: r[sLeads.value], __apps: r[sApps.value], __approvals: r[sAppr.value] })).filter(r => r.__date);
        window.boxScoreRows = mapped;
        meta.textContent = `Mapped ${mapped.length} rows ‚Ä¢ ready`;
        mapWrap.style.display = 'none';
        feedStatusWidgetFromBox(mapped);
      };
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', initBoxUploader);
  } else {
    initBoxUploader();
  }
})();
</script>

<script>
// Step 48: If a Box Score was uploaded earlier in the session, re-feed the widget on load
(function(){
  if (Array.isArray(window.boxScoreRows)) {
    try { if (typeof feedStatusWidgetFromBox==='function') feedStatusWidgetFromBox(window.boxScoreRows); } catch(e){}
  }
})();
</script>
</body>
</html>
